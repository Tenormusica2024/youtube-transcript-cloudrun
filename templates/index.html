<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- CACHE BUSTER: v2025090601 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- ULTIMATE CACHE BUSTER v3.1.1 -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="last-modified" content="Sat, 30 Aug 2025 06:00:00 GMT">
    <meta name="cache-buster" content="20250907-mobile-sidebar-size-double-v2">
    <title>ŒõIIV - Intelligent Podcast Platform</title>
    
    <!-- External Styles with cache busting -->
    <link rel="stylesheet" href="/static/css/style-20250906-menu-fix.css">
    <link rel="stylesheet" href="/static/css/mobile-sidebar-size-fix.css">
    
    <!-- „Ç§„É≥„É©„Ç§„É≥CSS - „Çπ„Éû„Éº„Éà„Éï„Ç©„É≥Áâà„Çµ„Ç§„Éâ„É°„Éã„É•„ÉºÂÖ®„Çµ„Ç§„Ç∫2ÂÄçÂº∑Âà∂ÈÅ©Áî® - ÊúÄÂ§ßË©≥Á¥∞Â∫¶ -->
    <style>
        /* ÂÖ®„Çπ„ÇØ„É™„Éº„É≥„Çµ„Ç§„Ç∫„ÅßÂº∑Âà∂ÈÅ©Áî® */
        * {
            box-sizing: border-box;
        }
        
        /* üö® CRITICAL FIX: Force center main content when sidebar is hidden */
        .sidebar.hidden + .main-content,
        .sidebar.login-required.hidden + .main-content {
            margin-left: 0 !important;
            margin-right: 0 !important;
            max-width: 100vw !important;
            width: 100% !important;
        }
    </style>
    
    <!-- üö® JavaScript fix for sidebar margin override -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const sidebar = document.querySelector('.sidebar');
            const mainContent = document.querySelector('.main-content');
            
            function adjustMainContentLayout() {
                if (sidebar && mainContent) {
                    const isMobile = window.innerWidth <= 768;
                    
                    if (isMobile) {
                        // „É¢„Éê„Ç§„É´Áâà„Åß„ÅØÂ∏∏„Å´‰∏≠Â§ÆÈÖçÁΩÆÔºà„Çµ„Ç§„Éâ„Éê„ÉºÁä∂ÊÖã„Å´Èñ¢„Çè„Çâ„ÅöÔºâ
                        mainContent.style.marginLeft = '0px';
                        mainContent.style.marginRight = '0px';
                        mainContent.style.maxWidth = '100vw';
                        mainContent.style.width = '100%';
                        mainContent.style.padding = '20px';
                        console.log('Applied mobile layout - centered');
                    } else if (sidebar.classList.contains('hidden')) {
                        // „Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÁâà„Åß„Çµ„Ç§„Éâ„Éê„Éº„ÅåÈùûË°®Á§∫„ÅÆÊôÇÔºö‰∏≠Â§ÆÈÖçÁΩÆ
                        mainContent.style.marginLeft = '0px';
                        mainContent.style.marginRight = '0px';
                        mainContent.style.maxWidth = '100vw';
                        mainContent.style.width = '100%';
                        console.log('Applied JavaScript centering fix for hidden sidebar');
                    } else {
                        // „Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÁâà„Åß„Çµ„Ç§„Éâ„Éê„Éº„ÅåË°®Á§∫„ÅÆÊôÇÔºöÂè≥„Å´ÈÅø„Åë„ÇãÔºà‰ª•Ââç„ÅÆÂãï‰ΩúÔºâ
                        mainContent.style.marginLeft = '250px';
                        mainContent.style.marginRight = '0px';
                        mainContent.style.maxWidth = 'calc(100vw - 250px)';
                        mainContent.style.width = 'calc(100vw - 250px)';
                        console.log('Applied JavaScript layout for visible sidebar');
                    }
                }
            }
            
            // ÂàùÊúüË™øÊï¥
            adjustMainContentLayout();
            applyMobilePlaylistFix();
            
            // „Éó„É¨„Ç§„É™„Çπ„ÉàË¶ÅÁ¥†„ÅÆËøΩÂä†„ÇíÁõ£Ë¶ñ
            const playlistObserver = new MutationObserver(function(mutations) {
                let shouldApplyFix = false;
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // Check if any playlist actions were added
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1 && 
                                (node.classList.contains('playlist-actions') || 
                                 node.querySelector && node.querySelector('.playlist-actions'))) {
                                shouldApplyFix = true;
                            }
                        });
                    }
                });
                
                if (shouldApplyFix) {
                    setTimeout(applyMobilePlaylistFix, 100); // Â∞ë„ÅóÈÅÖÂª∂„Åï„Åõ„Å¶Á¢∫ÂÆü„Å´ÈÅ©Áî®
                }
            });
            
            // „Éâ„Ç≠„É•„É°„É≥„ÉàÂÖ®‰Ωì„ÇíÁõ£Ë¶ñ
            playlistObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÊôÇ„ÅÆË™øÊï¥
            window.addEventListener('resize', function() {
                adjustMainContentLayout();
                applyMobilePlaylistFix(); // „Éó„É¨„Ç§„É™„Çπ„Éà„É¨„Ç§„Ç¢„Ç¶„Éà„ÇÇË™øÊï¥
            });
            
            // „É¢„Éê„Ç§„É´Áâà„Éó„É¨„Ç§„É™„Çπ„Éà„Éú„Çø„É≥„É¨„Ç§„Ç¢„Ç¶„Éà‰øÆÊ≠£
            function applyMobilePlaylistFix() {
                if (window.innerWidth <= 768) {
                    const playlistActions = Array.from(document.querySelectorAll('.playlist-actions'));
                    
                    playlistActions.forEach(actions => {
                        // Container styles
                        actions.style.display = 'flex';
                        actions.style.flexDirection = 'row';
                        actions.style.flexWrap = 'wrap';
                        actions.style.gap = '8px';
                        actions.style.alignItems = 'flex-start';
                        
                        // Button styles
                        const openBtn = actions.querySelector('.playlist-open-btn');
                        const editBtn = actions.querySelector('.playlist-edit-btn');
                        const deleteBtn = actions.querySelector('.playlist-delete-btn');
                        
                        if (openBtn) {
                            openBtn.style.order = '1';
                            openBtn.style.flex = '1';
                            openBtn.style.minWidth = 'calc(50% - 4px)';
                            openBtn.style.maxWidth = 'calc(50% - 4px)';
                        }
                        
                        if (editBtn) {
                            editBtn.style.order = '1';
                            editBtn.style.flex = '1';
                            editBtn.style.minWidth = 'calc(50% - 4px)';
                            editBtn.style.maxWidth = 'calc(50% - 4px)';
                        }
                        
                        if (deleteBtn) {
                            deleteBtn.style.order = '2';
                            deleteBtn.style.flex = '1 1 100%';
                            deleteBtn.style.width = '100%';
                            deleteBtn.style.marginTop = '4px';
                        }
                    });
                    
                    console.log('Applied mobile playlist layout fix');
                }
            }
            
            // „Çµ„Ç§„Éâ„Éê„Éº„ÅÆÁä∂ÊÖãÂ§âÂåñ„ÇíÁõ£Ë¶ñ
            if (sidebar) {
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            adjustMainContentLayout();
                        }
                    });
                });
                
                observer.observe(sidebar, {
                    attributes: true,
                    attributeFilter: ['class']
                });
            }
        });
    </script>
    
    <style>
        
        /* „É¢„Éê„Ç§„É´Â∞ÇÁî®CSS - ÊúÄÂ§ßË©≥Á¥∞Â∫¶ */
        @media (max-width: 768px) {
            /* ===== „É¢„Éê„Ç§„É´„Çµ„Ç§„Éâ„Éê„Éº„Éò„ÉÉ„ÉÄ„Éº ===== */
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen div.mobile-sidebar-header,
            html body div.container div.section.mobile-sidebar-fullscreen div.mobile-sidebar-header,
            html body div#mobileMenuScreen div.mobile-sidebar-header,
            html body .mobile-sidebar-header {
                padding: 32px !important;
                border-bottom: 4px solid rgba(255, 255, 255, 0.1) !important;
                background: var(--panel) !important;
            }
            
            /* ===== „É¢„Éê„Ç§„É´„Éà„Ç∞„É´„Éú„Çø„É≥ ===== */
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen button.mobile-menu-toggle-button,
            html body div.container div.section.mobile-sidebar-fullscreen button.mobile-menu-toggle-button,
            html body div#mobileMenuScreen button.mobile-menu-toggle-button,
            html body .mobile-menu-toggle-button {
                padding: 32px !important;
                border-radius: 24px !important;
                width: auto !important;
                height: auto !important;
                background: transparent !important;
                border: none !important;
            }
            
            /* ===== „Éè„É≥„Éê„Éº„Ç¨„Éº„É©„Ç§„É≥ ===== */
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen button.mobile-menu-toggle-button span.hamburger-line,
            html body div.container div.section.mobile-sidebar-fullscreen button.mobile-menu-toggle-button span.hamburger-line,
            html body div#mobileMenuScreen button.mobile-menu-toggle-button span.hamburger-line,
            html body .mobile-menu-toggle-button .hamburger-line {
                width: 80px !important;
                height: 8px !important;
                margin: 16px 0 !important;
                border-radius: 4px !important;
                display: block !important;
                background: rgba(255, 255, 255, 0.8) !important;
            }
            
            /* ===== „Çµ„Ç§„Éâ„Éê„Éº„Ç≥„É≥„ÉÜ„É≥„ÉÑ ===== */
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen div.mobile-sidebar-content,
            html body div.container div.section.mobile-sidebar-fullscreen div.mobile-sidebar-content,
            html body div#mobileMenuScreen div.mobile-sidebar-content,
            html body .mobile-sidebar-content {
                padding: 48px 32px !important;
                height: calc(100vh - 200px) !important;
                background: var(--panel) !important;
                overflow-y: auto !important;
            }
            
            /* ===== „É°„Éã„É•„ÉºÈ†ÖÁõÆ ===== */
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen div.mobile-sidebar-content div.menu-item,
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen div.mobile-sidebar-content div.menu-item-double,
            html body div#mobileMenuScreen div.mobile-sidebar-content div.menu-item,
            html body div#mobileMenuScreen div.mobile-sidebar-content div.menu-item-double,
            html body .mobile-sidebar-content .menu-item,
            html body .mobile-sidebar-content .menu-item-double {
                padding: 24px 32px !important;
                margin: 0 16px 8px 16px !important;
                border-radius: 16px !important;
                font-size: 28px !important;
                min-height: 80px !important;
                display: flex !important;
                align-items: center !important;
                cursor: pointer !important;
                transition: all 0.2s ease !important;
                color: rgba(255, 255, 255, 0.8) !important;
                font-weight: 500 !important;
            }
            
            /* ===== „É°„Éã„É•„Éº„Ç¢„Ç§„Ç≥„É≥ ===== */
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen div.mobile-sidebar-content div.menu-item span.menu-icon,
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen div.mobile-sidebar-content div.menu-item span.menu-icon-double,
            html body div#mobileMenuScreen div.mobile-sidebar-content div.menu-item span.menu-icon,
            html body div#mobileMenuScreen div.mobile-sidebar-content div.menu-item span.menu-icon-double,
            html body .mobile-sidebar-content .menu-icon,
            html body .mobile-sidebar-content .menu-icon-double {
                font-size: 22px !important;
                margin-right: 24px !important;
                min-width: 100px !important;
                text-align: left !important;
                text-transform: uppercase !important;
                letter-spacing: 0.5px !important;
                opacity: 0.7 !important;
                font-weight: 600 !important;
            }
            
            /* ===== „É°„Éã„É•„Éº„ÉÜ„Ç≠„Çπ„Éà ===== */
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen div.mobile-sidebar-content div.menu-item span.menu-text,
            html body div.container div#mobileMenuScreen.section.mobile-sidebar-fullscreen div.mobile-sidebar-content div.menu-item span.menu-text-double,
            html body div#mobileMenuScreen div.mobile-sidebar-content div.menu-item span.menu-text,
            html body div#mobileMenuScreen div.mobile-sidebar-content div.menu-item span.menu-text-double,
            html body .mobile-sidebar-content .menu-text,
            html body .mobile-sidebar-content .menu-text-double {
                font-size: 28px !important;
                font-weight: 500 !important;
                white-space: nowrap !important;
            }
        }
    </style>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='50'>AI</text></svg>">
</head>
<body>
    
    <div class="container">
        <!-- Left Sidebar Menu -->
        <!-- „Ç¶„Çß„Éñ„Éñ„É©„Ç¶„Ç∂Áâà„Çµ„Ç§„Éâ„Éê„Éº (Web Browser Sidebar) -->
        <div class="sidebar hidden" id="sidebar">
            <div class="sidebar-header">
                <button class="menu-toggle" id="menuToggle">
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                </button>
            </div>
            <div class="sidebar-content">
                <div class="sidebar-menu">
                    <div class="menu-item active" onclick="showMainScreen()">
                        <span class="menu-icon">Home</span>
                        <span class="menu-text">„Éõ„Éº„É†</span>
                    </div>
                    <div class="menu-item" onclick="window.openPlaylistManager()">
                        <span class="menu-icon">List</span>
                        <span class="menu-text">„Éó„É¨„Ç§„É™„Çπ„Éà</span>
                    </div>
                    <div class="menu-item" onclick="window.openPodcastPlaylistManager()">
                        <span class="menu-icon">üéôÔ∏è</span>
                        <span class="menu-text">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà</span>
                    </div>
                    <div class="menu-item" onclick="showLibraryScreen()">
                        <span class="menu-icon">Library</span>
                        <span class="menu-text">„É©„Ç§„Éñ„É©„É™</span>
                    </div>
                    <div class="menu-item" onclick="openUserSearchModal()">
                        <span class="menu-icon">Search</span>
                        <span class="menu-text">Ê§úÁ¥¢</span>
                    </div>
                    <div class="menu-item" onclick="window.showProfileScreen(event)">
                        <span class="menu-icon">User</span>
                        <span class="menu-text">„Éó„É≠„Éï„Ç£„Éº„É´</span>
                    </div>
                    <div class="menu-item debug-menu-item" onclick="toggleDebugMenu()" style="border-top: 1px solid rgba(255,255,255,0.1); margin-top: 10px; padding-top: 10px;">
                        <span class="menu-icon">Debug</span>
                        <span class="menu-text">„Éá„Éê„ÉÉ„Ç∞„ÉÑ„Éº„É´</span>
                        <span class="debug-arrow">‚ñº</span>
                    </div>
                    <div class="debug-submenu" id="debugSubmenu" style="display: none;">
                        <div class="submenu-item" onclick="window.forceCacheClear()">
                            <span class="submenu-icon">üîÑ</span>
                            <span class="submenu-text">„Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢</span>
                        </div>
                        <div class="submenu-item" onclick="window.hardRefresh()">
                            <span class="submenu-icon">‚ôªÔ∏è</span>
                            <span class="submenu-text">Âº∑Âà∂„É™„É≠„Éº„Éâ</span>
                        </div>
                        <div class="submenu-item" onclick="window.clearLocalStorage()">
                            <span class="submenu-icon">üóëÔ∏è</span>
                            <span class="submenu-text">„É≠„Éº„Ç´„É´‰øùÂ≠òÂâäÈô§</span>
                        </div>
                        <div class="submenu-item" onclick="window.toggleConsoleDebug()">
                            <span class="submenu-icon">üêõ</span>
                            <span class="submenu-text">„Ç≥„É≥„ÇΩ„Éº„É´„Éá„Éê„ÉÉ„Ç∞</span>
                        </div>
                        <div class="submenu-item" onclick="window.exportDebugData()">
                            <span class="submenu-icon">üìä</span>
                            <span class="submenu-text">„Éá„Éê„ÉÉ„Ç∞„Éá„Éº„ÇøÂá∫Âäõ</span>
                        </div>
                    </div>
                    <div class="menu-item logout-menu-item" onclick="window.handleSidebarLogout()">
                        <span class="menu-icon">Logout</span>
                        <span class="menu-text">„É≠„Ç∞„Ç¢„Ç¶„Éà</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- „Çπ„Éû„Éº„Éà„Éï„Ç©„É≥Áâà„Çµ„Ç§„Éâ„Éê„Éº (Mobile/Smartphone Sidebar) - „Ç¶„Çß„Éñ„Éñ„É©„Ç¶„Ç∂Áâà„ÅÆË¶ã„ÅüÁõÆ„Å´Âêà„Çè„Åõ„Åü„Éá„Ç∂„Ç§„É≥ -->
        <div class="section hidden mobile-sidebar-fullscreen" id="mobileMenuScreen">
            <div class="mobile-sidebar-header">
                <button class="mobile-menu-toggle-button">
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                </button>
                <!-- üé® SidebarÂÜÖ„ÅÆÁµ±‰∏Ä„Éá„Ç∂„Ç§„É≥„Éà„Ç∞„É´„Éú„Çø„É≥ -->
                <button id="sidebarMenuToggle" onclick="closeMobileMenuAndExecute(() => showMainScreen())" title="„É°„Éã„É•„Éº„ÇíÈñâ„Åò„Çã" 
                        style="position: absolute !important; top: 15px !important; left: 15px !important; z-index: 10002 !important; width: 44px !important; height: 44px !important; background: var(--panel) !important; border: 1px solid rgba(159, 247, 234, 0.25) !important; border-radius: 12px !important; backdrop-filter: blur(12px) !important; display: flex !important; align-items: center !important; justify-content: center !important; padding: 0 !important; margin: 0 !important; transition: none !important; cursor: pointer !important; font-size: 0 !important; box-shadow: none !important; transform: none !important; opacity: 1 !important;">
                    <span style="font-size: 18px !important; color: rgba(159, 247, 234, 0.9) !important; font-weight: 500 !important; line-height: 1 !important; text-shadow: none !important; transition: none !important;">‚ò∞</span>
                </button>
            </div>
            <div class="mobile-sidebar-content">
                <div class="sidebar-menu mobile-menu-double">
                    <div class="menu-item menu-item-double active" onclick="closeMobileMenuAndExecute(() => showMainScreen())">
                        <span class="menu-icon menu-icon-double">Home</span>
                        <span class="menu-text menu-text-double">„Éõ„Éº„É†</span>
                    </div>
                    <div class="menu-item menu-item-double" onclick="closeMobileMenuAndExecute(() => window.openPlaylistManager())">
                        <span class="menu-icon menu-icon-double">List</span>
                        <span class="menu-text menu-text-double">„Éó„É¨„Ç§„É™„Çπ„Éà</span>
                    </div>
                    <div class="menu-item menu-item-double" onclick="closeMobileMenuAndExecute(() => window.openPodcastPlaylistManager())">
                        <span class="menu-icon menu-icon-double">üéôÔ∏è</span>
                        <span class="menu-text menu-text-double">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà</span>
                    </div>
                    <div class="menu-item menu-item-double" onclick="closeMobileMenuAndExecute(() => showLibraryScreen())">
                        <span class="menu-icon menu-icon-double">Library</span>
                        <span class="menu-text menu-text-double">„É©„Ç§„Éñ„É©„É™</span>
                    </div>
                    <div class="menu-item menu-item-double" onclick="closeMobileMenuAndExecute(() => openUserSearchModal())">
                        <span class="menu-icon menu-icon-double">Search</span>
                        <span class="menu-text menu-text-double">Ê§úÁ¥¢</span>
                    </div>
                    <div class="menu-item menu-item-double" onclick="closeMobileMenuAndExecute(() => window.showProfileScreen(event))">
                        <span class="menu-icon menu-icon-double">User</span>
                        <span class="menu-text menu-text-double">„Éó„É≠„Éï„Ç£„Éº„É´</span>
                    </div>
                    <div class="menu-item menu-item-double debug-menu-item" onclick="toggleMobileDebugMenu()" style="border-top: 2px solid rgba(255,255,255,0.1); margin-top: 20px; padding-top: 20px;">
                        <span class="menu-icon menu-icon-double">Debug</span>
                        <span class="menu-text menu-text-double">„Éá„Éê„ÉÉ„Ç∞„ÉÑ„Éº„É´</span>
                        <span class="debug-arrow debug-arrow-double">‚ñº</span>
                    </div>
                    <div class="debug-submenu debug-submenu-double" id="mobileDebugSubmenu" style="display: none;">
                        <div class="submenu-item submenu-item-double" onclick="window.forceCacheClear()">
                            <span class="submenu-icon submenu-icon-double">üîÑ</span>
                            <span class="submenu-text submenu-text-double">„Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢</span>
                        </div>
                        <div class="submenu-item submenu-item-double" onclick="window.hardRefresh()">
                            <span class="submenu-icon submenu-icon-double">‚ôªÔ∏è</span>
                            <span class="submenu-text submenu-text-double">Âº∑Âà∂„É™„É≠„Éº„Éâ</span>
                        </div>
                        <div class="submenu-item submenu-item-double" onclick="window.clearLocalStorage()">
                            <span class="submenu-icon submenu-icon-double">üóëÔ∏è</span>
                            <span class="submenu-text submenu-text-double">„É≠„Éº„Ç´„É´‰øùÂ≠òÂâäÈô§</span>
                        </div>
                        <div class="submenu-item submenu-item-double" onclick="window.toggleConsoleDebug()">
                            <span class="submenu-icon submenu-icon-double">üêõ</span>
                            <span class="submenu-text submenu-text-double">„Ç≥„É≥„ÇΩ„Éº„É´„Éá„Éê„ÉÉ„Ç∞</span>
                        </div>
                        <div class="submenu-item submenu-item-double" onclick="window.exportDebugData()">
                            <span class="submenu-icon submenu-icon-double">üìä</span>
                            <span class="submenu-text submenu-text-double">„Éá„Éê„ÉÉ„Ç∞„Éá„Éº„ÇøÂá∫Âäõ</span>
                        </div>
                    </div>
                    <div class="menu-item menu-item-double logout-menu-item" onclick="window.handleSidebarLogout()">
                        <span class="menu-icon menu-icon-double">Logout</span>
                        <span class="menu-text menu-text-double">„É≠„Ç∞„Ç¢„Ç¶„Éà</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar Overlay for Mobile -->
        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

        <!-- Main Content Area -->
        <div class="main-content">
            <div class="header">
                <div class="header-content">
                    <div class="header-left">
                        <!-- Mobile Menu Toggle Button (Login Required) -->
                        <button class="mobile-menu-toggle login-required hidden" id="mobileMenuToggle" onclick="showMobileMenuScreen()" title="„É°„Éã„É•„Éº" 
                                style="position: fixed !important; top: 15px !important; left: 15px !important; z-index: 9999 !important; width: 56px !important; height: 56px !important; background: linear-gradient(135deg, #1a1a2e, #0f0f1e) !important; border: 1px solid rgba(255, 255, 255, 0.1) !important; border-radius: 12px !important; color: rgba(255, 255, 255, 0.8) !important; font-size: 0 !important; cursor: pointer !important; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 2px 6px rgba(0, 0, 0, 0.2) !important; transition: all 0.3s ease !important; align-items: center !important; justify-content: center !important; backdrop-filter: blur(8px) !important; margin: 0 !important; padding: 0 !important; opacity: 0.8 !important; transform: none !important;"
                                onmouseover="this.style.setProperty('background', 'linear-gradient(135deg, #2a2a3e, #1a1a2e)', 'important'); this.style.setProperty('transform', 'translateY(-2px) scale(1.05)', 'important'); this.style.setProperty('box-shadow', '0 6px 18px rgba(0, 0, 0, 0.4), 0 3px 9px rgba(0, 0, 0, 0.3)', 'important'); this.style.setProperty('border-color', 'rgba(255, 255, 255, 0.2)', 'important'); this.style.setProperty('opacity', '1', 'important');"
                                onmouseout="this.style.setProperty('background', 'linear-gradient(135deg, #1a1a2e, #0f0f1e)', 'important'); this.style.setProperty('transform', 'none', 'important'); this.style.setProperty('box-shadow', '0 4px 12px rgba(0, 0, 0, 0.3), 0 2px 6px rgba(0, 0, 0, 0.2)', 'important'); this.style.setProperty('border-color', 'rgba(255, 255, 255, 0.1)', 'important'); this.style.setProperty('opacity', '0.8', 'important');">
                            <span class="mobile-menu-icon" style="display: none !important;">‚ò∞</span>
                            <span style="font-size: 20px !important; font-weight: 500 !important; line-height: 1 !important; color: rgba(255, 255, 255, 0.8) !important; text-shadow: none !important;">‚ò∞</span>
                        </button>
                        <div class="brand-logo"></div>
                        <div class="brand-text">
                            <h1 onclick="showMainScreen()" style="cursor: pointer;" title="„É°„Ç§„É≥ÁîªÈù¢„Å´Êàª„Çã">ŒõIIV <span id="versionInfo" style="font-size: 0.6em; opacity: 0.8; font-weight: bold; animation: colorShift 10s ease-in-out infinite;">v3.6.0</span></h1>
                            <p style="font-family: 'Inter', 'Segoe UI', sans-serif; font-weight: 300; letter-spacing: 0.5px; font-size: 0.95em;">Intelligent Podcast Platform</p>
                        </div>
                    </div>
                    <div class="header-right" id="headerAccount">
                        <!-- Notification Button -->
                        <button class="notification-btn login-required" onclick="toggleNotifications()" title="ÈÄöÁü•" style="display: none;">
                            <span class="notification-icon">‚úâ</span>
                            <span class="notification-badge" id="notificationBadge" style="display: none;">0</span>
                        </button>
                        <!-- Profile Access Button (Always Visible) -->
                        <button class="profile-access-btn" onclick="window.showProfileScreen(event)" title="„Éó„É≠„Éï„Ç£„Éº„É´" style="display: none;">
                            <span class="profile-icon">Profile</span>
                            <span class="profile-text"></span>
                        </button>
                        <!-- Account info will be inserted here dynamically -->
                    </div>
                </div>
            </div>

        <!-- Authentication Section -->
        <div class="section" id="authSection">
            <div class="auth-form" id="loginForm">
                <h2>„É≠„Ç∞„Ç§„É≥ / Êñ∞Ë¶èÁôªÈå≤</h2>
                <input type="email" id="email" class="auth-input" placeholder="„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ" required autocomplete="email">
                <input type="password" id="password" class="auth-input" placeholder="„Éë„Çπ„ÉØ„Éº„ÉâÔºàÔºñÊñáÂ≠ó‰ª•‰∏äÔºâ" required autocomplete="current-password">
                <button class="auth-button" id="loginBtn">
                    <span id="loginText">„É≠„Ç∞„Ç§„É≥</span>
                    <div class="loading hidden" id="loginLoading"></div>
                </button>
                <button class="auth-button" id="registerBtn" style="background: linear-gradient(45deg, #4ecdc4, #ff6b6b);">
                    <span id="registerText">Êñ∞Ë¶èÁôªÈå≤</span>
                    <div class="loading hidden" id="registerLoading"></div>
                </button>
                <div id="authMessage" class="message hidden"></div>
            </div>
            
            <div class="user-info hidden" id="userInfo">
                <div class="user-avatar" id="userAvatar">U</div>
                <h3 id="userName"></h3>
                <p id="userEmail" style="opacity: 0.7; margin-bottom: 15px;"></p>
                <div id="storageInfo" style="margin-bottom: 15px; font-size: 0.9rem; opacity: 0.8;"></div>
                <button class="auth-button" id="logoutBtn" style="background: linear-gradient(45deg, #ff6b6b, #764ba2);">„É≠„Ç∞„Ç¢„Ç¶„Éà</button>
            </div>
        </div>

        <!-- Profile Screen -->
        <div class="section hidden" id="profileScreen">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 30px;">
                <button onclick="showMainScreen()" class="back-button" title="„É°„Ç§„É≥ÁîªÈù¢„Å´Êàª„Çã">
                    ‚Üê Êàª„Çã
                </button>
                <h2 style="margin: 0;">„Éó„É≠„Éï„Ç£„Éº„É´</h2>
            </div>
            
            <!-- Profile Navigation Tabs -->
            <div class="profile-tabs">
                <button class="profile-tab active" onclick="switchProfileTab('profile')" id="profileTab">
                    <span class="tab-icon">PROFILE</span>
                    „Éó„É≠„Éï„Ç£„Éº„É´
                </button>
                <button class="profile-tab" onclick="switchProfileTab('account')" id="accountTab">
                    <span class="tab-icon">SETTINGS</span>
                    „Ç¢„Ç´„Ç¶„É≥„Éà
                </button>
                <button class="profile-tab" onclick="switchProfileTab('privacy')" id="privacyTab">
                    <span class="tab-icon">PRIVACY</span>
                    „Éó„É©„Ç§„Éê„Ç∑„Éº
                </button>
                <button class="profile-tab" onclick="switchProfileTab('notifications')" id="notificationsTab">
                    <span class="tab-icon">NOTIFY</span>
                    ÈÄöÁü•
                </button>
                <button class="profile-tab" onclick="switchProfileTab('data')" id="dataTab">
                    <span class="tab-icon">DATA</span>
                    „Éá„Éº„Çø
                </button>
            </div>

            <!-- Profile Tab Content -->
            <div class="profile-tab-content" id="profileContent">
                <div class="profile-container">
                    <div class="profile-section">
                        <h3>Âü∫Êú¨ÊÉÖÂ†±</h3>
                        <div class="profile-info">
                            <div class="profile-avatar-section">
                                <div class="profile-avatar" id="profileAvatar">U</div>
                                <input type="file" id="avatarInput" accept="image/*" style="display: none;" onchange="handleAvatarChange(event)">
                                <button class="avatar-change-btn" onclick="changeAvatar()">
                                    <span class="avatar-change-icon">EDIT</span>
                                    „Ç¢„Éê„Çø„ÉºÂ§âÊõ¥
                                </button>
                            </div>
                            <div class="profile-details">
                                <div class="profile-field">
                                    <label>Ë°®Á§∫Âêç Display Name <span class="required">*</span></label>
                                    <input type="text" id="profileDisplayName" class="auth-input" placeholder="Ë°®Á§∫Âêç„ÇíÂÖ•Âäõ" maxlength="50">
                                    <small class="field-hint field-hint-right">‰ªñ„ÅÆ„É¶„Éº„Ç∂„Éº„Å´Ë°®Á§∫„Åï„Çå„ÇãÂêçÂâç„Åß„Åô</small>
                                </div>
                                <div class="profile-field">
                                    <label>Ëá™Â∑±Á¥π‰ªã Bio</label>
                                    <textarea id="profileBio" class="auth-input" placeholder="Ëá™Â∑±Á¥π‰ªã„ÇíÂÖ•ÂäõÔºà‰ªªÊÑèÔºâ" rows="3" maxlength="200"></textarea>
                                    <small class="field-hint field-hint-counter"><span id="bioCharCount">0</span>/200</small>
                                </div>
                                <div class="profile-field">
                                    <label>„Ç¶„Çß„Éñ„Çµ„Ç§„Éà Website</label>
                                    <input type="url" id="profileWebsite" class="auth-input" placeholder="https://your-website.com">
                                </div>
                                <div class="profile-field">
                                    <label>‰ΩèÊâÄ Location</label>
                                    <input type="text" id="profileLocation" class="auth-input" placeholder="‰ΩèÊâÄ„ÄÅÈÉΩÂ∏Ç / Tokyo, Japan">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="profile-section">
                        <h3></h3>
                        <div class="storage-info">
                            <div class="storage-bar">
                                <div class="storage-used" id="storageUsedBar" style="width: 0%"></div>
                            </div>
                            <p class="storage-text">
                                <span id="storageUsedText">0 MB</span> / <span id="storageMaxText">1024 MB</span> 
                                <button class="storage-manage-btn" onclick="manageStorage()">ÁÆ°ÁêÜ</button>
                            </p>
                        </div>
                    </div>
                    
                    <div class="profile-section">
                        <h3>Áµ±Ë®àÊÉÖÂ†±</h3>
                        <div class="profile-stats">
                            <div class="stat-item">
                                <div class="stat-number" id="totalTracksCount">0</div>
                                <div class="stat-label">„Éà„É©„ÉÉ„ÇØ</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="totalPlaysCount">0</div>
                                <div class="stat-label">ÂÜçÁîüÊï∞</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="libraryTracksCount">0</div>
                                <div class="stat-label">„É©„Ç§„Éñ„É©„É™</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="followerCount">0</div>
                                <div class="stat-label">„Éï„Ç©„É≠„ÉØ„Éº</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="profile-section">
                        <div class="profile-actions">
                            <button onclick="saveProfile()" class="auth-button primary">
                                ‰øùÂ≠ò
                            </button>
                            <button onclick="resetProfileForm()" class="auth-button secondary">
                                „É™„Çª„ÉÉ„Éà
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Account Settings Tab Content -->
            <div class="profile-tab-content hidden" id="accountContent">
                <div class="profile-container">
                    <div class="profile-section">
                        <h3>„Ç¢„Ç´„Ç¶„É≥„ÉàË®≠ÂÆö</h3>
                        <div class="profile-details">
                            <div class="profile-field">
                                <label></label>
                                <input type="email" id="accountEmail" class="auth-input" readonly style="opacity: 0.6;">
                                <small class="field-hint"></small>
                            </div>
                            <div class="profile-field">
                                <label>ID</label>
                                <input type="text" id="accountUserId" class="auth-input" readonly style="opacity: 0.6; font-family: monospace;">
                                <small class="field-hint"></small>
                            </div>
                            <div class="profile-field">
                                <label></label>
                                <input type="text" id="accountCreatedDate" class="auth-input" readonly style="opacity: 0.6;">
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3></h3>
                        <div class="security-options">
                            <div class="security-item">
                                <div class="security-info">
                                    <h4></h4>
                                    <p>ÊúÄÁµÇÊõ¥Êñ∞: 2025-08-25</p>
                                </div>
                                <button onclick="changePassword()" class="auth-button secondary">
                                    <span class="btn-icon">KEY</span>
                                    
                                </button>
                            </div>
                            <div class="security-item">
                                <div class="security-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <button onclick="setup2FA()" class="auth-button secondary">
                                    <span class="btn-icon">SHIELD</span>
                                    
                                </button>
                            </div>
                            <div class="security-item">
                                <div class="security-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <button onclick="viewLoginHistory()" class="auth-button secondary">
                                    <span class="btn-icon">LOG</span>
                                    
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3></h3>
                        <div class="profile-details">
                            <div class="profile-field">
                                <label></label>
                                <select id="accountLanguage" class="auth-input">
                                    <option value="ja"></option>
                                    <option value="en">English</option>
                                    <option value="ko"></option>
                                    <option value="zh"></option>
                                </select>
                            </div>
                            <div class="profile-field">
                                <label></label>
                                <select id="accountTimezone" class="auth-input">
                                    <option value="Asia/Tokyo">Asia/Tokyo (JST)</option>
                                    <option value="America/New_York">America/New_York (EST)</option>
                                    <option value="Europe/London">Europe/London (GMT)</option>
                                    <option value="Asia/Seoul">Asia/Seoul (KST)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Privacy Settings Tab Content -->
            <div class="profile-tab-content hidden" id="privacyContent">
                <div class="profile-container">
                    <div class="profile-section">
                        <h3></h3>
                        <div class="privacy-options">
                            <div class="privacy-item">
                                <div class="privacy-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="profileVisibility" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="privacy-item">
                                <div class="privacy-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="podcastVisibility" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="privacy-item">
                                <div class="privacy-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="historyVisibility">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3></h3>
                        <div class="privacy-options">
                            <div class="privacy-item">
                                <div class="privacy-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="searchable" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="privacy-item">
                                <div class="privacy-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="recommendable" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3></h3>
                        <div class="privacy-options">
                            <div class="privacy-item">
                                <div class="privacy-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="analyticsEnabled" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="privacy-item">
                                <div class="privacy-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="personalizedAds">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Notifications Tab Content -->
            <div class="profile-tab-content hidden" id="notificationsContent">
                <div class="profile-container">
                    <div class="profile-section">
                        <h3></h3>
                        <div class="notification-methods">
                            <div class="notification-method">
                                <div class="method-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="browserNotifications">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="notification-method">
                                <div class="method-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="emailNotifications" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3></h3>
                        <div class="notification-options">
                            <div class="notification-item">
                                <div class="notification-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="newFollowerNotification" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="notification-item">
                                <div class="notification-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="interactionNotification" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="notification-item">
                                <div class="notification-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="systemNotification" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="notification-item">
                                <div class="notification-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="recommendationNotification">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3></h3>
                        <div class="profile-details">
                            <div class="profile-field">
                                <label></label>
                                <select id="notificationFrequency" class="auth-input">
                                    <option value="instant"></option>
                                    <option value="daily">11</option>
                                    <option value="weekly">1</option>
                                    <option value="never"></option>
                                </select>
                            </div>
                            <div class="profile-field">
                                <label></label>
                                <select id="notificationTime" class="auth-input">
                                    <option value="morning"> (8:00)</option>
                                    <option value="afternoon"> (14:00)</option>
                                    <option value="evening"> (18:00)</option>
                                    <option value="night"> (20:00)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Data Management Tab Content -->
            <div class="profile-tab-content hidden" id="dataContent">
                <div class="profile-container">
                    <div class="profile-section">
                        <h3></h3>
                        <div class="data-export-options">
                            <div class="export-item">
                                <div class="export-info">
                                    <h4></h4>
                                    <p>JSON</p>
                                </div>
                                <button onclick="exportProfileData()" class="auth-button secondary">
                                    <span class="btn-icon">EXPORT</span>
                                    
                                </button>
                            </div>
                            <div class="export-item">
                                <div class="export-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <button onclick="exportContentData()" class="auth-button secondary">
                                    <span class="btn-icon">MUSIC</span>
                                    
                                </button>
                            </div>
                            <div class="export-item">
                                <div class="export-info">
                                    <h4></h4>
                                    <p>CSV</p>
                                </div>
                                <button onclick="exportHistoryData()" class="auth-button secondary">
                                    <span class="btn-icon">CHART</span>
                                    
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section">
                        <h3></h3>
                        <div class="data-deletion-options">
                            <div class="deletion-item">
                                <div class="deletion-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <button onclick="clearPlayHistory()" class="auth-button warning">
                                    <span class="btn-icon">DELETE</span>
                                    
                                </button>
                            </div>
                            <div class="deletion-item">
                                <div class="deletion-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <button onclick="clearCacheData()" class="auth-button warning">
                                    <span class="btn-icon"></span>
                                    
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="profile-section danger-zone">
                        <h3></h3>
                        <div class="danger-options">
                            <div class="danger-item">
                                <div class="danger-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <button onclick="deactivateAccount()" class="auth-button danger">
                                    <span class="btn-icon">PAUSE</span>
                                    
                                </button>
                            </div>
                            <div class="danger-item">
                                <div class="danger-info">
                                    <h4></h4>
                                    <p></p>
                                </div>
                                <button onclick="deleteAccount()" class="auth-button danger">
                                    <span class="btn-icon">REMOVE</span>
                                    
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Back to Main Button (Footer) -->
            <div class="profile-footer">
                <button onclick="showMainScreen()" class="auth-button secondary large">
                    <span class="btn-icon"></span>
                    
                </button>
            </div>
        </div>

        <!-- Upload Section -->
        <div class="section" id="uploadSection">
            <div class="upload-zone" id="uploadZone">
                <div class="upload-icon">UPLOAD</div>
                <h3>Drag & Drop or Click to Upload Media Files</h3>
                <p style="opacity: 0.7; margin-top: 10px;">Up to 500MB supported (Audio: MP3, WAV, M4A | Video: MP4, WebM, AVI)</p>
            </div>
            <input type="file" id="fileInput" accept="audio/mp3,audio/mpeg,audio/wav,audio/m4a,video/mp4,video/webm,video/avi" style="display: none;">
            
            <div class="upload-input-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; margin-top: 36px;">
                <input type="text" id="trackTitle" class="auth-input" placeholder=" *" required>
                <input type="text" id="trackArtist" class="auth-input" placeholder="„Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàÂêç">
            </div>
            
            <textarea id="trackDescription" class="auth-input" placeholder="Ê•ΩÊõ≤„ÅÆË™¨ÊòéÔºà‰ªªÊÑèÔºâ" rows="3" style="resize: vertical; width: 100%; margin-bottom: 15px;"></textarea>
            
            
            <button class="auth-button" id="uploadBtn" disabled>
                <span id="uploadText">„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ</span>
                <div class="loading hidden" id="uploadLoading"></div>
            </button>
            
            <div class="progress-indicator" id="uploadProgress">
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadProgressFill"></div>
                </div>
                <div class="upload-status" id="uploadStatus">...</div>
            </div>
            
            <div id="uploadMessage" class="message hidden"></div>
            
            
            <!-- Navigation to other sections -->
            <div class="upload-navigation" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(159, 247, 234, 0.15);">
                <h3 style="margin-bottom: 20px; color: var(--text); font-size: 1.1em;">Browse Content</h3>
                <div class="library-actions">
                    <button class="library-action-btn subscription-btn" onclick="showLibrary()" title="„É©„Ç§„Éñ„É©„É™">
                        <span class="btn-text">Library</span>
                    </button>
                    <button class="library-action-btn favorites-btn" onclick="showPodcastSearchScreen()" title="Ê§úÁ¥¢">
                        <span class="btn-text">Search</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Podcast Player Section -->
        <div class="section hidden" id="podcastLibrarySection">
            <div class="library-header">
                <h2></h2>
                <div class="library-controls login-required hidden">
                    <button class="create-playlist-btn" onclick="openCreatePlaylist()" title="„Éó„É¨„Ç§„É™„Çπ„Éà‰ΩúÊàê" style="background: rgba(159, 247, 234, 0.1); border: 1px solid var(--accent); color: var(--accent); display: inline-flex; align-items: center; gap: 8px; padding: 10px 16px; height: 40px; font-size: 13px; font-weight: 500; border-radius: 6px; transition: all 0.3s ease;">
                        <span class="plus-icon">+</span>
                        <span class="btn-text">Êñ∞„Åó„ÅÑ„Éó„É¨„Ç§„É™„Çπ„Éà</span>
                    </button>
                    <button class="podcast-search-btn" onclick="showPodcastSearchScreen()" title="AI">
                        <span class="btn-text">Podcasts</span>
                    </button>
                    <button class="library-action-btn favorites-btn" onclick="showFavorites()" title="„ÅäÊ∞ó„Å´ÂÖ•„Çä">
                        <span class="btn-text">Favorites</span>
                    </button>
                    <button class="library-action-btn history-btn" onclick="showPlaybackHistory()" title="ÂÜçÁîüÂ±•Ê≠¥">
                        <span class="btn-text">History</span>
                    </button>
                    <select id="playlistSelector" class="playlist-selector">
                        <option value="all">„Åô„Åπ„Å¶„ÅÆ„Éó„É¨„Ç§„É™„Çπ„Éà</option>
                    </select>
                </div>
            </div>
            <input type="text" class="search-bar login-required hidden" id="searchBar" placeholder="„Éà„É©„ÉÉ„ÇØ„ÇíÊ§úÁ¥¢">
            
            <div id="loadingEpisodes" class="loading login-required hidden" style="margin: 20px auto; display: block;"></div>
            <div class="episode-grid login-required hidden" id="episodeGrid">
                <!-- Episodes will be loaded here -->
            </div>
            <div id="noEpisodes" class="login-required hidden" style="text-align: center; opacity: 0.7; margin: 40px 0;">
                <div style="font-size: 24px; font-weight: 600; margin-bottom: 20px; color: var(--accent);">NO EPISODES</div>
                <p><br></p>
            </div>
            
            
        </div>

        <!-- Podcast Search Section -->
        <div class="section hidden" id="podcastSearchSection">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 30px;">
                <button onclick="showMainScreen()" class="back-button" title="„É°„Ç§„É≥ÁîªÈù¢„Å´Êàª„Çã">
                    Êàª„Çã
                </button>
                <h2 style="margin: 0;">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„ÉàÊ§úÁ¥¢</h2>
            </div>
            
            <div class="search-form-container" style="margin-bottom: 25px; width: 100%;">
                <div class="podcast-search-container">
                    <input type="text" id="podcastSearchInput" class="auth-input" 
                           placeholder="AIChatGPT..." 
                           style="flex: 1; min-width: 200px; font-size: 0.8em;">
                    <select id="podcastCategoryFilter" class="auth-input podcast-category-select" 
                            style="min-width: 280px; max-width: 350px; width: 320px; font-size: 16px; padding: 12px 16px; height: 48px;">
                        <option value="all">ÂÖ®„Å¶„ÅÆ„Ç´„ÉÜ„Ç¥„É™</option>
                        <option value="ai_ml">AI„ÉªÊ©üÊ¢∞Â≠¶Áøí</option>
                        <option value="tech">„ÉÜ„ÇØ„Éé„É≠„Ç∏„Éº</option>
                        <option value="research">Á†îÁ©∂„ÉªÂ≠¶Ë°ì</option>
                        <option value="cs">„Ç≥„É≥„Éî„É•„Éº„Çø„Éº„Çµ„Ç§„Ç®„É≥„Çπ</option>
                        <option value="business">„Éì„Ç∏„Éç„Çπ„ÉªËµ∑Ê•≠</option>
                        <option value="news">„Éã„É•„Éº„Çπ„ÉªÂ†±ÈÅì</option>
                        <option value="culture">ÊñáÂåñ„ÉªÊ≠¥Âè≤</option>
                        <option value="entertainment">„Ç®„É≥„Çø„Éº„ÉÜ„Ç§„É≥„É°„É≥„Éà</option>
                        <option value="education">ÊïôËÇ≤„ÉªÂ≠¶Áøí</option>
                        <option value="science">„Çµ„Ç§„Ç®„É≥„Çπ</option>
                        <option value="health">ÂÅ•Â∫∑„ÉªÂåªÁôÇ</option>
                    </select>
                </div>
                    
                    <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap; justify-content: flex-start;">
                        <button class="auth-button" id="podcastSearchBtn" onclick="searchPodcasts()" style="background: linear-gradient(45deg, #667eea 0%, #764ba2 100%); width: auto; min-width: 100px; max-width: 150px; color: #e8e9f3; font-weight: 500; text-shadow: 0 1px 2px rgba(0,0,0,0.1); font-size: 0.8em;">
                            Ê§úÁ¥¢
                        </button>
                        <button class="auth-button" id="loadLatestEpisodesBtn" onclick="loadLatestEpisodes()" style="background: linear-gradient(45deg, #4ecdc4 0%, #44a08d 100%); width: auto; min-width: 140px; max-width: 250px; color: #e8e9f3; font-weight: 500; text-shadow: 0 1px 2px rgba(0,0,0,0.1); font-size: 0.8em;">
                            ÊúÄÊñ∞„Ç®„Éî„ÇΩ„Éº„ÉâÂèñÂæó
                        </button>
                    </div>
                    
                    <!--  -->
                    <div style="margin-top: 15px; padding: 10px; background: rgba(159, 247, 234, 0.1); border-radius: 8px; font-size: 0.9em;">
                        <strong> :</strong> Rebuild.fm, Researchat.fm, ajito.fm, fukabori.fm, Turing Complete FM
                    </div>
                </div>
                
                <!--  -->
                <div id="podcastSearchResults" class="search-results-container" style="display: none;">
                    <div class="results-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 id="searchResultsTitle" style="margin: 0;"></h3>
                        <div id="searchResultsCount" class="results-count" style="color: var(--accent); font-size: 0.9em;"></div>
                    </div>
                    
                    <div id="episodesList" class="episodes-list">
                        <!--  -->
                    </div>
                </div>
                
                <!--  -->
                <div id="podcastSearchLoading" class="loading hidden" style="margin: 20px auto; display: flex; align-items: center; justify-content: center;">
                    <div class="spinner"></div>
                </div>
                
                <!--  -->
                <div id="podcastSearchMessage" class="message hidden"></div>
            </div>
        </div>

        <!-- Subscription Manager Section -->
        <div class="section hidden" id="subscriptionManagerSection">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 30px;">
                <button onclick="showMainScreen()" class="back-button" title="„É°„Ç§„É≥ÁîªÈù¢„Å´Êàª„Çã">
                    ‚Üê Êàª„Çã
                </button>
                <h2 style="margin: 0;">Subscription Manager</h2>
            </div>
            
            <!-- RSS URL  -->
            <div class="add-subscription-container" style="margin-bottom: 30px;">
                <h3></h3>
                <div class="subscription-form">
                    <input type="url" id="rssUrlInput" class="auth-input" placeholder="RSS URL " required>
                    <button onclick="subscribeToRSS()" class="auth-button" id="subscribeBtn">
                        <span id="subscribeText">Subscribe</span>
                        <div class="loading hidden" id="subscribeLoading"></div>
                    </button>
                </div>
            </div>
            
            <!--  -->
            <div class="subscriptions-container">
                <h3></h3>
                <div id="subscriptionsList" class="subscriptions-list">
                    <!--  -->
                </div>
            </div>
            
            <!--  -->
            <div id="subscriptionLoading" class="loading hidden" style="margin: 20px auto;"></div>
            <div id="subscriptionMessage" class="message hidden"></div>
        </div>

        <!-- Favorites Section -->
        <div class="section hidden" id="favoritesSection">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 30px;">
                <button onclick="showMainScreen()" class="back-button" title="„É°„Ç§„É≥ÁîªÈù¢„Å´Êàª„Çã">
                    ‚Üê Êàª„Çã
                </button>
                <h2 style="margin: 0;">Favorites</h2>
            </div>
            
            <div id="favoritesList" class="favorites-list">
                <!--  -->
            </div>
            
            <!--  -->
            <div id="favoritesLoading" class="loading hidden" style="margin: 20px auto;"></div>
            <div id="favoritesMessage" class="message hidden"></div>
        </div>

        <!-- Playback History Section -->
        <div class="section hidden" id="playbackHistorySection">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 30px;">
                <button onclick="showMainScreen()" class="back-button" title="„É°„Ç§„É≥ÁîªÈù¢„Å´Êàª„Çã">
                    ‚Üê Êàª„Çã
                </button>
                <h2 style="margin: 0;">Playback History</h2>
            </div>
            
            <div id="historyList" class="history-list">
                <!--  -->
            </div>
            
            <!--  -->
            <div id="historyLoading" class="loading hidden" style="margin: 20px auto;"></div>
            <div id="historyMessage" class="message hidden"></div>
        </div>
    </div>

    <!-- Media Player -->
    <div class="media-player" id="mediaPlayer">
        <!-- Video Display Area (hidden for audio) -->
        <div class="video-container" id="videoContainer" style="display: none;">
            <video id="videoElement" controls style="width: 100%; height: 300px; background: #000;">
                Your browser does not support the video tag.
            </video>
        </div>
        
        <div class="player-info">
            <div class="player-title" id="playerTitle"></div>
            <div class="player-artist" id="playerArtist"></div>
            <div class="media-type-indicator" id="mediaTypeIndicator"></div>
        </div>
        
        <div class="player-controls">
            <button class="control-button" id="playPauseBtn" title="/">PLAY</button>
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
            <div class="volume-control">
                <button class="control-button" id="volumeBtn" title="Èü≥ÈáèË™øÊï¥">VOL</button>
                <div class="volume-bar" id="volumeBar">
                    <div class="volume-fill" id="volumeFill"></div>
                </div>
            </div>
            <button class="control-button" id="fullscreenBtn" title="„Éï„É´„Çπ„ÇØ„É™„Éº„É≥" style="display: none;">FULL</button>
            <button class="control-button" id="closePlayerBtn" title="„Éó„É¨„Ç§„É§„Éº„ÇíÈñâ„Åò„Çã">CLOSE</button>
        </div>
        
        <!-- Hidden audio element for audio-only playback -->
        <audio id="audioElement" style="display: none;"></audio>
    </div>

    <!-- Firebase and Application Scripts -->
    <script type="module">
        // AI FM JavaScript Loading - Version 3.6.1 (Production - Debug Removed)
        
        // 
        document.addEventListener('DOMContentLoaded', () => {
            const versionElement = document.getElementById('versionInfo');
            if (versionElement) {
                versionElement.innerHTML = 'v3.6.0 CACHE-BUSTED';
                versionElement.style.animation = 'colorShift 10s ease-in-out infinite';
                // Version element updated
            } else {
                // Version element not found
                // : body
                const fallbackVersion = document.createElement('div');
                fallbackVersion.style.cssText = 'position: fixed; top: 10px; right: 10px; background: #00ff00; color: black; padding: 5px; z-index: 9999; font-weight: bold;';
                fallbackVersion.textContent = 'v3.1.0 FORCED';
                document.body.appendChild(fallbackVersion);
            }
        });
        
        // Initialize Firebase modules globally - WITH PROPER AWAIT
        async function initializeApp() {
            try {
                console.log('INIT: Starting app initialization...');
                
                // Dynamic import to avoid caching issues
                const cacheBuster = Date.now() + Math.random().toString(36).substr(2, 9);
                console.log('INIT: Loading firebase modules...');
                const { firebaseAuth, apiClient, uploadHelper, debugHelper } = await import('/static/js/firebase-config.js?v=3.1.4-init&t=' + cacheBuster);
                
                // Make modules globally available
                window.firebaseAuth = firebaseAuth;
                window.apiClient = apiClient;
                window.uploadHelper = uploadHelper;
                window.debugHelper = debugHelper;
                
                console.log('INIT: Firebase modules loaded successfully');
                console.log('INIT: firebaseAuth =', typeof firebaseAuth);
                console.log('INIT: debugHelper =', typeof debugHelper);
                
                // Now initialize the rest of the app
                await initializeAppComponents();
                
            } catch (error) {
                console.error('INIT ERROR: Failed to load Firebase modules:', error);
            }
        }
        
        async function initializeAppComponents() {
            console.log('INIT: Initializing app components...');
            
            // Use environment detection from Firebase config
            // Debug mode only for localhost, production mode for Cloud Run
            
            // Auto-test functionality removed to allow manual user input
            
            // Setup event listeners
            setupEventListeners();
            
            // Verify critical DOM elements exist before setting up auth
            const criticalElements = ['authSection', 'loginForm', 'userInfo', 'uploadSection'];
            const missingElements = criticalElements.filter(id => !document.getElementById(id));
            
            if (missingElements.length > 0) {
                console.error('INIT ERROR: Critical DOM elements missing:', missingElements);
                return;
            }
            
            console.log('INIT: All critical DOM elements verified');
            
            // Setup Firebase auth listener
            if (window.firebaseAuth) {
                console.log('INIT: Setting up Firebase auth state listener');
                window.firebaseAuth.onAuthStateChanged(handleAuthStateChange);
                
                // Initial auth state check
                setTimeout(() => {
                    console.log('INIT: Checking initial auth state...');
                    const currentAuth = window.firebaseAuth.getCurrentUser();
                    if (currentAuth) {
                        console.log('INIT: Found existing authenticated user:', currentAuth.email);
                        handleAuthStateChange(currentAuth);
                    } else {
                        console.log('INIT: No authenticated user found');
                        handleAuthStateChange(null);
                    }
                }, 500);
            } else {
                console.error('INIT ERROR: firebaseAuth not available');
            }
        }

        // Cache clearing function
        window.forceCacheClear = async function() {
            try {
                // Clear server-side rate limits first
                // Clearing server-side rate limits
                const response = await fetch('/api/admin/clear-rate-limits', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    // Server-side rate limits cleared
                } else {
                    // Failed to clear server-side rate limits
                }
            } catch (error) {
                // Error clearing server-side rate limits
            }
            
            // Clear all caches
            localStorage.clear();
            sessionStorage.clear();
            
            // Clear service worker cache if available
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => caches.delete(name));
                });
            }
            
            // Force refreshing page
            // Force hard refresh
            window.location.reload(true);
        };
        
        // Auto cache clear on version mismatch
        const currentVersion = '20250829-fix';
        const lastVersion = localStorage.getItem('app_version');
        if (lastVersion && lastVersion !== currentVersion) {
            // Version changed, clearing cache
            localStorage.clear();
            sessionStorage.clear();
        }
        localStorage.setItem('app_version', currentVersion);

        // Application State - „Ç∞„É≠„Éº„Éê„É´„Çπ„Ç≥„Éº„Éó„ÅßÂÆöÁæ©
        let currentUser = null;
        window.currentUser = currentUser;
        let currentMedia = null; // Can be audio or video element
        let currentMediaType = 'audio'; // 'audio' or 'video'
        let currentlyPlayingId = null; // Track the currently playing episode ID
        
        // üî• FIX: Make currentMedia globally accessible to avoid null reference errors
        window.currentMedia = currentMedia;
        window.currentMediaType = currentMediaType;
        window.currentlyPlayingId = currentlyPlayingId;
        let episodes = [];
        let isUploading = false;
        let selectedFile = null; //
        
        // Constants
        const DEFAULT_BIO_MESSAGE = '„Åì„ÅÆ„É¶„Éº„Ç∂„Éº„ÅØ„Åæ„Å†„Éó„É≠„Éï„Ç£„Éº„É´Ë™¨Êòé„ÇíË®≠ÂÆö„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ'; 

        // Global functions that need to be available early
        window.toggleHeaderAccountDropdown = function(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('headerAccountDropdown');
            if (dropdown) {
                dropdown.classList.toggle('active');
            }
        };

        // DOM Elements
        const authSection = document.getElementById('authSection');
        const loginForm = document.getElementById('loginForm');
        const userInfo = document.getElementById('userInfo');
        const uploadSection = document.getElementById('uploadSection');
        const episodeGrid = document.getElementById('episodeGrid');
        const mediaPlayer = document.getElementById('mediaPlayer');
        const searchBar = document.getElementById('searchBar');
        const headerAccount = document.getElementById('headerAccount');
        // Header account element initialization

        // Legacy initialization removed - using new initialization system only

        // Setup all event listeners
        function setupEventListeners() {
            // Authentication
            document.getElementById('loginBtn').addEventListener('click', (e) => {
                // Login button clicked
                handleLogin(e);
            });
            document.getElementById('registerBtn').addEventListener('click', (e) => {
                // Register button clicked
                handleRegister(e);
            });
            document.getElementById('logoutBtn').addEventListener('click', (e) => {
                // Logout button clicked
                handleLogout(e);
            });

            // File Upload
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');
            
            if (fileInput && uploadZone) {
                uploadZone.addEventListener('click', () => {
                    // Upload zone clicked
                    fileInput.click();
                });
                uploadZone.addEventListener('dragover', handleDragOver);
                uploadZone.addEventListener('dragleave', handleDragLeave);
                uploadZone.addEventListener('drop', handleDrop);
                fileInput.addEventListener('change', (e) => {
                    // File input changed
                    handleFileSelect(e);
                });
            } else {
                // File input elements not found
            }
            
            document.getElementById('uploadBtn').addEventListener('click', handleUpload);

            // Search
            searchBar.addEventListener('input', handleSearch);

            // Media Player
            document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
            document.getElementById('closePlayerBtn').addEventListener('click', closePlayer);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            document.getElementById('progressBar').addEventListener('click', handleProgressClick);
            document.getElementById('volumeBtn').addEventListener('click', toggleMute);
            document.getElementById('volumeBar').addEventListener('click', handleVolumeClick);

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);
            
            // Setup emoji selector (needs delay for DOM to be ready)
            setTimeout(() => {
                setupEmojiSelector();
            }, 100);

            // Profile Bio Character Count
            const profileBio = document.getElementById('profileBio');
            if (profileBio) {
                profileBio.addEventListener('input', updateBioCharCount);
                profileBio.addEventListener('keyup', updateBioCharCount);
                // Initial count on load
                updateBioCharCount();
            }
        }

        // Authentication State Change Handler
        function handleAuthStateChange(user) {
            console.log('üîÑ HANDLE_AUTH_STATE_CHANGE: Called with user:', user ? `${user.email} (${user.uid})` : 'null');
            
            currentUser = user;
            window.currentUser = user; // „Ç∞„É≠„Éº„Éê„É´„Çπ„Ç≥„Éº„Éó„Åß„ÇÇÊõ¥Êñ∞
            
            // Show/hide debug mode indicator - should be visible in development mode always
            const debugIndicator = document.getElementById('debugModeIndicator');
            if (debugIndicator && window.isDevelopment) {
                debugIndicator.style.display = 'block';
                debugIndicator.classList.add('debug-active');
                console.log('üîß Debug mode indicator RE-ACTIVATED - Red line visible at top');
            }
            
            // „Çµ„Ç§„Éâ„Éê„Éº„Å®„É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆË™çË®ºÁä∂ÊÖã„Å´„Çà„ÇãÂà∂Âæ°
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.querySelector('.main-content');
            
            if (sidebar && mainContent) {
                if (!user) {
                    // Èùû„É≠„Ç∞„Ç§„É≥Áä∂ÊÖã: „Çµ„Ç§„Éâ„Éê„Éº„ÇíÂÆåÂÖ®„Å´Èö†„Åó„Å¶„É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÇíÂÖ®ÂπÖ„Å´
                    sidebar.classList.add('login-required', 'hidden');
                    sidebar.classList.remove('sidebar-hidden'); // ÊâãÂãïÈùûË°®Á§∫Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
                    mainContent.classList.add('full-width');
                    console.log('üîí Non-authenticated: Sidebar hidden, main content full width');
                } else {
                    // „É≠„Ç∞„Ç§„É≥Áä∂ÊÖã: „É¶„Éº„Ç∂„Éº„ÅÆË®≠ÂÆö„Å´Âøú„Åò„Å¶„Çµ„Ç§„Éâ„Éê„ÉºË°®Á§∫„ÇíÂà∂Âæ°
                    sidebar.classList.remove('login-required', 'hidden');
                    // Êó¢Â≠ò„ÅÆ„Çµ„Ç§„Éâ„Éê„ÉºÁä∂ÊÖã„ÇíÁ∂≠ÊåÅÔºàinitializeSidebarState„ÅßÂà∂Âæ°„Åï„Çå„ÇãÔºâ
                    console.log('‚úÖ Authenticated: Sidebar state controlled by user preference');
                    // „Çµ„Ç§„Éâ„Éê„ÉºÁä∂ÊÖã„ÅÆÂàùÊúüÂåñ„ÇíÂÆüË°å
                    setTimeout(() => {
                        initializeSidebarState();
                    }, 100);
                }
            }
            
            updateAuthUI();
            
            // ‚úÖ Ë™çË®ºÁä∂ÊÖãÂ§âÊõ¥ÊôÇ„ÅÆ„Éá„Éº„Çø„ÇØ„É™„Ç¢Âº∑ÂåñÔºàÊñ∞Ë¶èË¶Å‰ª∂ÂØæÂøúÔºâ
            if (!user) {
                // „É≠„Ç∞„Ç¢„Ç¶„ÉàÊôÇÔºö„Åô„Åπ„Å¶„ÅÆ„É¶„Éº„Ç∂„Éº„Éá„Éº„Çø„ÇíÂÆåÂÖ®„ÇØ„É™„Ç¢
                console.log('üßπ Clearing all user data on logout...');
                clearAllUserData();
            }
            
            // Always force clear cache when authentication state changes
            forceClearEpisodesCache();
            
            if (user) {
                // ‚úÖ Êñ∞Ë¶è„É≠„Ç∞„Ç§„É≥ÊôÇÔºö„Éá„Éº„ÇøÂàùÊúüÂåñ„Çí‰øùË®º
                console.log('üîÑ New login detected, ensuring clean state for user:', user.email);
                // User authenticated
                // Verify authentication with backend
                verifyAuthWithBackend();
                // Load user playlists for the selector
                loadUserPlaylists();
                // Load episodes after authentication with fresh cache
                setTimeout(() => {
                    loadEpisodes();
                }, 100);
            } else {
                // console.log('User signed out');
                // Reset playlist selection to "all" when signed out
                window.selectedPlaylistId = 'all';
                updatePlaylistSelector();
                // üö® „É≠„Ç∞„Ç¢„Ç¶„ÉàÊôÇ„ÅØloadEpisodes()„ÇíÂëº„Å∞„Å™„ÅÑÔºàË™çË®º„Ç®„É©„ÉºÂõûÈÅøÔºâ
                // setTimeout(() => {
                //     loadEpisodes();
                // }, 100);
            }
        }

        // Verify authentication with backend
        async function verifyAuthWithBackend() {
            try {
                const result = await apiClient.request('/api/auth/verify', {
                    method: 'POST'
                });
                // console.log(' Backend authentication verified:', result);
                updateStorageInfo(result);
            } catch (error) {
                console.error('Backend verification failed:', error);
                showMessage('', 'warning');
            }
        }

        // Update storage information display
        function updateStorageInfo(userData) {
            const storageInfo = document.getElementById('storageInfo');
            if (userData.storageUsed !== undefined && userData.maxStorageBytes !== undefined) {
                const usedMB = (userData.storageUsed / 1024 / 1024).toFixed(1);
                const maxMB = (userData.maxStorageBytes / 1024 / 1024).toFixed(0);
                const percentage = ((userData.storageUsed / userData.maxStorageBytes) * 100).toFixed(1);
                
                storageInfo.innerHTML = `
                    : ${usedMB} MB / ${maxMB} MB (${percentage}%)
                    <div class="progress-bar" style="margin-top: 5px; height: 4px;">
                        <div class="progress-fill" style="width: ${percentage}%"></div>
                    </div>
                `;
            }
        }

        // Authentication Functions
        async function handleLogin() {
            // console.log(' Login process starting...');
            
            const email = document.getElementById('email').value.trim();
            const password = document.getElementById('password').value;
            
            // console.log(' Login attempt for email:', email);
            // console.log('Password length:', password.length);
            
            if (!validateAuthInput(email, password)) {
                // console.log('Validation failed');
                return;
            }

            setLoadingState('login', true);
            // console.log('‚è≥ Loading state set for login');
            
            try {
                // console.log('Calling firebaseAuth.signIn...');
                const result = await firebaseAuth.signIn(email, password);
                // console.log(' Login successful:', result);
                
                showMessage('', 'success');
                clearAuthForm();
            } catch (error) {
                console.error('Login error:', error);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                showMessage(error.message || '', 'error');
            } finally {
                setLoadingState('login', false);
                // console.log(' Loading state cleared for login');
            }
        }

        async function handleRegister() {
            // console.log(' Registration process starting...');
            
            const email = document.getElementById('email').value.trim();
            const password = document.getElementById('password').value;
            
            // console.log(' Email entered:', email);
            // console.log('Password length:', password.length);
            
            if (!validateAuthInput(email, password)) {
                // console.log('Input validation failed');
                return;
            }
            
            if (password.length < 6) {
                // console.log('Password too short');
                showMessage('6', 'error');
                return;
            }

            setLoadingState('register', true);
            // console.log('‚è≥ Loading state set for registration');
            
            try {
                // console.log('Calling firebaseAuth.signUp...');
                const result = await firebaseAuth.signUp(email, password);
                // console.log(' Registration successful:', result);
                
                showMessage('', 'success');
                clearAuthForm();
            } catch (error) {
                console.error('Registration error:', error);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                showMessage(error.message || '', 'error');
            } finally {
                setLoadingState('register', false);
                // console.log(' Loading state cleared for registration');
            }
        }

        async function handleLogout() {
            try {
                // ‚úÖ „É≠„Ç∞„Ç¢„Ç¶„ÉàÂâç„Å´„É¶„Éº„Ç∂„Éº„Éá„Éº„Çø„ÇíÂÆåÂÖ®„ÇØ„É™„Ç¢
                console.log('üîÑ Starting enhanced logout process...');
                clearAllUserData();
                
                await firebaseAuth.signOut();
                showMessage('', 'success');
                // Close audio player if open
                closePlayer();
                
                console.log('‚úÖ Enhanced logout completed');
                
                // üîÑ „Éö„Éº„Ç∏„É™„Éï„É¨„ÉÉ„Ç∑„É•„ÅßÁ¢∫ÂÆü„Å´ÂàùÊúüÁä∂ÊÖã„Å´Êàª„Çã
                setTimeout(() => {
                    location.reload();
                }, 500);
            } catch (error) {
                console.error('Logout error:', error);
                showMessage('', 'error');
                // „Ç®„É©„ÉºÊôÇ„ÇÇ„É™„Éï„É¨„ÉÉ„Ç∑„É•
                setTimeout(() => {
                    location.reload();
                }, 500);
            }
        }

        // Update authentication UI
        function updateAuthUI() {
            console.log('üîÑ UPDATE_AUTH_UI: Called, currentUser:', currentUser ? 'exists' : 'null');
            
            // PHASE 1: Update body class for hamburger button visibility control
            const body = document.body;
            if (currentUser) {
                body.classList.add('logged-in');
                console.log('‚úÖ Body class added: logged-in (hamburger buttons will show)');
            } else {
                body.classList.remove('logged-in');
                console.log('üîí Body class removed: logged-in (hamburger buttons will hide)');
            }
            
            // Get fresh references to DOM elements to ensure they exist
            const authSection = document.getElementById('authSection');
            const loginForm = document.getElementById('loginForm');
            const userInfo = document.getElementById('userInfo');
            const uploadSection = document.getElementById('uploadSection');
            const sidebar = document.getElementById('sidebar');
            
            console.log('üîÑ UPDATE_AUTH_UI: Elements found -', {
                authSection: !!authSection,
                loginForm: !!loginForm,
                userInfo: !!userInfo,
                uploadSection: !!uploadSection,
                sidebar: !!sidebar
            });
            
            if (currentUser) {
                // Show authenticated state
                console.log('‚úÖ UPDATE_AUTH_UI: Showing authenticated UI for user:', currentUser.email);
                
                if (authSection) authSection.style.display = 'block';
                if (loginForm) loginForm.classList.add('hidden');
                if (userInfo) userInfo.classList.remove('hidden');
                if (uploadSection) uploadSection.classList.remove('hidden');
                
                // Show sidebar for logged-in users
                if (sidebar) sidebar.classList.remove('hidden');
                
                // Show podcast library section for logged-in users
                const librarySection = document.getElementById('podcastLibrarySection');
                if (librarySection) librarySection.classList.remove('hidden');
                
                // Add logged-in class to body for CSS targeting
                document.body.classList.add('logged-in');
                
                // Show all login-required elements
                document.querySelectorAll('.login-required').forEach(element => {
                    element.classList.remove('hidden');
                });
                
                // PHASE 2: Update hamburger button visibility based on login state
                if (typeof conditionalShowMobileToggle === 'function') {
                    conditionalShowMobileToggle();
                }
                
                // Initialize sidebar state after showing login-required elements
                setTimeout(() => {
                    initializeSidebarState();
                }, 100);
                
                // Update user info elements safely
                const userName = document.getElementById('userName');
                const userEmail = document.getElementById('userEmail');
                const userAvatar = document.getElementById('userAvatar');
                
                if (userName) userName.textContent = currentUser.displayName || currentUser.email?.split('@')[0] || '';
                if (userEmail) userEmail.textContent = currentUser.email || '';
                if (userAvatar) userAvatar.textContent = (currentUser.displayName || currentUser.email || 'U').charAt(0).toUpperCase();
                
                console.log('‚úÖ UPDATE_AUTH_UI: Authenticated UI elements updated successfully');
                
                // Update header account display
                updateHeaderAccountDisplay(currentUser);
                
                // Re-render episodes to show menu buttons
                loadEpisodes();
            } else {
                // Show login form
                console.log('üîê UPDATE_AUTH_UI: Showing login UI - user not authenticated');
                
                if (authSection) authSection.style.display = 'block';
                if (loginForm) loginForm.classList.remove('hidden');
                if (userInfo) userInfo.classList.add('hidden');
                if (uploadSection) uploadSection.classList.add('hidden');
                
                // Initialize Japanese button texts when showing login form
                setTimeout(() => {
                    if (typeof initializeButtonTexts === 'function') {
                        initializeButtonTexts();
                        console.log('üåê Japanese button texts initialized (login screen)');
                    }
                }, 10);
                
                // Hide sidebar for non-authenticated users
                if (sidebar) sidebar.classList.add('hidden');
                
                // Hide podcast library section for non-authenticated users
                const librarySection = document.getElementById('podcastLibrarySection');
                if (librarySection) librarySection.classList.add('hidden');
                
                // Remove logged-in class from body
                document.body.classList.remove('logged-in');
                
                // Hide all login-required elements
                document.querySelectorAll('.login-required').forEach(element => {
                    element.classList.add('hidden');
                });
                
                // PHASE 2: Update hamburger button visibility based on login state
                if (typeof conditionalShowMobileToggle === 'function') {
                    conditionalShowMobileToggle();
                }
                
                console.log('üîê UPDATE_AUTH_UI: Login UI elements updated successfully');
                // console.log(' DEBUG: Login UI set - loginForm classes:', loginForm.className);
                clearAuthForm();
                
                // Update header account display
                updateHeaderAccountDisplay(null);
                
                // Re-render episodes to hide menu buttons
                loadEpisodes();
            }
        }

        // ‚ö†Ô∏è ÈáçË¶Å: „Éò„ÉÉ„ÉÄ„ÉºÂè≥‰∏ä„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
        // ÈÄöÁü•„Éú„Çø„É≥„ÄÅÊ§úÁ¥¢„Éú„Çø„É≥„ÄÅ„Ç¢„Ç´„Ç¶„É≥„ÉàÊÉÖÂ†±„Å™„Å©„ÅÆÂãïÁöÑÊõ¥Êñ∞„ÅØ„Åì„Åì„ÅßË°å„Çè„Çå„Çã
        function updateHeaderAccountDisplay(user) {
            // console.log('updateHeaderAccountDisplay called with user:', !!user);
            
            // Show profile button when user is logged in
            const profileBtn = document.querySelector('.profile-access-btn');
            if (profileBtn) {
                profileBtn.style.display = user ? 'flex' : 'none';
                // console.log(' Profile button visibility:', user ? 'visible' : 'hidden');
            }
            
            if (user) {
                const displayName = user.displayName || user.email?.split('@')[0] || '';
                const avatar = (user.displayName || user.email || 'U').charAt(0).toUpperCase();
                // console.log(' Display name:', displayName, 'Avatar:', avatar);
                
                // Load user avatar from profile data
                let avatarHtml = avatar;
                
                // Try to get saved avatar from profile data
                if (window.currentUserProfile?.avatar) {
                    avatarHtml = `<img src="${window.currentUserProfile.avatar}" alt="Avatar" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                }
                
                // console.log(' Setting header account HTML');
                // ‚ö†Ô∏è ÈáçË¶Å: „Éò„ÉÉ„ÉÄ„ÉºÂè≥‰∏ä„ÅÆ„Éú„Çø„É≥ÈÖçÁΩÆ„ÅØ„Åì„Åì„ÅßÂãïÁöÑ„Å´ÁîüÊàê„Åï„Çå„Çã
                // ÈÄöÁü•„Éú„Çø„É≥„ÇÑ„Åù„ÅÆ‰ªñ„ÅÆ„Éò„ÉÉ„ÉÄ„Éº„Éú„Çø„É≥„ÅÆ‰øÆÊ≠£„ÅØ„Åì„ÅÆÈÉ®ÂàÜ„ÅßË°å„ÅÜ
                headerAccount.innerHTML = `
                    <button class="search-button" onclick="openUserSearchModal()" title="„É¶„Éº„Ç∂„ÉºÊ§úÁ¥¢">
                        <div class="search-icon"></div>
                    </button>
                    <!-- ÈÄöÁü•„Éú„Çø„É≥: „É≠„Ç∞„Ç§„É≥ÊôÇ„Å´Ë°®Á§∫„Åï„Çå„ÇãÈÄöÁü•„Ç¢„Ç§„Ç≥„É≥„Éú„Çø„É≥ -->
                    <button class="search-button" onclick="toggleNotifications()" title="ÈÄöÁü•">
                        <div class="notification-icon">‚úâ</div>
                        <span class="notification-badge" id="notificationBadge" style="display: none;">0</span>
                    </button>
                    <div class="header-account" onclick="window.toggleHeaderAccountDropdown(event)" id="headerAccountContainer">
                        <div class="header-user-avatar">${avatarHtml}</div>
                        <div class="header-user-info">
                            <div class="header-user-name">${displayName}</div>
                            <div class="header-user-email">${user.email || ''}</div>
                        </div>
                        <div class="header-account-dropdown" id="headerAccountDropdown">
                            <button class="header-dropdown-item" onclick="window.showProfileScreen(event)">
                                <div class="header-dropdown-icon">üë§</div>
                                <span>„Éó„É≠„Éï„Ç£„Éº„É´</span>
                            </button>
                            <button class="header-dropdown-item" onclick="window.showLibraryScreen(event)">
                                <div class="header-dropdown-icon">üìö</div>
                                <span>„É©„Ç§„Éñ„É©„É™</span>
                            </button>
                            <button class="header-dropdown-item" onclick="window.showSettingsScreen(event)">
                                <div class="header-dropdown-icon">‚öôÔ∏è</div>
                                <span>Ë®≠ÂÆö</span>
                            </button>
                            <button class="header-dropdown-item logout-item" onclick="window.handleHeaderLogout(event)">
                                <div class="header-dropdown-icon">üö™</div>
                                <span>„É≠„Ç∞„Ç¢„Ç¶„Éà</span>
                            </button>
                        </div>
                    </div>
                `;
                // console.log(' Header account HTML set successfully');
                
                // Ensure functions are available globally
                window.toggleHeaderAccountDropdown = toggleHeaderAccountDropdown;
                window.showProfileScreen = showProfileScreen;
                window.showLibraryScreen = showLibraryScreen;
                window.showSettingsScreen = showSettingsScreen;
                window.handleHeaderLogout = handleHeaderLogout;
                window.handleSidebarLogout = handleSidebarLogout;
                // console.log(' Global functions registered');
                
                // Verify the DOM elements are actually created
                setTimeout(() => {
                    const accountContainer = document.getElementById('headerAccountContainer');
                    const dropdown = document.getElementById('headerAccountDropdown');
                    const headerAccount = document.getElementById('headerAccount');
                    
                    // console.log(' DOM verification:');
                    // console.log('  - Header account parent found:', !!headerAccount);
                    // console.log('  - Account container found:', !!accountContainer);
                    // console.log('  - Dropdown found:', !!dropdown);
                    
                    if (headerAccount) {
                        // console.log('  - Header account innerHTML length:', headerAccount.innerHTML.length);
                        // console.log('  - Header account visible text:', headerAccount.innerText.substring(0, 50) + '...');
                    }
                    
                    if (accountContainer) {
                        // console.log('  - Click handler attribute:', accountContainer.getAttribute('onclick'));
                        // console.log('  - Account container display:', window.getComputedStyle(accountContainer).display);
                        // console.log('  - Account container cursor:', window.getComputedStyle(accountContainer).cursor);
                        // console.log('  - Account container position:', accountContainer.getBoundingClientRect());
                        // console.log('  - Account container z-index:', window.getComputedStyle(accountContainer).zIndex);
                    }
                    
                    if (dropdown) {
                        // console.log('  - Dropdown display:', window.getComputedStyle(dropdown).display);
                        // console.log('  - Dropdown classes:', dropdown.className);
                    }
                    
                    // If elements are not found, debug further
                    if (!accountContainer) {
                        console.error(' headerAccountContainer not found! Checking all header elements...');
                        const allHeaderElements = document.querySelectorAll('#headerAccount *');
                        // console.log(' All elements in headerAccount:', allHeaderElements);
                        for (let i = 0; i < allHeaderElements.length; i++) {
                            const el = allHeaderElements[i];
                            // console.log(`  ${i}: ${el.tagName} ${el.id ? '#' + el.id : ''} ${el.className ? '.' + el.className.replace(/ /g, '.') : ''}`);
                        }
                    }
                    
                    // Add event listeners manually as a backup (keep onclick as primary)
                    if (accountContainer) {
                        // Add additional click event listener as backup
                        accountContainer.addEventListener('click', (event) => {
                            // console.log(' Backup click event triggered on header account');
                            event.stopPropagation();
                            window.toggleHeaderAccountDropdown(event);
                        });
                        
                        // console.log(' Backup event listener added to account container');
                        
                        // Test if the onclick attribute is set correctly
                        const onClickAttr = accountContainer.getAttribute('onclick');
                        // console.log(' OnClick attribute:', onClickAttr);
                        
                        // Try calling the function manually to test
                        if (typeof window.toggleHeaderAccountDropdown === 'function') {
                            // console.log(' window.toggleHeaderAccountDropdown is available');
                        } else {
                            console.error(' window.toggleHeaderAccountDropdown is not available');
                        }
                    }
                    
                    // Add event listeners to dropdown items
                    const profileButton = dropdown?.querySelector('[onclick*="showProfileScreen"]');
                    if (profileButton) {
                        // Add additional event listener as backup
                        profileButton.addEventListener('click', (event) => {
                            // console.log(' Backup click event triggered on profile button');
                            event.stopPropagation();
                            window.showProfileScreen(event);
                        });
                        // console.log(' Backup event listener added to profile button');
                    }
                }, 100);
            } else {
                headerAccount.innerHTML = `
                    <div class="login-prompt">
                        <span>LOGIN</span>
                    </div>
                `;
            }
        }

        // Header account dropdown toggle function moved to global scope above

        // Close header dropdown when clicking outside
        document.addEventListener('click', (event) => {
            const dropdown = document.getElementById('headerAccountDropdown');
            const accountContainer = document.getElementById('headerAccountContainer');
            
            if (dropdown && accountContainer && 
                !accountContainer.contains(event.target) && 
                dropdown.classList.contains('active')) {
                dropdown.classList.remove('active');
            }
        });

        // Show profile screen
        function showProfileScreen(event) {
            // console.log(' showProfileScreen called');
            if (event && event.stopPropagation) {
                event.stopPropagation();
            }
            
            // Close dropdown
            const dropdown = document.getElementById('headerAccountDropdown');
            // console.log(' Dropdown element found for closing:', !!dropdown);
            if (dropdown) {
                dropdown.classList.remove('active');
                // console.log(' Dropdown closed');
            }
            
            // Hide all sections
            // console.log(' Hiding all sections');
            hideAllSections();
            
            // Show profile screen
            const profileScreen = document.getElementById('profileScreen');
            // console.log(' Profile screen element found:', !!profileScreen);
            if (profileScreen) {
                profileScreen.classList.remove('hidden');
                // console.log(' Profile screen shown');
                loadProfileData();
            } else {
                console.error(' Profile screen element not found');
            }
            
            // Scroll to top of page
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
            
            // console.log('Profile screen opened');
        }
        
        // Make function available globally immediately
        window.showProfileScreen = showProfileScreen;

        // Open user search modal
        function openUserSearchModal() {
            // console.log(' openUserSearchModal called');
            
            // Hide all sections first
            hideAllSections();
            
            // Show existing podcast search section with proper Japanese text
            const searchSection = document.getElementById('podcastSearchSection');
            if (searchSection) {
                searchSection.classList.remove('hidden');
                searchSection.style.display = 'block';
                // console.log(' Search section displayed (using existing podcastSearchSection)');
            } else {
                // console.warn(' podcastSearchSection not found, creating basic search interface');
                // Create a basic search interface if section doesn't exist
                const mainScreen = document.getElementById('mainScreen');
                if (mainScreen) {
                    const searchHTML = `
                        <div id="searchSection" style="padding: 20px;">
                            <h2 style="margin-bottom: 20px;">Ê§úÁ¥¢</h2>
                            <div style="margin-bottom: 20px;">
                                <input 
                                    type="text" 
                                    id="globalSearchInput" 
                                    placeholder="„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„ÇíÊ§úÁ¥¢..." 
                                    style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px;"
                                    onkeypress="if(event.key==='Enter') performGlobalSearch()"
                                />
                                <button 
                                    onclick="performGlobalSearch()" 
                                    style="margin-top: 10px; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer;"
                                >
                                    Ê§úÁ¥¢
                                </button>
                            </div>
                            <div id="searchResults" style="margin-top: 20px;">
                                <p style="color: #666;">Ê§úÁ¥¢ÁµêÊûú„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô</p>
                            </div>
                        </div>
                    `;
                    mainScreen.insertAdjacentHTML('beforeend', searchHTML);
                }
            }
            
            // Focus on search input if available
            const searchInput = document.getElementById('globalSearchInput');
            if (searchInput) {
                setTimeout(() => {
                    searchInput.focus();
                }, 100);
            }
            
            // console.log('Search modal opened');
        }
        
        // Perform global search
        function performGlobalSearch() {
            const searchInput = document.getElementById('globalSearchInput');
            const searchResults = document.getElementById('searchResults');
            
            if (!searchInput || !searchResults) {
                // console.warn('Search elements not found');
                return;
            }
            
            const query = searchInput.value.trim().toLowerCase();
            // console.log(' Performing search for:', query);
            
            if (!query) {
                searchResults.innerHTML = '<p style="color: #666;"></p>';
                return;
            }
            
            // Show loading
            searchResults.innerHTML = '<p style="color: #666;"> ...</p>';
            
            // Search through current episodes
            const matchingEpisodes = episodes.filter(episode => 
                episode.title?.toLowerCase().includes(query) ||
                episode.description?.toLowerCase().includes(query) ||
                episode.uploaderName?.toLowerCase().includes(query) ||
                episode.artist?.toLowerCase().includes(query)
            );
            
            // console.log(` Found ${matchingEpisodes.length} matching episodes`);
            
            if (matchingEpisodes.length === 0) {
                searchResults.innerHTML = '<p style="color: #666;"></p>';
                return;
            }
            
            // Display results
            let resultsHTML = `<h3 style="margin-bottom: 15px;"> (${matchingEpisodes.length})</h3>`;
            resultsHTML += '<div class="search-results-grid" style="display: grid; gap: 15px;">';
            
            matchingEpisodes.forEach(episode => {
                const duration = episode.durationSec ? formatDuration(episode.durationSec) : 'Unknown';
                const uploadDate = episode.createdAt ? new Date(episode.createdAt).toLocaleDateString('ja-JP') : 'Unknown';
                
                resultsHTML += `
                    <div class="search-result-item" style="border: 1px solid #eee; padding: 15px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s;" onclick="playEpisode('${episode.trackId}')">
                        <div style="font-weight: bold; margin-bottom: 5px;">${escapeHtml(episode.title)}</div>
                        <div style="color: #666; font-size: 0.9em; margin-bottom: 5px;">${escapeHtml(episode.description || '')}</div>
                        <div style="color: #888; font-size: 0.8em;">
                            BY ${escapeHtml(episode.uploaderName || 'Unknown')} | ${uploadDate} | ${duration}
                        </div>
                    </div>
                `;
            });
            
            resultsHTML += '</div>';
            searchResults.innerHTML = resultsHTML;
            
            // Add hover effects
            const resultItems = searchResults.querySelectorAll('.search-result-item');
            resultItems.forEach(item => {
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#f8f9fa';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = 'white';
                });
            });
        }
        
        // Make search functions available globally
        window.openUserSearchModal = openUserSearchModal;
        window.performGlobalSearch = performGlobalSearch;

        // Toggle header account dropdown
        function toggleHeaderAccountDropdown(event) {
            // console.log(' toggleHeaderAccountDropdown called');
            event?.stopPropagation?.();
            
            const dropdown = document.getElementById('headerAccountDropdown');
            // console.log(' Dropdown element found:', !!dropdown);
            
            if (dropdown) {
                dropdown.classList.toggle('active');
                const isActive = dropdown.classList.contains('active');
                // console.log(' Header account dropdown toggled, active:', isActive);
            } else {
                console.error(' Header account dropdown element not found');
            }
        }
        
        // Make function available globally immediately
        window.toggleHeaderAccountDropdown = toggleHeaderAccountDropdown;

        // Close dropdown when clicking outside
        document.addEventListener('click', (event) => {
            const dropdown = document.getElementById('headerAccountDropdown');
            const accountContainer = document.getElementById('headerAccountContainer');
            
            if (dropdown && accountContainer && 
                !accountContainer.contains(event.target)) {
                dropdown.classList.remove('active');
            }
        });

        // Show library screen - use existing podcastLibrarySection
        function showLibraryScreen(event) {
            if (event) event.stopPropagation();
            
            // Close dropdown
            const dropdown = document.getElementById('headerAccountDropdown');
            if (dropdown) {
                dropdown.classList.remove('active');
            }
            
            // Hide all sections
            hideAllSections();
            
            // Show existing podcast library section with proper Japanese text
            const librarySection = document.getElementById('podcastLibrarySection');
            if (librarySection) {
                librarySection.classList.remove('hidden');
                librarySection.style.display = 'block';
                // console.log('Library screen displayed (using existing podcastLibrarySection)');
            } else {
                // console.warn('podcastLibrarySection not found');
                showMessage('„É©„Ç§„Éñ„É©„É™„Çª„ÇØ„Ç∑„Éß„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
            }
        }

        // Library action functions
        function showSubscriptions() {
            document.getElementById('libraryResults').innerHTML = '<p></p>';
        }


        function showHistory() {
            document.getElementById('libraryResults').innerHTML = '<p></p>';
        }

        // Show settings screen (placeholder for future)
        function showSettingsScreen(event) {
            event.stopPropagation();
            
            // Close dropdown
            const dropdown = document.getElementById('headerAccountDropdown');
            if (dropdown) {
                dropdown.classList.remove('active');
            }
            
            showMessage('', 'warning');
            // console.log('Settings screen requested (not implemented yet)');
        }

        // Show main screen (return from profile or podcast search) - Upload screen as home
        function showMainScreen() {
            // console.log(' showMainScreen called - currentUser:', !!currentUser);
            
            // Hide all sections first
            hideAllSections();
            
            // Use updateAuthUI to restore the correct authenticated state
            updateAuthUI();
            
            // Scroll to top of page
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Show podcast search screen
        function showPodcastSearchScreen(event) {
            if (event) event.preventDefault();
            hideAllSections();
            document.getElementById('podcastSearchSection').classList.remove('hidden');
            
            // Scroll to top of page
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Show podcast library screen
        function showLibrary() {
            hideAllSections();
            document.getElementById('authSection').style.display = 'block';
            document.getElementById('podcastLibrarySection').classList.remove('hidden');
            
            // Scroll to top of page
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        //  RSS
        async function subscribeToRSS() {
            const rssUrl = document.getElementById('rssUrlInput').value.trim();
            if (!rssUrl) {
                showMessage('RSS URL', 'warning');
                return;
            }

            const subscribeBtn = document.getElementById('subscribeBtn');
            const subscribeText = document.getElementById('subscribeText');
            const subscribeLoading = document.getElementById('subscribeLoading');

            try {
                subscribeText.style.display = 'none';
                subscribeLoading.classList.remove('hidden');
                subscribeBtn.disabled = true;

                const result = await apiClient.request('/api/podcasts/subscribe', {
                    method: 'POST',
                    body: JSON.stringify({ rss_url: rssUrl })
                });

                showMessage(result.message, 'success');
                document.getElementById('rssUrlInput').value = '';
                await loadUserSubscriptions();
            } catch (error) {
                showMessage(error.message || 'RSS', 'error');
            } finally {
                subscribeText.style.display = 'inline';
                subscribeLoading.classList.add('hidden');
                subscribeBtn.disabled = false;
            }
        }

        //  
        async function loadUserSubscriptions() {
            const subscriptionsListElement = document.getElementById('subscriptionsList');
            const subscriptionLoading = document.getElementById('subscriptionLoading');

            try {
                subscriptionLoading.classList.remove('hidden');
                
                const result = await apiClient.request('/api/podcasts/subscriptions');
                
                if (result.subscriptions.length === 0) {
                    subscriptionsListElement.innerHTML = '<p class="empty-message"></p>';
                } else {
                    subscriptionsListElement.innerHTML = result.subscriptions.map(sub => `
                        <div class="subscription-item">
                            <div class="subscription-info">
                                <h4>${escapeHtml(sub.podcast_info.title)}</h4>
                                <p>${escapeHtml(sub.podcast_info.description).substring(0, 100)}...</p>
                                <div class="subscription-meta">
                                    <span>: ${new Date(sub.subscribed_at).toLocaleDateString('ja-JP')}</span>
                                    <span>: ${sub.episode_count}</span>
                                </div>
                            </div>
                            <div class="subscription-actions">
                                <button onclick="viewSubscriptionEpisodes('${sub.subscription_id}')" class="action-button">
                                    View Episodes
                                </button>
                                <button onclick="unsubscribePodcast('${sub.subscription_id}')" class="action-button remove">
                                    Unsubscribe
                                </button>
                            </div>
                        </div>
                    `).join('');
                }
            } catch (error) {
                showMessage('', 'error');
                subscriptionsListElement.innerHTML = '<p class="error-message"></p>';
            } finally {
                subscriptionLoading.classList.add('hidden');
            }
        }

        //  
        async function unsubscribePodcast(subscriptionId) {
            if (!confirm('')) return;

            try {
                const result = await apiClient.request(`/api/podcasts/subscriptions/${subscriptionId}`, {
                    method: 'DELETE'
                });

                showMessage(result.message, 'success');
                await loadUserSubscriptions();
            } catch (error) {
                showMessage(error.message || '', 'error');
            }
        }

        //  
        async function toggleFavorite(episodeId, episodeInfo) {
            try {
                // 
                const favorites = await getFavorites();
                const isFavorite = favorites.some(fav => fav.episode_id === episodeId);

                if (isFavorite) {
                    // 
                    const favorite = favorites.find(fav => fav.episode_id === episodeId);
                    await apiClient.request(`/api/favorites/${favorite.favorite_id}`, {
                        method: 'DELETE'
                    });
                    showMessage('', 'success');
                } else {
                    // 
                    await apiClient.request('/api/favorites', {
                        method: 'POST',
                        body: JSON.stringify({
                            episode_id: episodeId,
                            episode_info: episodeInfo
                        })
                    });
                    showMessage('', 'success');
                }

                // UI
                updateFavoriteButtons();
                if (document.getElementById('favoritesSection').classList.contains('hidden') === false) {
                    await loadFavorites();
                }
            } catch (error) {
                showMessage(error.message || '', 'error');
            }
        }

        //  
        async function getFavorites() {
            try {
                const result = await apiClient.request('/api/favorites');
                return result.favorites;
            } catch (error) {
                // console.warn('Failed to get favorites:', error);
                return [];
            }
        }

        async function loadFavorites() {
            const favoritesListElement = document.getElementById('favoritesList');
            const favoritesLoading = document.getElementById('favoritesLoading');

            try {
                favoritesLoading.classList.remove('hidden');
                
                const favorites = await getFavorites();
                
                if (favorites.length === 0) {
                    favoritesListElement.innerHTML = '<p class="empty-message"></p>';
                } else {
                    favoritesListElement.innerHTML = favorites.map(fav => `
                        <div class="favorite-item">
                            <div class="episode-info">
                                <h4>${escapeHtml(fav.episode_info.title || 'No Title')}</h4>
                                <p>${escapeHtml((fav.episode_info.description || '').substring(0, 100))}...</p>
                                <div class="episode-meta">
                                    <span>: ${new Date(fav.added_at).toLocaleDateString('ja-JP')}</span>
                                </div>
                            </div>
                            <div class="favorite-actions">
                                <button onclick="playEpisode('${fav.episode_id}', ${JSON.stringify(fav.episode_info).replace(/"/g, '&quot;')})" class="play-btn">
                                    
                                </button>
                                <button onclick="toggleFavorite('${fav.episode_id}', ${JSON.stringify(fav.episode_info).replace(/"/g, '&quot;')})" class="remove-favorite-btn">
                                    
                                </button>
                            </div>
                        </div>
                    `).join('');
                }
            } catch (error) {
                showMessage('', 'error');
                favoritesListElement.innerHTML = '<p class="error-message"></p>';
            } finally {
                favoritesLoading.classList.add('hidden');
            }
        }

        //  
        async function recordPlayback(episodeId, episodeInfo, progress = 0, duration = 0) {
            try {
                await apiClient.request('/api/playback-history', {
                    method: 'POST',
                    body: JSON.stringify({
                        episode_id: episodeId,
                        episode_info: episodeInfo,
                        progress: progress,
                        duration: duration
                    })
                });
            } catch (error) {
                // console.warn('Failed to record playback:', error);
            }
        }

        async function loadPlaybackHistory() {
            const historyListElement = document.getElementById('historyList');
            const historyLoading = document.getElementById('historyLoading');

            try {
                historyLoading.classList.remove('hidden');
                
                const result = await apiClient.request('/api/playback-history?limit=50');
                
                if (result.history.length === 0) {
                    historyListElement.innerHTML = '<p class="empty-message"></p>';
                } else {
                    historyListElement.innerHTML = result.history.map(history => {
                        const progressPercent = history.duration > 0 ? Math.round((history.progress / history.duration) * 100) : 0;
                        return `
                            <div class="history-item ${history.completed ? 'completed' : ''}">
                                <div class="episode-info">
                                    <h4>${escapeHtml(history.episode_info.title || 'No Title')}</h4>
                                    <p>${escapeHtml((history.episode_info.description || '').substring(0, 100))}...</p>
                                    <div class="episode-meta">
                                        <span>: ${new Date(history.last_played).toLocaleDateString('ja-JP')}</span>
                                        <span>: ${progressPercent}% ${history.completed ? '()' : ''}</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                                    </div>
                                </div>
                                <div class="history-actions">
                                    <button onclick="playEpisode('${history.episode_id}', ${JSON.stringify(history.episode_info).replace(/"/g, '&quot;')})" class="play-btn">
                                        ${history.completed ? '' : ''}
                                    </button>
                                    <button onclick="toggleFavorite('${history.episode_id}', ${JSON.stringify(history.episode_info).replace(/"/g, '&quot;')})" class="favorite-btn">
                                        
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            } catch (error) {
                showMessage('', 'error');
                historyListElement.innerHTML = '<p class="error-message"></p>';
            } finally {
                historyLoading.classList.add('hidden');
            }
        }

        //  
        function showSubscriptionManager() {
            if (!currentUser) {
                showMessage('', 'warning');
                return;
            }
            hideAllSections();
            document.getElementById('subscriptionManagerSection').classList.remove('hidden');
            loadUserSubscriptions();
            
            // Scroll to top of page
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        function showFavorites() {
            if (!currentUser) {
                showMessage('', 'warning');
                return;
            }
            
            // Check if we're on main screen or favorites section
            const favoritesSection = document.getElementById('favoritesSection');
            const mainLibraryResults = document.getElementById('mainLibraryResults');
            
            if (favoritesSection && !favoritesSection.classList.contains('hidden')) {
                // We're on the favorites screen - load favorites there
                loadFavorites();
            } else if (mainLibraryResults) {
                // We're on main screen - show favorites in main library section
                mainLibraryResults.innerHTML = '<div class="loading-item">...</div>';
                loadFavoritesInMainLibrary();
            } else {
                // Fallback to full favorites screen
                hideAllSections();
                if (favoritesSection) {
                    favoritesSection.classList.remove('hidden');
                    loadFavorites();
                    // Scroll to top of page
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                }
            }
        }
        
        async function loadFavoritesInMainLibrary() {
            const mainLibraryResults = document.getElementById('mainLibraryResults');
            
            try {
                // console.log(' Loading favorites for main library...');
                
                const token = await firebaseAuth.getIdToken();
                const response = await fetch('/api/favorites', {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const favorites = await response.json();
                // console.log(' Favorites loaded:', favorites);
                
                if (favorites.length === 0) {
                    mainLibraryResults.innerHTML = `
                        <div style="text-align: center; opacity: 0.7; padding: 30px;">
                            <div style="font-size: 48px; margin-bottom: 15px;"></div>
                            <h3 style="margin: 0 0 10px 0; color: var(--accent);"></h3>
                            <p style="margin: 0; opacity: 0.8;"></p>
                        </div>
                    `;
                    return;
                }
                
                // Create favorites grid
                const favoritesHTML = favorites.map(track => `
                    <div class="episode-card" onclick="playEpisode('${track.trackId}')">
                        <div class="episode-artwork" ${track.artwork ? `style="background-image: url('${track.artwork}')"` : ''}></div>
                        <div class="episode-info">
                            <h3 class="episode-title">${track.title || 'Untitled'}</h3>
                            <p class="episode-description">${track.description ? track.description.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, '').substring(0, 100) + (track.description.length > 100 ? '...' : '') : 'No description'}</p>
                            <div class="episode-meta">
                                <span class="episode-duration">${track.duration || ''}</span>
                                <span class="episode-date">${new Date(track.createdAt).toLocaleDateString('ja-JP')}</span>
                            </div>
                        </div>
                    </div>
                `).join('');
                
                mainLibraryResults.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: var(--accent); margin: 0;">  (${favorites.length})</h3>
                    </div>
                    <div class="episode-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px;">
                        ${favoritesHTML}
                    </div>
                `;
                
            } catch (error) {
                console.error(' Failed to load favorites:', error);
                mainLibraryResults.innerHTML = `
                    <div style="text-align: center; opacity: 0.7; padding: 30px;">
                        <div style="color: var(--danger); font-size: 24px; margin-bottom: 10px;"></div>
                        <p style="margin: 0;"></p>
                        <p style="margin: 10px 0 0 0; font-size: 0.9em; opacity: 0.7;">${error.message}</p>
                    </div>
                `;
            }
        }

        function showPlaybackHistory() {
            if (!currentUser) {
                showMessage('', 'warning');
                return;
            }
            hideAllSections();
            document.getElementById('playbackHistorySection').classList.remove('hidden');
            loadPlaybackHistory();
            
            // Scroll to top of page
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        function viewSubscriptionEpisodes(subscriptionId) {
            // 
            showMessage('', 'info');
        }

        function updateFavoriteButtons() {
            // 
            getFavorites().then(favorites => {
                const favoriteIds = favorites.map(fav => fav.episode_id);
                document.querySelectorAll('[data-episode-id]').forEach(element => {
                    const episodeId = element.getAttribute('data-episode-id');
                    const isFavorite = favoriteIds.includes(episodeId);
                    const favoriteBtn = element.querySelector('.favorite-btn');
                    if (favoriteBtn) {
                        favoriteBtn.textContent = isFavorite ? '' : '';
                        favoriteBtn.title = isFavorite ? '' : '';
                    }
                });
            }).catch(console.error);
        }

        // Make functions globally available
        window.showMainScreen = showMainScreen;
        window.showPodcastSearchScreen = showPodcastSearchScreen;
        window.showLibrary = showLibrary;
        window.showSubscriptionManager = showSubscriptionManager;
        window.showFavorites = showFavorites;
        window.showPlaybackHistory = showPlaybackHistory;
        window.searchPodcasts = searchPodcasts;
        window.loadLatestEpisodes = loadLatestEpisodes;
        window.playPodcastEpisode = playPodcastEpisode;
        window.downloadPodcastEpisode = downloadPodcastEpisode;
        window.subscribeToRSS = subscribeToRSS;
        window.unsubscribePodcast = unsubscribePodcast;
        window.toggleFavorite = toggleFavorite;
        window.viewSubscriptionEpisodes = viewSubscriptionEpisodes;

        // Load profile data
        async function loadProfileData() {
            if (!currentUser) {
                showMessage('', 'error');
                return;
            }

            try {
                // API - Fixed: Extract profile from response
                let profileData = null;
                try {
                    const response = await apiClient.request(`/api/users/${currentUser.uid}/profile`);
                    // console.log('üîç [DEBUG] Profile API response:', response);
                    // Extract profile from response object
                    profileData = response?.profile || response;
                    // console.log('[DEBUG] Profile data extracted:', profileData);
                } catch (error) {
                    console.error('[DEBUG] Profile API error:', error);
                    // console.warn('API failed, using fallback profile');
                }

                // Store profile data globally for header avatar access
                window.currentUserProfile = profileData;

                // Display name and avatar handling
                const displayName = profileData?.displayName || currentUser.displayName || currentUser.email?.split('@')[0] || '';
                const avatar = displayName.charAt(0).toUpperCase();

                // Load avatar image or fallback to text
                const profileAvatar = document.getElementById('profileAvatar');
                if (profileData?.avatar) {
                    profileAvatar.innerHTML = `<img src="${profileData.avatar}" alt="Avatar" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                } else {
                    profileAvatar.textContent = avatar;
                }

                // Update header avatar if needed
                const headerAvatar = document.querySelector('.header-user-avatar');
                if (headerAvatar && profileData?.avatar) {
                    headerAvatar.innerHTML = `<img src="${profileData.avatar}" alt="Avatar" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                }
                document.getElementById('profileDisplayName').value = displayName;
                document.getElementById('profileBio').value = profileData?.bio || DEFAULT_BIO_MESSAGE;
                document.getElementById('profileWebsite').value = profileData?.website || '';
                document.getElementById('profileLocation').value = profileData?.location || '';
                
                // 
                if (document.getElementById('accountEmail')) {
                    document.getElementById('accountEmail').value = currentUser.email || '';
                }
                if (document.getElementById('accountUserId')) {
                    document.getElementById('accountUserId').value = currentUser.uid || '';
                }

                // 
                if (currentUser.storageUsed !== undefined && currentUser.maxStorageBytes !== undefined) {
                    const usedMB = Math.round(currentUser.storageUsed / (1024 * 1024));
                    const maxMB = Math.round(currentUser.maxStorageBytes / (1024 * 1024));
                    const usedPercentage = (currentUser.storageUsed / currentUser.maxStorageBytes) * 100;

                    document.getElementById('storageUsedText').textContent = `${usedMB} MB`;
                    document.getElementById('storageMaxText').textContent = `${maxMB} MB`;
                    document.getElementById('storageUsedBar').style.width = `${Math.min(usedPercentage, 100)}%`;
                }

                // 
                updateBioCharCount();

                // 
                await loadUserProfileStats();

                // console.log('Profile data loaded successfully');
            } catch (error) {
                console.error('Error loading profile data:', error);
                showMessage('', 'error');
            }
        }

        // Update profile
        async function updateProfile() {
            if (!currentUser) {
                showMessage('', 'error');
                return;
            }

            try {
                const displayName = document.getElementById('profileDisplayName').value.trim();
                const bio = document.getElementById('profileBio').value.trim();
                const website = document.getElementById('profileWebsite').value.trim();
                const location = document.getElementById('profileLocation').value.trim();
                
                if (!displayName) {
                    showMessage('', 'error');
                    return;
                }

                setLoadingState('update', true);
                showMessage('...', 'warning');

                // Prepare form data with avatar if available
                const formData = {
                    displayName: displayName,
                    bio: bio,
                    website: website,
                    location: location
                };

                // Add avatar data if available
                if (window.pendingAvatarData) {
                    formData.avatar = window.pendingAvatarData;
                }

                // API
                const response = await apiClient.request('/api/users/profile', {
                    method: 'POST',
                    body: JSON.stringify(formData)
                });
                
                // Clear pending avatar data after successful save
                if (window.pendingAvatarData) {
                    delete window.pendingAvatarData;
                }

                showMessage('„Éó„É≠„Éï„Ç£„Éº„É´„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü', 'success');
                // console.log('Profile update completed:', response);
                
                // UI
                currentUser.displayName = displayName;
                updateHeaderAccountDisplay(currentUser);
                
                // 
                await loadUserProfileStats();
                
            } catch (error) {
                console.error('Profile update error:', error);
                showMessage(': ' + error.message, 'error');
            } finally {
                setLoadingState('update', false);
            }
        }

        // Load user profile statistics
        async function loadUserProfileStats() {
            if (!currentUser) {
                return;
            }

            try {
                // console.log('üîç [DEBUG] Loading profile stats for user:', currentUser.uid);
                // Get user statistics from profile API
                const response = await apiClient.request(`/api/users/${currentUser.uid}/profile`);
                // console.log('üîç [DEBUG] Profile stats response:', response);
                
                const profileData = response?.profile || response;
                const totalTracks = profileData?.trackCount || 0;
                const totalDurationMinutes = profileData?.totalDurationMinutes || 0;
                const followersCount = profileData?.followersCount || 0;
                const joinedDate = profileData?.joinedDate || '';
                
                // console.log('[DEBUG] Profile stats extracted:', {
                //     tracks: totalTracks,
                //     duration: totalDurationMinutes,
                //     followers: followersCount,
                //     joined: joinedDate
                // });
                
                // Update stats display
                if (document.getElementById('userEpisodesCount')) {
                    document.getElementById('userEpisodesCount').textContent = totalTracks.toString();
                }
                if (document.getElementById('userTotalPlays')) {
                    document.getElementById('userTotalPlays').textContent = followersCount.toString();
                }
                if (document.getElementById('userTotalDuration')) {
                    document.getElementById('userTotalDuration').textContent = `${totalDurationMinutes} minutes`;
                }
                if (document.getElementById('userJoinedDate')) {
                    document.getElementById('userJoinedDate').textContent = joinedDate;
                }
                
                // console.log('[DEBUG] User profile stats loaded successfully');
            } catch (error) {
                // console.warn('Could not load user stats:', error);
                // Set default values if API fails
                if (document.getElementById('userEpisodesCount')) {
                    document.getElementById('userEpisodesCount').textContent = '0';
                }
                if (document.getElementById('userTotalPlays')) {
                    document.getElementById('userTotalPlays').textContent = '0';
                }
            }
        }

        // Update bio character count
        function updateBioCharCount() {
            const bioTextarea = document.getElementById('profileBio');
            const charCountElement = document.getElementById('bioCharCount');
            
            if (!bioTextarea || !charCountElement) {
                return;
            }
            
            const currentLength = bioTextarea.value.length;
            const maxLength = 300;
            const remaining = maxLength - currentLength;
            
            charCountElement.textContent = `${currentLength}/${maxLength}`;
            
            // Color coding based on remaining characters
            if (remaining < 0) {
                charCountElement.className = 'char-count char-count-over';
                charCountElement.style.color = '#ff4444';
            } else if (remaining < 50) {
                charCountElement.className = 'char-count char-count-warning';
                charCountElement.style.color = '#ff8800';
            } else {
                charCountElement.className = 'char-count char-count-normal';
                charCountElement.style.color = '#888';
            }
        }

        // Reset profile form to saved values
        async function resetProfileForm() {
            if (!currentUser) {
                return;
            }
            
            try {
                // Reload profile data from server
                await loadProfileData();
                showMessage('', 'info');
            } catch (error) {
                console.error('Error resetting profile form:', error);
                showMessage('', 'error');
            }
        }

        // Switch profile tabs
        function switchProfileTab(tabName) {
            // Hide all tab content
            const tabContents = document.querySelectorAll('.profile-tab-content');
            tabContents.forEach(content => content.classList.add('hidden'));
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.profile-tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));
            
            // Show selected tab content
            const selectedContent = document.getElementById(`${tabName}TabContent`);
            if (selectedContent) {
                selectedContent.classList.remove('hidden');
            }
            
            // Add active class to selected tab button
            const selectedButton = document.querySelector(`[data-tab="${tabName}"]`);
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
            
            // Load specific data based on tab
            if (tabName === 'profile') {
                loadProfileData();
            } else if (tabName === 'episodes') {
                loadUserEpisodes();
            } else if (tabName === 'stats') {
                loadUserProfileStats();
            }
            
            // console.log('Switched to profile tab:', tabName);
        }

        // Helper function to format dates
        function formatDate(dateString) {
            if (!dateString) return '';
            
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return '';
                
                const now = new Date();
                const diffTime = Math.abs(now - date);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays <= 1) {
                    return '';
                } else if (diffDays <= 7) {
                    return `${diffDays}`;
                } else if (diffDays <= 30) {
                    const weeks = Math.floor(diffDays / 7);
                    return `${weeks}`;
                } else {
                    return date.toLocaleDateString('ja-JP', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });
                }
            } catch (error) {
                // console.warn('Date formatting error:', error);
                return '';
            }
        }

        // Load user episodes for profile tab
        async function loadUserEpisodes() {
            if (!currentUser) {
                return;
            }

            try {
                const response = await apiClient.getTracks({ 
                    visibility: 'private',
                    limit: 50 // Show recent episodes
                });
                
                const episodes = response.episodes || [];
                const episodesList = document.getElementById('userEpisodesList');
                
                if (!episodesList) {
                    return;
                }
                
                if (episodes.length === 0) {
                    episodesList.innerHTML = '<div class="no-episodes"></div>';
                    return;
                }
                
                episodesList.innerHTML = episodes.map(episode => `
                    <div class="user-episode-item">
                        <div class="episode-info">
                            <h4>${episode.title || 'Untitled'}</h4>
                            <p class="episode-meta">${formatDate(episode.uploadedAt)} ‚Ä¢ ${episode.playCount || 0} </p>
                        </div>
                        <div class="episode-actions">
                            <button class="btn-secondary btn-small" onclick="editEpisode('${episode.id}')">Á∑®ÈõÜ</button>
                            <button class="btn-danger btn-small" onclick="deleteEpisode('${episode.id}')">ÂâäÈô§</button>
                        </div>
                    </div>
                `).join('');
                
                // console.log('User episodes loaded:', episodes.length);
            } catch (error) {
                console.error('Error loading user episodes:', error);
                const episodesList = document.getElementById('userEpisodesList');
                if (episodesList) {
                    episodesList.innerHTML = '<div class="error-message"></div>';
                }
            }
        }

        // Helper function to hide all sections
        function hideAllSections() {
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.add('hidden'));
        }

        // „É≠„Ç∞„Ç¢„Ç¶„ÉàÂ∞ÇÁî®: Áõ¥Êé•„É≠„Ç∞„Ç§„É≥ÁîªÈù¢„ÇíË°®Á§∫ÔºàupdateAuthUI„ÇíÂëº„Å∞„Å™„ÅÑÔºâ
        function showLoginScreenDirectly() {
            console.log('üîÑ showLoginScreenDirectly: Showing login screen without updateAuthUI');
            
            // Hide all sections first
            hideAllSections();
            
            // Show only login-related elements
            const authSection = document.getElementById('authSection');
            const loginForm = document.getElementById('loginForm');
            const userInfo = document.getElementById('userInfo');
            const uploadSection = document.getElementById('uploadSection');
            const sidebar = document.getElementById('sidebar');
            
            if (authSection) authSection.style.display = 'block';
            if (loginForm) loginForm.classList.remove('hidden');
            if (userInfo) userInfo.classList.add('hidden');
            if (uploadSection) uploadSection.classList.add('hidden');
            if (sidebar) sidebar.classList.add('hidden');
            
            // Remove logged-in class from body initially
            document.body.classList.remove('logged-in');
            
            // Hide all login-required elements
            document.querySelectorAll('.login-required').forEach(element => {
                element.classList.add('hidden');
            });
            
            // Hide mobile hamburger menu
            const mobileMenuToggle = document.getElementById('mobileMenuToggle');
            if (mobileMenuToggle) {
                mobileMenuToggle.style.setProperty('display', 'none', 'important');
            }
            
            // Clear header account display
            const headerAccount = document.getElementById('headerAccount');
            if (headerAccount) {
                headerAccount.innerHTML = '';
            }
            
            // Scroll to top of page
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
            
            console.log('‚úÖ showLoginScreenDirectly: Login screen displayed successfully');
        }

        // Header logout handler
        async function handleHeaderLogout(event) {
            if (event) {
                event.stopPropagation();
            }
            try {
                // ‚úÖ „Éò„ÉÉ„ÉÄ„Éº„É≠„Ç∞„Ç¢„Ç¶„ÉàÊôÇ„ÇÇ„É¶„Éº„Ç∂„Éº„Éá„Éº„Çø„ÇíÂÆåÂÖ®„ÇØ„É™„Ç¢
                console.log('üîÑ Starting header logout with data cleanup...');
                clearAllUserData();
                
                await firebaseAuth.signOut();
                showMessage('', 'success');
                
                console.log('‚úÖ Header logout completed');
                
                // üîÑ „Éö„Éº„Ç∏„É™„Éï„É¨„ÉÉ„Ç∑„É•„ÅßÁ¢∫ÂÆü„Å´ÂàùÊúüÁä∂ÊÖã„Å´Êàª„Çã
                setTimeout(() => {
                    location.reload();
                }, 500);
            } catch (error) {
                console.error('Logout error:', error);
                showMessage('', 'error');
                // „Ç®„É©„ÉºÊôÇ„ÇÇ„É™„Éï„É¨„ÉÉ„Ç∑„É•
                setTimeout(() => {
                    location.reload();
                }, 500);
            }
        }

        // Sidebar logout handler
        async function handleSidebarLogout(event) {
            if (event) {
                event.stopPropagation();
            }
            try {
                // ‚úÖ „Çµ„Ç§„Éâ„Éê„Éº„É≠„Ç∞„Ç¢„Ç¶„ÉàÊôÇ„ÇÇ„É¶„Éº„Ç∂„Éº„Éá„Éº„Çø„ÇíÂÆåÂÖ®„ÇØ„É™„Ç¢
                console.log('üîÑ Starting sidebar logout with data cleanup...');
                clearAllUserData();
                
                await firebaseAuth.signOut();
                showMessage('', 'success');
                
                console.log('‚úÖ Sidebar logout completed');
                
                // üîÑ „Éö„Éº„Ç∏„É™„Éï„É¨„ÉÉ„Ç∑„É•„ÅßÁ¢∫ÂÆü„Å´ÂàùÊúüÁä∂ÊÖã„Å´Êàª„Çã
                setTimeout(() => {
                    location.reload();
                }, 500);
            } catch (error) {
                console.error('Sidebar logout error:', error);
                showMessage('', 'error');
                // „Ç®„É©„ÉºÊôÇ„ÇÇ„É™„Éï„É¨„ÉÉ„Ç∑„É•
                setTimeout(() => {
                    location.reload();
                }, 500);
            }
        }

        // File Upload Functions
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                selectedFile = files[0]; // &
                // console.log('FILE File saved to selectedFile variable (drag):', selectedFile.name);
                processSelectedFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            // console.log('FILE handleFileSelect called');
            // console.log('FILE Event target:', e.target);
            // console.log('FILE Files property exists:', 'files' in e.target);
            // console.log('FILE Files array:', e.target.files);
            // console.log('FILE Files length:', e.target.files ? e.target.files.length : 'undefined');
            
            if (!e.target.files || e.target.files.length === 0) {
                // console.log('Warning: No files selected');
                selectedFile = null; // 
                return;
            }
            
            const file = e.target.files[0];
            // console.log('FILE Selected file:', file.name, file.size, file.type);
            
            if (file) {
                selectedFile = file; // 
                // console.log('FILE File saved to selectedFile variable:', selectedFile.name);
                processSelectedFile(file);
            }
        }

        function processSelectedFile(file) {
            // Validate file
            const isAudio = file.type.startsWith('audio/');
            const isVideo = file.type.startsWith('video/');
            
            if (!isAudio && !isVideo) {
                showMessage('', 'error', 'upload');
                return;
            }

            if (file.size > 500 * 1024 * 1024) { // 500MB
                showMessage('500MB', 'error', 'upload');
                return;
            }

            // Update UI
            document.getElementById('uploadBtn').disabled = false;
            
            const uploadZone = document.getElementById('uploadZone');
            uploadZone.innerHTML = `
                <div class="upload-icon">${isVideo ? 'VIDEO' : 'AUDIO'}</div>
                <h3>${file.name}</h3>
                <p style="opacity: 0.7; margin-top: 10px;">
                    : ${(file.size / 1024 / 1024).toFixed(2)} MB<br>
                    : ${file.type} ${isVideo ? '()' : '()'}
                </p>
            `;

            // Auto-fill title if empty
            const titleInput = document.getElementById('trackTitle');
            if (!titleInput.value.trim()) {
                const fileName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
                titleInput.value = fileName;
            }
        }

        async function handleUpload() {
            // console.log('UPLOAD: Upload button clicked');
            if (isUploading) {
                // console.log('Warning: Upload already in progress');
                return;
            }

            const fileInput = document.getElementById('fileInput');
            if (!fileInput) {
                console.error(' File input element not found');
                showMessage('', 'error', 'upload');
                return;
            }

            // console.log(' File input element found:', fileInput);
            // console.log(' Files property exists:', 'files' in fileInput);
            // console.log(' Files object:', fileInput.files);
            // console.log(' Global selectedFile:', selectedFile);

            const title = document.getElementById('trackTitle').value.trim();
            const artist = document.getElementById('trackArtist').value.trim();
            const description = document.getElementById('trackDescription').value.trim();
            const isPublic = true; // 
            
            // console.log('FILE Files in input:', fileInput.files ? fileInput.files.length : 'files property missing');
            // console.log('FILE Global selectedFile available:', !!selectedFile);
            // console.log(' Title:', title);
            
            // selectedFile
            let file = null;
            if (selectedFile) {
                file = selectedFile;
                // console.log(' Using global selectedFile:', file.name);
            } else if (fileInput.files && fileInput.files.length > 0) {
                file = fileInput.files[0];
                // console.log(' Using fileInput files:', file.name);
            }
            
            if (!file) {
                console.error(' No files selected');
                showMessage('', 'error', 'upload');
                return;
            }
            
            if (!title) {
                showMessage('', 'error', 'upload');
                return;
            }

            // console.log('FILE File to upload:', file.name, file.size, file.type);
            
            // 
            const fileIsVideo = file.type.startsWith('video/');
            
            isUploading = true;
            
            try {
                setLoadingState('upload', true);
                showProgress('...', 0);

                // Extract artwork for MP3 files
                let artwork = null;
                if (file.type.startsWith('audio/')) {
                    showProgress('...', 5);
                    try {
                        const artworkResult = await uploadHelper.extractArtwork(file);
                        // üîß Á¢∫ÂÆü„Å´base64„Éá„Éº„ÇøURI„Å®„Åó„Å¶Âá¶ÁêÜ
                        if (artworkResult && artworkResult.data && artworkResult.data.startsWith('data:image/')) {
                            artwork = artworkResult.data;
                            console.log('‚úÖ Artwork extracted as data URI:', artwork.substring(0, 50));
                        } else if (artworkResult && typeof artworkResult === 'string' && artworkResult.startsWith('data:image/')) {
                            artwork = artworkResult;
                            console.log('‚úÖ Artwork extracted as string data URI:', artwork.substring(0, 50));
                        } else {
                            console.log('‚ö†Ô∏è No valid artwork found or invalid format');
                            artwork = null;
                        }
                    } catch (error) {
                        console.error('‚ùå Artwork extraction failed:', error);
                        artwork = null;
                    }
                }

                // Get upload URL
                showProgress('URL...', 10);
                const uploadData = await apiClient.getUploadUrl(file.name, file.type, file.size);

                // Extract media metadata
                showProgress(`${fileIsVideo ? '' : ''}...`, 20);
                const metadata = await uploadHelper.extractMediaMetadata(file);

                // Upload file to GCS
                showProgress('...', 30);
                
                // Signed URL
                if (uploadData.directUpload) {
                    // console.log(' Using direct upload method');
                    await uploadHelper.uploadDirect(uploadData, file, (progress) => {
                        showProgress('...', 30 + (progress * 0.6));
                    });
                } else {
                    // console.log(' Using signed URL method');
                    await uploadHelper.uploadToGCS(uploadData.signedUrl, file, (progress) => {
                        showProgress('...', 30 + (progress * 0.6));
                    });
                }

                // Create track record
                showProgress('...', 95);
                await apiClient.createTrack({
                    title: title,
                    description: description,
                    gcsPath: uploadData.objectName,
                    originalFilename: file.name,
                    durationSec: Math.floor(metadata.duration || 0),
                    sizeBytes: file.size,
                    contentType: file.type,
                    visibility: isPublic ? 'public' : 'private',
                    tags: artist ? [artist] : [],
                    artwork: artwork
                });

                showProgress('', 100);
                showMessage('', 'success', 'upload');
                
                // console.log(' Upload completed, reloading episodes...');
                // console.log(' Current user at upload completion:', currentUser?.email);
                
                // Reset form and reload episodes
                resetUploadForm();
                
                // Force complete cache clear to ensure fresh reload
                forceClearEpisodesCache();
                
                // Wait a moment then reload with completely fresh data
                setTimeout(async () => {
                    // console.log(' Forcing completely fresh episode reload after upload...');
                    await loadEpisodes();
                    // console.log(' Episodes completely reloaded after upload');
                }, 1500);
                
                // Update user storage info
                if (currentUser) {
                    verifyAuthWithBackend();
                }

            } catch (error) {
                console.error('Upload error:', error);
                showMessage(': ' + error.message, 'error', 'upload');
            } finally {
                isUploading = false;
                setLoadingState('upload', false);
                hideProgress();
            }
        }

        function resetUploadForm() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.value = '';
            }
            document.getElementById('trackTitle').value = '';
            document.getElementById('trackArtist').value = '';
            document.getElementById('trackDescription').value = '';
            // true
            document.getElementById('uploadBtn').disabled = true;
            
            const uploadZone = document.getElementById('uploadZone');
            uploadZone.innerHTML = `
                <div class="upload-icon">AUDIO</div>
                <h3>Drag & Drop or Click to Upload Audio Files</h3>
                <p style="opacity: 0.7; margin-top: 10px;">Up to 50MB supported (MP3, WAV, M4A)</p>
            `;
        }

        // Force clear cache and reset episodes
        function forceClearEpisodesCache() {
            // console.log(' Forcing complete episodes cache clear...');
            
            // Clear global episodes array
            episodes = [];
            
            // Clear DOM
            const episodeGrid = document.getElementById('episodeGrid');
            if (episodeGrid) {
                episodeGrid.innerHTML = '';
            }
            
            // Clear any cached data in sessionStorage/localStorage that might contain episodes
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (key.includes('episode') || key.includes('track') || key.includes('sample') || key.includes('emergency'))) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => {
                try {
                    localStorage.removeItem(key);
                    // console.log(` Cleared localStorage key: ${key}`);
                } catch (error) {
                    // console.warn(`Failed to clear localStorage key ${key}:`, error);
                }
            });
            
            // Clear sessionStorage as well
            const sessionKeysToRemove = [];
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                if (key && (key.includes('episode') || key.includes('track') || key.includes('sample') || key.includes('emergency'))) {
                    sessionKeysToRemove.push(key);
                }
            }
            sessionKeysToRemove.forEach(key => {
                try {
                    sessionStorage.removeItem(key);
                    // console.log(` Cleared sessionStorage key: ${key}`);
                } catch (error) {
                    // console.warn(`Failed to clear sessionStorage key ${key}:`, error);
                }
            });
            
            // Add cache-busting timestamp for next API request
            window.lastApiCacheTime = Date.now();
            // console.log(' Cache-busting timestamp set:', window.lastApiCacheTime);
            
            // console.log(' Complete episodes cache clear finished');
        }

        // ‚úÖ Êñ∞Ë¶èË¶Å‰ª∂Ôºö„Åô„Åπ„Å¶„ÅÆ„É¶„Éº„Ç∂„Éº„Éá„Éº„Çø„ÇíÂÆåÂÖ®„ÇØ„É™„Ç¢Ôºà„Ç¢„Ç´„Ç¶„É≥„ÉàÂàá„ÇäÊõø„ÅàÊôÇÔºâ
        function clearAllUserData() {
            console.log('üßπ clearAllUserData: Starting comprehensive user data cleanup...');
            
            // 1. „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Çí„É™„Çª„ÉÉ„Éà
            episodes = [];
            selectedPlaylistId = 'all';
            window.currentUser = null;
            currentUser = null;
            
            // 2. DOMË¶ÅÁ¥†„Çí„ÇØ„É™„Ç¢
            const episodeGrid = document.getElementById('episodeGrid');
            if (episodeGrid) {
                episodeGrid.innerHTML = '';
            }
            
            // 3. localStorage „ÅÆÂÖ®„É¶„Éº„Ç∂„Éº„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢
            const localKeysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (
                    key.includes('episode') || 
                    key.includes('track') || 
                    key.includes('playlist') ||
                    key.includes('user') ||
                    key.includes('auth') ||
                    key.includes('sample') || 
                    key.includes('emergency') ||
                    key.includes('cache') ||
                    key.startsWith('ai-fm-') ||
                    key.includes('confirmation')
                )) {
                    localKeysToRemove.push(key);
                }
            }
            localKeysToRemove.forEach(key => {
                try {
                    localStorage.removeItem(key);
                    console.log(`üóëÔ∏è Removed localStorage key: ${key}`);
                } catch (error) {
                    console.warn(`‚ùå Failed to remove localStorage key ${key}:`, error);
                }
            });
            
            // 4. sessionStorage „ÅÆÂÖ®„É¶„Éº„Ç∂„Éº„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢
            const sessionKeysToRemove = [];
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                if (key && (
                    key.includes('episode') || 
                    key.includes('track') || 
                    key.includes('playlist') ||
                    key.includes('user') ||
                    key.includes('auth') ||
                    key.includes('sample') || 
                    key.includes('emergency') ||
                    key.includes('cache') ||
                    key.startsWith('ai-fm-')
                )) {
                    sessionKeysToRemove.push(key);
                }
            }
            sessionKeysToRemove.forEach(key => {
                try {
                    sessionStorage.removeItem(key);
                    console.log(`üóëÔ∏è Removed sessionStorage key: ${key}`);
                } catch (error) {
                    console.warn(`‚ùå Failed to remove sessionStorage key ${key}:`, error);
                }
            });
            
            // 5. „Éó„É¨„Ç§„É™„Çπ„ÉàÈÅ∏Êäû„Çí„É™„Çª„ÉÉ„Éà
            updatePlaylistSelector();
            
            // 6. „Ç≠„É£„ÉÉ„Ç∑„É•„Éê„Çπ„ÉÜ„Ç£„É≥„Ç∞„Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÇíÊõ¥Êñ∞
            window.lastApiCacheTime = Date.now();
            
            console.log('‚úÖ clearAllUserData: Complete user data cleanup finished');
        }

        // Episode Loading and Display
        async function loadEpisodes() {
            const loadingIndicator = document.getElementById('loadingEpisodes');
            const noEpisodes = document.getElementById('noEpisodes');
            
            // üî• DEBUG: „Éó„É¨„Ç§„É™„Çπ„ÉàÂàá„ÇäÊõø„Åà„Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞
            console.log('üß™ loadEpisodes called with:', {
                selectedPlaylistId: window.selectedPlaylistId,
                currentPlaylists: currentPlaylists,
                currentUser: currentUser?.email || 'not authenticated'
            });
            
            // üéôÔ∏è PODCAST PLAYLIST CHECK: Skip regular track loading for podcast playlists
            if (window.selectedPlaylistId && window.selectedPlaylistId.startsWith('podcast_')) {
                console.log('üéôÔ∏è Skipping loadEpisodes for podcast playlist, content should be loaded by loadPodcastPlaylistContent');
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                if (noEpisodes) noEpisodes.style.display = 'none';
                return;
            }
            
            // üö® Ë™çË®º„ÉÅ„Çß„ÉÉ„ÇØ: „É≠„Ç∞„Ç¢„Ç¶„ÉàÁä∂ÊÖã„Åß„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
            if (!currentUser) {
                console.log('üîê loadEpisodes: Skipping - user not authenticated');
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                if (noEpisodes) noEpisodes.style.display = 'none';
                return;
            }
            
            // Force clear any cached episode data to prevent emergency-1 from appearing
            forceClearEpisodesCache();
            
            try {
                loadingIndicator.style.display = 'block';
                
                let episodesToShow = [];
                
                if (window.selectedPlaylistId === 'all') {
                    // üö® EMERGENCY FIX: Always try to load tracks regardless of auth state
                    // console.log('üö® EMERGENCY: Loading all tracks regardless of auth state');
                    try {
                        // üî• TEMPORARY FIX: Remove visibility filter to show all tracks
                        // The issue might be that user authentication is not properly linked to tracks
                        const requestParams = { 
                            visibility: 'private',  // Fixed: Re-enabled for proper user data isolation
                            limit: 50,
                            _t: window.lastApiCacheTime || Date.now() // Cache buster
                        };
                        // console.log(' Loading episodes with params:', requestParams);
                        
                        // üî• MANUAL API CALL: apiClient is not available, use direct fetch with auth
                        let data = { tracks: [] }; // Initialize with empty tracks
                        try {
                            // Get authentication token
                            let token = null;
                            if (currentUser && currentUser.getIdToken) {
                                token = await currentUser.getIdToken();
                                // console.log(' Manual token obtained:', token ? 'Yes (' + token.substring(0, 20) + '...)' : 'No');
                            } else {
                                // console.warn(' No getIdToken method available on currentUser');
                            }
                            
                            // Use normal authenticated API call only
                            {
                                // console.log(' üîí SECURE: Using authenticated API call only');
                                // Build URL with parameters for normal API call
                            const searchParams = new URLSearchParams(requestParams);
                            const url = `/api/tracks?${searchParams}`;
                            // console.log(' Manual API URL:', url);
                            
                            // Make authenticated request
                            const headers = {
                                'Content-Type': 'application/json'
                            };
                            
                            if (token) {
                                headers['Authorization'] = `Bearer ${token}`;
                                // console.log(' Authorization header added');
                            } else {
                                console.warn(' üö® SECURITY: No token available - refusing unauthenticated request');
                                // Return empty data instead of making unauthenticated request
                                data = { tracks: [] };
                                throw new Error('Authentication required - no token available');
                            }
                            
                            const response = await fetch(url, {
                                method: 'GET',
                                headers: headers
                            });
                            
                            // console.log(' Manual API response status:', response.status, response.statusText);
                            
                            if (!response.ok) {
                                const errorText = await response.text();
                                console.error(' Manual API error:', errorText);
                                throw new Error(`HTTP ${response.status}: ${errorText}`);
                            }
                            
                                data = await response.json();
                                // console.log(' Manual API Response data:', data);
                            }
                            
                        } catch (apiError) {
                            console.error(' Manual API call failed:', apiError);
                            // Fallback to empty data
                            data = { tracks: [] };
                        }
                        
                        let rawTracks = data.tracks || [];
                        // console.log(' Raw episodes from API:', rawTracks.length, rawTracks);
                        // console.log(' Current user authentication state:', {
                        //     currentUser: currentUser,
                        //     currentUserUid: currentUser ? currentUser.uid : 'NO_UID',
                        //     currentUserEmail: currentUser ? currentUser.email : 'NO_EMAIL',
                        //     windowCurrentUser: window.currentUser,
                        //     authState: typeof firebaseAuth !== 'undefined' ? 'available' : 'not available'
                        // });
                            
                        // TRIPLE SAFETY: Always filter out emergency/sample episodes regardless of user state
                        // This prevents any emergency-1 or sample episodes from appearing
                        episodesToShow = rawTracks.filter(ep => {
                            // Â§ßÂπÖ„Å´„Éï„Ç£„É´„Çø„É™„É≥„Ç∞Êù°‰ª∂„ÇíÁ∑©Âíå - ÂÆüÈöõ„ÅÆ„É¶„Éº„Ç∂„Éº„Éá„Éº„Çø„ÇíË°®Á§∫
                            const shouldExclude = (
                                // Âü∫Êú¨ÁöÑ„Å™Èô§Â§ñÊù°‰ª∂„ÅÆ„Åø
                                (ep.trackId && ep.trackId.startsWith('sample-')) || // Sample episodes
                                (ep.trackId && ep.trackId.startsWith('emergency-')) || // Emergency prefix
                                ep.trackId === 'emergency-1' || // Specific emergency-1
                                ep.title?.includes('emergency') // English emergency in title (Japanese emergency check removed)
                            );
                            
                            if (shouldExclude) {
                                // console.log(' FILTERED OUT:', {
                                //     trackId: ep.trackId,
                                //     title: ep.title,
                                //     uploaderUid: ep.uploaderUid,
                                //     status: ep.status,
                                //     reason: 'emergency/sample episode detected',
                                //     checks: {
                                //         startsWithSample: ep.trackId && ep.trackId.startsWith('sample-'),
                                //         startsWithEmergency: ep.trackId && ep.trackId.startsWith('emergency-'),
                                //         isEmergency1: ep.trackId === 'emergency-1',
                                //         titleIncludesEmergency: ep.title?.includes('emergency')
                                //     }
                                // });
                            } else {
                                // console.log(' KEEPING episode:', {
                                //     trackId: ep.trackId,
                                //     title: ep.title,
                                //     uploaderUid: ep.uploaderUid,
                                //     status: ep.status,
                                //     fileSize: ep.fileSize,
                                //     isNewUpload: !ep.trackId // Flag for debugging new uploads
                                // });
                            }
                            
                            return !shouldExclude;
                        });
                        
                        // console.log(` TRIPLE FILTERED episodes: ${rawTracks.length} -> ${episodesToShow.length}`);
                        
                    } catch (outerError) {
                        console.error('üö® EMERGENCY: Outer API call failed:', outerError);
                        // Ultimate fallback - use sample data
                        episodesToShow = createSampleEpisodes();
                    }
                    
                    // üî• EMERGENCY FIX: Remove additional filtering that was excluding user uploads
                    // The issue was that uploaded content without trackId was being filtered out
                    // console.log(' Additional filtering DISABLED to show user uploads');
                    
                    // console.log(' Final episodes to show:', episodesToShow.length, episodesToShow);
                    
                    // Only add sample episodes if user is not authenticated AND no tracks exist
                    if (episodesToShow.length === 0 && !currentUser) {
                        // console.log(' Adding sample episodes for non-authenticated user');
                        episodesToShow = createSampleEpisodes();
                    }
                } else {
                    // Load specific playlist tracks
                    console.log('üéµ Loading specific playlist:', window.selectedPlaylistId);
                    console.log('üéµ Available playlists:', currentPlaylists);
                    
                    const playlist = currentPlaylists.find(p => p.playlistId === window.selectedPlaylistId);
                    console.log('üéµ Found playlist:', playlist);
                    
                    // Check if playlist has tracks OR podcast episodes
                    const hasRegularTracks = playlist && playlist.tracks && playlist.tracks.length > 0;
                    const hasPodcastEpisodes = playlist && playlist.podcastEpisodes && playlist.podcastEpisodes.length > 0;
                    
                    if (hasRegularTracks || hasPodcastEpisodes) {
                        console.log('üéµ Playlist has content:', { 
                            tracks: hasRegularTracks ? playlist.tracks.length : 0,
                            podcastEpisodes: hasPodcastEpisodes ? playlist.podcastEpisodes.length : 0
                        });
                        // Use the same authenticated approach as 'all' case
                        try {
                            // Get authentication token
                            let token = null;
                            if (currentUser && currentUser.getIdToken) {
                                token = await currentUser.getIdToken();
                            } else {
                                console.warn('No getIdToken method available for playlist loading');
                            }
                            
                            if (!token) {
                                console.warn('üö® SECURITY: No token available for playlist - refusing unauthenticated request');
                                episodesToShow = [];
                            } else {
                                // üîß NEW APPROACH: Use tracks/by-ids API for playlist tracks
                                if (hasRegularTracks) {
                                    console.log('üéµ Fetching tracks by IDs for playlist:', playlist.tracks);
                                    
                                    const response = await fetch('/api/tracks/by-ids', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'Authorization': `Bearer ${token}`
                                        },
                                        body: JSON.stringify({
                                            trackIds: playlist.tracks
                                        })
                                    });
                                    
                                    if (!response.ok) {
                                        const errorText = await response.text();
                                        console.error('Playlist tracks API error:', errorText);
                                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                                    }
                                    
                                    const data = await response.json();
                                    episodesToShow = data.tracks || [];
                                    console.log(`üéµ Found ${episodesToShow.length} tracks for playlist from ${playlist.tracks.length} track IDs`);
                                } else {
                                    episodesToShow = [];
                                }
                                
                                // Add podcast episodes to the display
                                if (hasPodcastEpisodes) {
                                    console.log('üéôÔ∏è Adding podcast episodes to playlist display:', playlist.podcastEpisodes.length);
                                    playlist.podcastEpisodes.forEach(podcastEpisode => {
                                        // Convert podcast episode to episode format for display
                                        const episodeForDisplay = {
                                            trackId: podcastEpisode.episodeId,
                                            title: podcastEpisode.title,
                                            description: podcastEpisode.description,
                                            type: 'podcast',
                                            addedAt: podcastEpisode.addedAt,
                                            isPodcast: true, // Flag to identify podcast episodes
                                            audioUrl: podcastEpisode.audioUrl, // Add audio URL for playback
                                            audio_url: podcastEpisode.audioUrl, // Fallback field name
                                            uploaderName: podcastEpisode.uploaderName || 'Podcast',
                                            duration: podcastEpisode.duration || 'Unknown'
                                        };
                                        episodesToShow.push(episodeForDisplay);
                                        
                                        // CRITICAL FIX: Add podcast episode to global episodes array for playback
                                        const existingEpisodeIndex = episodes.findIndex(ep => ep.trackId === podcastEpisode.episodeId);
                                        if (existingEpisodeIndex >= 0) {
                                            // Update existing episode with podcast data
                                            episodes[existingEpisodeIndex] = { ...episodes[existingEpisodeIndex], ...episodeForDisplay };
                                            console.log('üéôÔ∏è Updated existing episode in global array:', podcastEpisode.title);
                                        } else {
                                            // Add new episode to global array
                                            episodes.push(episodeForDisplay);
                                            console.log('üéôÔ∏è Added new podcast episode to global array:', podcastEpisode.title);
                                        }
                                    });
                                }
                                
                                // Add found tracks to global episodes array for playback
                                episodesToShow.forEach(track => {
                                    const existingEpisodeIndex = episodes.findIndex(ep => ep.trackId === track.trackId);
                                    if (existingEpisodeIndex >= 0) {
                                        // Update existing episode with track data
                                        episodes[existingEpisodeIndex] = { ...episodes[existingEpisodeIndex], ...track };
                                        console.log('üéµ Updated existing track in global array:', track.title);
                                    } else {
                                        // Add new track to global array
                                        episodes.push(track);
                                        console.log('üéµ Added new track to global array:', track.title);
                                    }
                                });
                                
                                console.log('üéµ Total content for playlist (tracks + podcasts):', episodesToShow.length);
                                console.log('üéµ Content IDs:', episodesToShow.map(t => t.trackId));
                                
                                // Sort by playlist order (tracks first, then podcasts)
                                episodesToShow.sort((a, b) => {
                                    const aTrackIndex = playlist.tracks.indexOf(a.trackId);
                                    const bTrackIndex = playlist.tracks.indexOf(b.trackId);
                                    
                                    // If both are in tracks array, sort by track order
                                    if (aTrackIndex >= 0 && bTrackIndex >= 0) {
                                        return aTrackIndex - bTrackIndex;
                                    }
                                    // If only a is in tracks, a comes first
                                    if (aTrackIndex >= 0) return -1;
                                    // If only b is in tracks, b comes first  
                                    if (bTrackIndex >= 0) return 1;
                                    // If neither is in tracks (both are podcasts), maintain original order
                                    return 0;
                                });
                                
                                console.log(`üìã Playlist "${playlist.name}" loaded: ${episodesToShow.length} tracks`);
                            }
                        } catch (error) {
                            console.error('Error loading playlist tracks:', error);
                            episodesToShow = [];
                        }
                    } else {
                        // No playlist found or no tracks in playlist
                        episodesToShow = [];
                        console.log(`üìã Playlist not found or empty: ${window.selectedPlaylistId}`);
                    }
                }
                
                episodes = episodesToShow;
                renderEpisodes(episodes);
                
                if (episodes.length === 0) {
                    noEpisodes.classList.remove('hidden');
                } else {
                    noEpisodes.classList.add('hidden');
                }
                
            } catch (error) {
                console.error('Error loading episodes:', error);
                
                // FIX: ÈùûË™çË®º„É¶„Éº„Ç∂„Éº„ÅÆÂ†¥Âêà„ÄÅ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫„Åõ„Åö„Çµ„É≥„Éó„É´„Ç®„Éî„ÇΩ„Éº„Éâ„ÇíÁõ¥Êé•Ë°®Á§∫
                if (!currentUser) {
                    // console.log('Non-authenticated user detected - loading sample episodes without API');
                    episodes = createSampleEpisodes();
                    renderEpisodes(episodes);
                } else {
                    // Ë™çË®º„É¶„Éº„Ç∂„Éº„ÅÆÂ†¥Âêà„ÅÆ„Åø„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫
                    showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„ÅÆË™≠„ÅøËæº„Åø‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', 'error');
                    episodes = [];
                    renderEpisodes(episodes);
                }
                
            } finally {
                loadingIndicator.style.display = 'none';
                
                // Ensure episode grid is visible for authenticated users
                if (currentUser && episodeGrid.classList.contains('hidden')) {
                    // console.log(' Finally block: Making episodeGrid visible');
                    episodeGrid.classList.remove('hidden');
                }
            }
        }

        // üî• PLAYLIST FIX: Make loadEpisodes globally accessible for playlist switching
        window.loadEpisodes = loadEpisodes;

        function createSampleEpisodes() {
            // Never show sample episodes for authenticated users
            if (currentUser) {
                // console.log(' Authenticated user detected, returning empty episodes array');
                return [];
            }
            
            // console.log(' Non-authenticated user, showing sample episodes');
            return [
                {
                    trackId: 'sample-1',
                    title: 'AI 2024',
                    uploaderName: 'Tech Talk Japan',
                    description: '',
                    durationSec: 930, // 15:30
                    playCount: 1250,
                    createdAt: new Date(Date.now() - 86400000).toISOString(),
                    audioUrl: generateToneAudio(440, 15.5)
                },
                {
                    trackId: 'sample-2',
                    title: '',
                    uploaderName: 'Cloud Expert',
                    description: 'AWSGCPAzure',
                    durationSec: 1335, // 22:15
                    playCount: 890,
                    createdAt: new Date(Date.now() - 172800000).toISOString(),
                    audioUrl: generateToneAudio(330, 22.25)
                },
                {
                    trackId: 'sample-3',
                    title: 'Web',
                    uploaderName: 'DevTips',
                    description: 'WebReactVue.jsNext.js',
                    durationSec: 1125, // 18:45
                    playCount: 672,
                    createdAt: new Date(Date.now() - 259200000).toISOString(),
                    audioUrl: generateToneAudio(523, 18.75)
                }
            ];
        }

        function renderEpisodes(episodesToRender) {
            // TRIPLE SAFETY at render level - Always filter out emergency/sample episodes
            // console.log(' renderEpisodes - currentUser check:', {
            //     currentUser: !!currentUser,
            //     currentUserEmail: currentUser?.email,
            //     currentUserUid: currentUser?.uid
            // });
            
            // Apply the same TRIPLE SAFETY filter at render level
            const originalCount = episodesToRender.length;
            const beforeFilter = episodesToRender.map(ep => ({ trackId: ep.trackId, title: ep.title }));
            
            // üö® EMERGENCY FIX: Disable render-level filtering that was removing ALL episodes
            // The issue: !ep.trackId was excluding valid tracks
            // The issue: ep.title?.includes('') matches EVERY title (empty string)
            // console.log(' üö® EMERGENCY: Render filtering DISABLED to show all episodes');
            
            /* DISABLED - this was filtering out everything:
            episodesToRender = episodesToRender.filter(ep => {
                const shouldExclude = (
                    !ep.trackId || 
                    ep.trackId.startsWith('sample-') || 
                    ep.trackId.startsWith('emergency-') || 
                    ep.trackId === 'emergency-1' || 
                    ep.title?.includes('') || // BUG: This matches ALL titles!
                    ep.title?.includes('emergency')
                );
                
                if (shouldExclude) {
                    // console.log(' RENDER FILTERED OUT:', {
                    //     trackId: ep.trackId,
                    //     title: ep.title,
                    //     reason: 'emergency/sample episode at render'
                    // });
                }
                
                return !shouldExclude;
            });
            */
            
            const afterFilter = episodesToRender.map(ep => ({ trackId: ep.trackId, title: ep.title }));
            // console.log(` RENDER LEVEL FILTER: ${originalCount} -> ${episodesToRender.length}`);
            // console.log(' Before render filter:', beforeFilter);
            // console.log(' After render filter:', afterFilter);
            
            // console.log(' renderEpisodes called:', {
            //     episodesToRender: episodesToRender.length,
            //     currentUser: !!currentUser,
            //     userEmail: currentUser?.email,
            //     sampleEpisodes: episodesToRender.some(ep => ep.trackId?.startsWith('sample-'))
            // });
            
            // Ensure episode grid is visible for logged-in users
            if (currentUser && episodeGrid.classList.contains('hidden')) {
                // console.log(' Making episodeGrid visible after render');
                episodeGrid.classList.remove('hidden');
            }
            
            episodeGrid.innerHTML = episodesToRender.map(episode => {
                const duration = formatDuration(episode.durationSec || 0);
                const uploadDate = new Date(episode.createdAt).toLocaleDateString('ja-JP');
                const playCount = episode.playCount || 0;
                const escapedTitle = escapeHtml(episode.title).replace(/'/g, "\\'");
                const escapedDescription = escapeHtml(episode.description || '').replace(/'/g, "\\'");
                
                // Debug logging for menu button logic
                // console.log('Episode menu debug:', {
                //     trackId: episode.trackId,
                //     title: episode.title,
                //     uploaderUid: episode.uploaderUid,
                //     currentUserUid: currentUser?.uid,
                //     isOwner: episode.uploaderUid && episode.uploaderUid === currentUser?.uid,
                //     hasCurrentUser: !!currentUser,
                //     uploaderUidType: typeof episode.uploaderUid,
                //     currentUserUidType: typeof currentUser?.uid,
                //     strictEquality: episode.uploaderUid === currentUser?.uid
                // });
                
                // Don't show menu for sample episodes
                const isSampleEpisode = episode.trackId?.startsWith('sample-') || episode.trackId?.startsWith('emergency-');
                const menuButton = (currentUser && !isSampleEpisode) ? 
                    `<div class="episode-menu">
                        <button class="menu-button" onclick="event.stopPropagation(); toggleEpisodeMenu('${episode.trackId}')" title="„É°„Éã„É•„Éº">
                            ‚ãØ
                        </button>
                        <div class="menu-dropdown" id="menu-${episode.trackId}">
                            <button class="menu-item playlist-add-item" onclick="event.stopPropagation(); addToPlaylist('${episode.trackId}')">
                                <span class="menu-text">„Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†</span>
                            </button>
                            <button class="menu-item download-add-item" data-episode-id="${episode.trackId}" onclick="event.stopPropagation(); downloadEpisodeClean('${episode.trackId}', this)" title="„Ç®„Éî„ÇΩ„Éº„Éâ„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ">
                                <span class="menu-text">„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</span>
                            </button>
                            ${(episode.uploaderUid && episode.uploaderUid === currentUser.uid) ? `
                            <button class="menu-item edit-item" onclick="event.stopPropagation(); openTrackEditor('${episode.trackId}', '${escapedTitle}', '${escapedDescription}')">
                                <span class="menu-text">„Éà„É©„ÉÉ„ÇØÊÉÖÂ†±Á∑®ÈõÜ</span>
                            </button>
                            ` : ''}
                            <button class="menu-item delete-item" onclick="event.stopPropagation(); ${(episode.uploaderUid && episode.uploaderUid === currentUser.uid) ? `confirmDeleteTrack('${episode.trackId}', '${escapedTitle}')` : (() => {
                                // Check if this is a podcast episode
                                const isPodcastEpisode = episode.isPodcast || episode.type === 'podcast';
                                // For podcast episodes, check if they have audio_url or audioUrl
                                const hasAudioUrl = episode.audioUrl || episode.audio_url;
                                // For music tracks, check if they have both uploaderUid and audioUrl
                                const isBrokenTrack = isPodcastEpisode ? !hasAudioUrl : (!episode.uploaderUid || !episode.audioUrl);
                                return isBrokenTrack ? `confirmDeleteOrphanedTrack('${episode.trackId}', '${escapedTitle}')` : `removeFromLibrary('${episode.trackId}', '${escapedTitle}', ${isPodcastEpisode})`;
                            })()}">
                                <span class="menu-text">${(episode.uploaderUid && episode.uploaderUid === currentUser.uid) ? '„Éà„É©„ÉÉ„ÇØ„ÇíÂâäÈô§' : (() => {
                                    // Check if this is a podcast episode
                                    const isPodcastEpisode = episode.isPodcast || episode.type === 'podcast';
                                    // For podcast episodes, check if they have audio_url or audioUrl
                                    const hasAudioUrl = episode.audioUrl || episode.audio_url;
                                    // For music tracks, check if they have both uploaderUid and audioUrl
                                    const isBrokenTrack = isPodcastEpisode ? !hasAudioUrl : (!episode.uploaderUid || !episode.audioUrl);
                                    return isBrokenTrack ? 'Á†¥Êêç„Éà„É©„ÉÉ„ÇØ„ÇíÂâäÈô§' : '„É©„Ç§„Éñ„É©„É™„Åã„ÇâÂâäÈô§';
                                })()}</span>
                            </button>
                        </div>
                    </div>` : '';
                
                const hasArtwork = episode.artwork && typeof episode.artwork === 'string' && episode.artwork.trim();
                
                // üîß blobURLÂïèÈ°å‰øÆÊ≠£: Á¢∫ÂÆü„Å´base64„Éá„Éº„ÇøURI„Å®„Åó„Å¶Âá¶ÁêÜ
                let artworkElement = '';
                if (hasArtwork) {
                    let artworkUrl = episode.artwork;
                    
                    // „Ç¢„Éº„Éà„ÉØ„Éº„ÇØ„Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞
                    console.log(`Episode ${episode.trackId} artwork type:`, typeof episode.artwork);
                    console.log(`Episode ${episode.trackId} artwork prefix:`, episode.artwork.substring(0, 50));
                    
                    // blobURL„ÅÆÂ†¥Âêà„ÅØnull„Å´„Åó„Å¶ÁÑ°Ë¶ñ
                    if (artworkUrl.startsWith('blob:')) {
                        console.warn(`‚ö†Ô∏è Episode ${episode.trackId}: Ignoring blob URL - ${artworkUrl.substring(0, 60)}`);
                        artworkUrl = null;
                    }
                    // Ê≠£„Åó„ÅÑdata URI„ÅÆÂ†¥Âêà„ÅÆ„Åø‰ΩøÁî®
                    else if (artworkUrl.startsWith('data:image/')) {
                        console.log(`‚úÖ Episode ${episode.trackId}: Using valid data URI`);
                    }
                    // „Åù„ÅÆ‰ªñ„ÅÆÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
                    else {
                        console.warn(`‚ö†Ô∏è Episode ${episode.trackId}: Invalid artwork URL format - ${artworkUrl.substring(0, 60)}`);
                        artworkUrl = null;
                    }
                    
                    if (artworkUrl) {
                        artworkElement = `<div class="episode-artwork" style="background-image: url('${artworkUrl.replace(/'/g, "\\'")}')" title="Album Artwork"></div>`;
                    }
                }
                
                return `
                    <div class="episode-card" onclick="playEpisode('${episode.trackId}')">
                        ${menuButton}
                        <div class="episode-title">${escapeHtml(episode.title)}</div>
                        <div class="episode-description">${episode.description ? escapeHtml(episode.description).replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, '').substring(0, 100) + (episode.description.length > 100 ? '...' : '') : ''}</div>
                        <div class="episode-meta">
                            <span>BY ${escapeHtml(episode.uploaderName || 'Unknown')}</span>
                            <span>DATE ${uploadDate}</span>
                        </div>
                        <div class="episode-meta">
                            <span>TIME ${duration}</span>
                            <span>PLAYS ${playCount}</span>
                        </div>
                        <div class="episode-actions">
                            <button class="play-button" onclick="event.stopPropagation(); playEpisode('${episode.trackId}')" title="ÂÜçÁîü">
                                ÂÜçÁîü
                            </button>
                        </div>
                        ${artworkElement}
                    </div>
                `;
            }).join('');
        }

        // Search functionality
        function handleSearch() {
            const query = searchBar.value.toLowerCase().trim();
            
            if (!query) {
                renderEpisodes(episodes);
                return;
            }
            
            const filteredEpisodes = episodes.filter(episode => 
                episode.title?.toLowerCase().includes(query) ||
                episode.description?.toLowerCase().includes(query) ||
                episode.uploaderName?.toLowerCase().includes(query)
            );
            
            renderEpisodes(filteredEpisodes);
        }

        // Audio Player Functions
        async function playEpisode(episodeId, titleOrEpisode = null, podcastName = null) {
            // Check if this track is currently playing - implement toggle functionality
            if (currentlyPlayingId === episodeId && currentMedia && !currentMedia.paused) {
                // Stop playback and reset button
                currentMedia.pause();
                currentMedia.currentTime = 0;
                currentlyPlayingId = null;
                window.currentlyPlayingId = null; // üî• FIX: Update global reference
                
                // Reset button text to "ÂÜçÁîü"
                const playButtons = document.querySelectorAll(`[onclick*="${episodeId}"]`);
                playButtons.forEach(btn => {
                    if (btn.classList.contains('play-button')) {
                        btn.textContent = 'ÂÜçÁîü';
                        btn.style.opacity = '1';
                        btn.style.background = '';
                    }
                });
                
                // Hide media player
                mediaPlayer.style.display = 'none';
                
                // Update play/pause button
                document.getElementById('playPauseBtn').textContent = 'PLAY';
                
                showMessage('ÂÜçÁîü„ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü', 'info');
                return;
            }
            
            // console.log(' Starting immediate playback for:', episodeId);
            
            // Handle different parameter formats
            let episode;
            
            // If titleOrEpisode is a string (title), create a podcast episode object
            if (typeof titleOrEpisode === 'string' && podcastName) {
                episode = {
                    trackId: episodeId,
                    title: titleOrEpisode,
                    artist: podcastName,
                    uploaderName: podcastName,
                    isPodcast: true,  // Mark as podcast episode
                    type: 'podcast'
                };
            }
            // If titleOrEpisode is an object, use it as the episode
            else if (typeof titleOrEpisode === 'object' && titleOrEpisode !== null) {
                episode = titleOrEpisode;
            }
            // Otherwise, try to find in episodes array
            else {
                episode = episodes.find(ep => ep.trackId === episodeId);
            }
            
            if (!episode) {
                showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                return;
            }

            try {
                // Show immediate feedback
                showMessage(' ...', 'info');
                
                // Update play button for visual feedback
                const playButtons = document.querySelectorAll(`[onclick*="${episodeId}"]`);
                playButtons.forEach(btn => {
                    if (btn.classList.contains('play-button')) {
                        btn.textContent = '‚è≥';
                        btn.style.opacity = '0.7';
                    }
                });

                // Stop current media safely
                if (currentMedia) {
                    try {
                        // Remove event listeners first
                        currentMedia.removeEventListener('timeupdate', updateProgress);
                        currentMedia.removeEventListener('ended', handleMediaEnded);
                        currentMedia.removeEventListener('error', handleMediaError);
                        currentMedia.removeEventListener('volumechange', updateVolumeDisplay);
                        
                        // Pause and reset
                        currentMedia.pause();
                        currentMedia.currentTime = 0;
                        currentMedia.src = '';
                        
                        // Wait for cleanup to complete
                        await new Promise(resolve => setTimeout(resolve, 150));
                        currentMedia = null;
                        window.currentMedia = null; // üî• FIX: Update global reference
                    } catch (stopError) {
                        console.warn('Error stopping previous media:', stopError);
                        currentMedia = null;
                        window.currentMedia = null; // üî• FIX: Update global reference
                    }
                }

                let audioUrl = episode.audioUrl;
                
                // Check if this is a podcast episode (has isPodcast flag or type === 'podcast')
                const isPodcastEpisode = episode.isPodcast || episode.type === 'podcast';
                
                if (isPodcastEpisode) {
                    // For podcast episodes, use audio_url directly or try to get from server
                    audioUrl = episode.audio_url || episode.audioUrl;
                    console.log('üéôÔ∏è Processing podcast episode:', { episodeId, audioUrl, hasAudioUrl: !!audioUrl });
                    
                    // If no direct audioUrl, try to get it from podcast-specific API
                    if (!audioUrl) {
                        console.log('üéôÔ∏è No direct audioUrl found, searching for episode details...');
                        try {
                            // Use podcast search API to get episode details
                            const searchResponse = await fetch(`/api/podcasts/search?episode_id=${episodeId}`, {
                                headers: {
                                    'Content-Type': 'application/json'
                                }
                            });
                            
                            if (searchResponse.ok) {
                                const searchData = await searchResponse.json();
                                if (searchData.episodes && searchData.episodes.length > 0) {
                                    const foundEpisode = searchData.episodes.find(ep => ep.id === episodeId) || searchData.episodes[0];
                                    audioUrl = foundEpisode.audio_url;
                                    console.log('üéôÔ∏è Got audioUrl from podcast search:', audioUrl);
                                }
                            }
                            
                            if (!audioUrl) {
                                throw new Error('Audio URL not found in search results');
                            }
                        } catch (error) {
                            console.error('üéôÔ∏è Failed to get audioUrl from podcast search:', error);
                            throw new Error('„Åì„ÅÆ„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„Ç®„Éî„ÇΩ„Éº„Éâ„ÅÆÈü≥Â£∞„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                        }
                    }
                } else if (!episode.audioUrl && !episodeId.startsWith('sample-')) {
                    // For library tracks, get play URL from server
                    // console.log(' Fetching play URL...');
                    const playData = await apiClient.getPlayUrl(episodeId);
                    audioUrl = playData.playUrl;
                }

                if (!audioUrl) {
                    throw new Error('URL');
                }

                // console.log(' Creating media element with URL:', audioUrl.substring(0, 50) + '...');
                
                // Determine media type and create appropriate element
                const isVideo = episode.contentType && episode.contentType.startsWith('video/');
                currentMediaType = isVideo ? 'video' : 'audio';
                
                const videoContainer = document.getElementById('videoContainer');
                const videoElement = document.getElementById('videoElement');
                const audioElement = document.getElementById('audioElement');
                
                if (isVideo) {
                    currentMedia = videoElement;
                    window.currentMedia = currentMedia; // üî• FIX: Update global reference
                    videoContainer.style.display = 'block';
                    audioElement.style.display = 'none';
                } else {
                    currentMedia = audioElement;
                    window.currentMedia = currentMedia; // üî• FIX: Update global reference
                    videoContainer.style.display = 'none';
                    audioElement.style.display = 'none';
                }
                
                currentMedia.preload = 'auto';
                currentMedia.volume = 0.8;
                
                // Update player UI immediately
                document.getElementById('playerTitle').textContent = episode.title;
                document.getElementById('playerArtist').textContent = episode.artist || episode.uploaderName || 'Unknown Artist';
                document.getElementById('mediaTypeIndicator').textContent = isVideo ? ' ' : ' ';
                
                // Show/hide fullscreen button for videos
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                if (isVideo) {
                    fullscreenBtn.style.display = 'inline-block';
                } else {
                    fullscreenBtn.style.display = 'none';
                }
                
                mediaPlayer.style.display = 'flex';
                
                // Set up event listeners for better user feedback
                currentMedia.addEventListener('loadstart', () => {
                    // console.log(` ${currentMediaType} loading started`);
                });
                
                currentMedia.addEventListener('loadedmetadata', () => {
                    // console.log(` ${currentMediaType} metadata loaded`);
                    updateTimeDisplay();
                    updateVolumeDisplay();
                });
                
                currentMedia.addEventListener('canplay', () => {
                    // console.log(` ${currentMediaType} ready to play`);
                });

                currentMedia.addEventListener('timeupdate', updateProgress);
                currentMedia.addEventListener('ended', handleMediaEnded);
                currentMedia.addEventListener('error', handleMediaError);
                currentMedia.addEventListener('volumechange', updateVolumeDisplay);

                // Set source and wait for readiness
                currentMedia.src = audioUrl;
                
                // Wait for media element to load
                const mediaReady = new Promise((resolve) => {
                    const onCanPlay = () => {
                        currentMedia.removeEventListener('canplay', onCanPlay);
                        resolve();
                    };
                    currentMedia.addEventListener('canplay', onCanPlay);
                    
                    // Fallback timeout
                    setTimeout(resolve, 3000);
                });
                
                await mediaReady;
                
                // Additional safety wait
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Start playback with error handling
                try {
                    const playPromise = currentMedia.play();
                    if (playPromise !== undefined) {
                        await playPromise;
                    }
                    // console.log(' Playback started successfully!');
                    
                    // Set currently playing ID
                    currentlyPlayingId = episodeId;
                    window.currentlyPlayingId = currentlyPlayingId; // üî• FIX: Update global reference
                    
                    document.getElementById('playPauseBtn').textContent = 'PAUSE';
                    showMessage(` "${episode.title}" `, 'success');
                    
                    // Reset button appearance
                    playButtons.forEach(btn => {
                        if (btn.classList.contains('play-button')) {
                            btn.textContent = 'PLAYING';
                            btn.style.opacity = '1';
                            btn.style.background = 'linear-gradient(45deg, #47d18c, #4ecdc4)';
                        }
                    });
                    
                } catch (playError) {
                    // console.warn(' Autoplay blocked:', playError);
                    
                    if (playError.name === 'NotAllowedError') {
                        // Show friendly autoplay blocked message
                        showMessage(' ', 'warning');
                        document.getElementById('playPauseBtn').textContent = 'PLAY';
                        
                        // Reset button state
                        playButtons.forEach(btn => {
                            if (btn.classList.contains('play-button')) {
                                btn.textContent = 'PLAY';
                                btn.style.opacity = '1';
                                btn.style.background = '';
                            }
                        });
                    } else {
                        throw playError;
                    }
                }
                
            } catch (error) {
                console.error(' Play error:', error);
                
                // Reset button state on error
                const playButtons = document.querySelectorAll(`[onclick*="${episodeId}"]`);
                playButtons.forEach(btn => {
                    if (btn.classList.contains('play-button')) {
                        btn.textContent = 'PLAY';
                        btn.style.opacity = '1';
                        btn.style.background = '';
                    }
                });
                
                // Enhanced error messages for better UX
                let errorMessage = '';
                if (error.name === 'NotAllowedError') {
                    errorMessage = ' ';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage = ' ';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage = ' ';
                } else if (error.message.includes('decode')) {
                    errorMessage = ' ';
                }
                
                showMessage(errorMessage, 'error');
                
                // Clean up on error
                currentlyPlayingId = null;
                if (currentMedia) {
                    currentMedia.src = '';
                    currentMedia = null;
                }
                mediaPlayer.style.display = 'none';
            }
        }

        // Media Event Handlers
        function handleMediaEnded() {
            // console.log(' Media playback ended');
            
            // Clear currently playing ID and reset all play buttons
            const currentId = currentlyPlayingId;
            currentlyPlayingId = null;
            
            // Reset all play buttons to "ÂÜçÁîü"
            if (currentId) {
                const playButtons = document.querySelectorAll(`[onclick*="${currentId}"]`);
                playButtons.forEach(btn => {
                    if (btn.classList.contains('play-button')) {
                        btn.textContent = 'ÂÜçÁîü';
                        btn.style.opacity = '1';
                        btn.style.background = '';
                    }
                });
            }
            
            // Reset player UI
            document.getElementById('playPauseBtn').textContent = 'PLAY';
            
            // Reset progress bar
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.value = 0;
            }
            
            // Show completion message
            showMessage('', 'success');
            
            // Auto-hide player after completion (optional)
            // setTimeout(() => closePlayer(), 3000);
        }

        function handleMediaError(event) {
            console.error(' Media error:', event);
            
            const error = event.target.error;
            let errorMessage = '';
            
            if (error) {
                switch (error.code) {
                    case MediaError.MEDIA_ERR_ABORTED:
                        errorMessage = '';
                        break;
                    case MediaError.MEDIA_ERR_NETWORK:
                        errorMessage = '';
                        break;
                    case MediaError.MEDIA_ERR_DECODE:
                        errorMessage = '';
                        break;
                    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        errorMessage = '';
                        break;
                }
            }
            
            showMessage(errorMessage, 'error');
            
            // Reset player state
            document.getElementById('playPauseBtn').textContent = 'PLAY';
            
            // Clean up
            if (currentMedia) {
                currentMedia.src = '';
                currentMedia = null;
                window.currentMedia = null; // üî• FIX: Update global reference
            }
            mediaPlayer.style.display = 'none';
        }

        function togglePlayPause() {
            if (!currentMedia) return;

            if (currentMedia.paused) {
                currentMedia.play();
                document.getElementById('playPauseBtn').textContent = 'PAUSE';
            } else {
                currentMedia.pause();
                document.getElementById('playPauseBtn').textContent = 'PLAY';
            }
        }

        function closePlayer() {
            // Reset play button for currently playing track
            if (currentlyPlayingId) {
                const playButtons = document.querySelectorAll(`[onclick*="${currentlyPlayingId}"]`);
                playButtons.forEach(btn => {
                    if (btn.classList.contains('play-button')) {
                        btn.textContent = 'ÂÜçÁîü';
                        btn.style.opacity = '1';
                        btn.style.background = '';
                    }
                });
                currentlyPlayingId = null;
                window.currentlyPlayingId = null; // üî• FIX: Update global reference
            }
            
            if (currentMedia) {
                currentMedia.pause();
                currentMedia = null;
                window.currentMedia = null; // üî• FIX: Update global reference
            }
            mediaPlayer.style.display = 'none';
            document.getElementById('playPauseBtn').textContent = 'PLAY';
            
            // Hide video container
            document.getElementById('videoContainer').style.display = 'none';
        }
        
        function toggleFullscreen() {
            if (currentMediaType !== 'video') return;
            
            const videoElement = document.getElementById('videoElement');
            
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                videoElement.requestFullscreen();
            }
        }

        function handleAudioEnded() {
            document.getElementById('playPauseBtn').textContent = 'PLAY';
        }

        function handleAudioError(e) {
            console.error('Audio error:', e);
            showMessage('', 'error');
            closePlayer();
        }

        function updateProgress() {
            if (!currentMedia) return;

            const progress = (currentMedia.currentTime / currentMedia.duration) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            updateTimeDisplay();
        }

        function updateTimeDisplay() {
            if (!currentMedia) return;

            const current = formatTime(currentMedia.currentTime);
            const total = formatTime(currentMedia.duration);
            document.getElementById('timeDisplay').textContent = `${current} / ${total}`;
        }

        function handleProgressClick(e) {
            if (!currentMedia) return;

            const rect = e.currentTarget.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            currentMedia.currentTime = percent * currentMedia.duration;
        }

        // Volume control functions
        function toggleMute() {
            if (!currentMedia) return;

            currentMedia.muted = !currentMedia.muted;
            updateVolumeDisplay();
        }

        function handleVolumeClick(e) {
            if (!currentMedia) return;

            const rect = e.currentTarget.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            currentMedia.volume = Math.min(1, Math.max(0, percent));
            currentMedia.muted = false;
            updateVolumeDisplay();
        }

        function updateVolumeDisplay() {
            if (!currentMedia) return;

            const volumeBtn = document.getElementById('volumeBtn');
            const volumeFill = document.getElementById('volumeFill');

            if (currentMedia.muted || currentMedia.volume === 0) {
                volumeBtn.textContent = 'MUTE';
                volumeFill.style.width = '0%';
            } else if (currentMedia.volume < 0.5) {
                volumeBtn.textContent = 'LOW';
                volumeFill.style.width = (currentMedia.volume * 100) + '%';
            } else {
                volumeBtn.textContent = 'VOL';
                volumeFill.style.width = (currentMedia.volume * 100) + '%';
            }
        }

        // Keyboard shortcuts
        function handleKeyboard(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlayPause();
                    break;
                case 'Escape':
                    closePlayer();
                    break;
            }
        }

        // Utility Functions
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function formatDuration(seconds) {
            if (!seconds) return '0:00';
            
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function escapeHtml(unsafe) {
            return (unsafe || '')
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function validateAuthInput(email, password) {
            if (!email || !password) {
                showMessage('', 'error');
                return false;
            }
            
            if (!email.includes('@')) {
                showMessage('', 'error');
                return false;
            }
            
            return true;
        }

        function clearAuthForm() {
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';
        }

        function setLoadingState(type, loading) {
            const btn = document.getElementById(`${type}Btn`);
            const text = document.getElementById(`${type}Text`);
            const loadingEl = document.getElementById(`${type}Loading`);
            
            // Check if elements exist before trying to modify them
            if (btn) {
                btn.disabled = loading;
            }
            if (text) {
                if (loading) {
                    text.classList.add('hidden');
                } else {
                    text.classList.remove('hidden');
                }
            }
            if (loadingEl) {
                if (loading) {
                    loadingEl.classList.remove('hidden');
                } else {
                    loadingEl.classList.add('hidden');
                }
            }
            
            // If elements don't exist, log a warning but don't throw an error
            if (!btn && !text && !loadingEl) {
                // console.warn(`setLoadingState: No elements found for type "${type}"`);
            }
        }

        function showProgress(message, percent) {
            const progress = document.getElementById('uploadProgress');
            const fill = document.getElementById('uploadProgressFill');
            const status = document.getElementById('uploadStatus');
            
            progress.classList.add('active');
            fill.style.width = Math.min(100, Math.max(0, percent)) + '%';
            status.textContent = message;
        }

        function hideProgress() {
            const progress = document.getElementById('uploadProgress');
            progress.classList.remove('active');
        }

        // Global message display function - works everywhere
        window.showMessage = function(message, type = 'info', context = 'auth') {
            // First try the context-specific elements for backward compatibility
            const messageId = context === 'upload' ? 'uploadMessage' : 'authMessage';
            const messageEl = document.getElementById(messageId);
            
            if (messageEl) {
                messageEl.textContent = message;
                messageEl.className = `message ${type}-message`;
                messageEl.classList.remove('hidden');
                
                setTimeout(() => {
                    messageEl.classList.add('hidden');
                }, 5000);
                return;
            }
            
            // Fallback: Create a floating message for any context
            console.log(`[${type.toUpperCase()}] ${message}`);
            
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                z-index: 10000;
                font-size: 14px;
                max-width: 400px;
                word-wrap: break-word;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                transition: opacity 0.3s ease;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;
            
            // Type-based styling
            switch(type) {
                case 'success':
                    messageDiv.style.backgroundColor = '#4CAF50';
                    messageDiv.style.color = 'white';
                    break;
                case 'error':
                    messageDiv.style.backgroundColor = '#f44336';
                    messageDiv.style.color = 'white';
                    break;
                case 'warning':
                    messageDiv.style.backgroundColor = '#ff9800';
                    messageDiv.style.color = 'white';
                    break;
                case 'info':
                default:
                    messageDiv.style.backgroundColor = '#2196F3';
                    messageDiv.style.color = 'white';
                    break;
            }
            
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.style.opacity = '0';
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.parentNode.removeChild(messageDiv);
                        }
                    }, 300);
                }
            }, 3000);
        }
        
        // Legacy function for backward compatibility
        function showMessage(message, type = 'info', context = 'auth') {
            return window.showMessage(message, type, context);
        }

        // Custom confirmation dialog to replace browser confirm() - Styled to match existing modals
        function showCustomConfirmDialog(message) {
            return new Promise((resolve) => {
                // Create modal overlay using existing system styles
                const overlay = document.createElement('div');
                overlay.className = 'modal';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(8px);
                `;

                // Create modal content using existing class structure
                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content confirmation-modal';
                modalContent.style.cssText = `
                    background: var(--panel-2);
                    border-radius: var(--radius);
                    border: 1px solid rgba(159, 247, 234, 0.2);
                    box-shadow: var(--shadow);
                    max-width: 480px;
                    width: 90%;
                    overflow: hidden;
                    animation: modalSlideIn 0.2s ease-out;
                `;

                // Create modal header
                const modalHeader = document.createElement('div');
                modalHeader.className = 'modal-header';
                modalHeader.style.cssText = `
                    padding: 24px 32px 0;
                    border-bottom: none;
                `;

                const title = document.createElement('h2');
                title.textContent = 'ÂâäÈô§„ÅÆÁ¢∫Ë™ç';
                title.style.cssText = `
                    color: var(--text);
                    font-size: 20px;
                    font-weight: 600;
                    margin: 0;
                    margin-bottom: 16px;
                `;

                // Create modal body
                const modalBody = document.createElement('div');
                modalBody.className = 'modal-body';
                modalBody.style.cssText = `
                    padding: 0 32px 24px;
                `;

                const messageEl = document.createElement('p');
                messageEl.textContent = message;
                messageEl.className = 'confirm-message';
                messageEl.style.cssText = `
                    color: var(--muted);
                    font-size: 15px;
                    line-height: 1.6;
                    margin: 0 0 24px 0;
                `;

                // Create modal footer
                const modalFooter = document.createElement('div');
                modalFooter.className = 'modal-footer';
                modalFooter.style.cssText = `
                    display: flex;
                    gap: 12px;
                    padding: 0 32px 32px;
                    justify-content: flex-end;
                `;

                // Create Cancel button using existing auth-button styles
                const cancelButton = document.createElement('button');
                cancelButton.textContent = '„Ç≠„É£„É≥„Çª„É´';
                cancelButton.className = 'auth-button secondary';
                cancelButton.style.cssText = `
                    background: var(--panel);
                    color: var(--text);
                    border: 1px solid rgba(159, 247, 234, 0.2);
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    min-width: 90px;
                `;

                // Create OK/Delete button using existing danger auth-button styles  
                const okButton = document.createElement('button');
                okButton.textContent = 'ÂâäÈô§';
                okButton.className = 'auth-button danger';
                okButton.style.cssText = `
                    background: var(--danger);
                    color: white;
                    border: none;
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    min-width: 90px;
                `;

                // Add hover effects matching existing system
                cancelButton.onmouseover = () => {
                    cancelButton.style.background = 'var(--panel-2)';
                    cancelButton.style.borderColor = 'var(--accent)';
                    cancelButton.style.transform = 'translateY(-1px)';
                };
                cancelButton.onmouseout = () => {
                    cancelButton.style.background = 'var(--panel)';
                    cancelButton.style.borderColor = 'rgba(159, 247, 234, 0.2)';
                    cancelButton.style.transform = 'translateY(0)';
                };

                okButton.onmouseover = () => {
                    okButton.style.background = '#ff5252';
                    okButton.style.transform = 'translateY(-1px)';
                };
                okButton.onmouseout = () => {
                    okButton.style.background = 'var(--danger)';
                    okButton.style.transform = 'translateY(0)';
                };

                // Event handlers
                const cleanup = () => {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                    }
                };

                okButton.onclick = () => {
                    console.log('üîî DEBUG: Custom dialog - User clicked ÂâäÈô§');
                    cleanup();
                    resolve(true);
                };

                cancelButton.onclick = () => {
                    console.log('üîî DEBUG: Custom dialog - User clicked „Ç≠„É£„É≥„Çª„É´');
                    cleanup();
                    resolve(false);
                };

                // ESC key support
                const handleKeydown = (e) => {
                    if (e.key === 'Escape') {
                        console.log('üîî DEBUG: Custom dialog - User pressed ESC');
                        cleanup();
                        document.removeEventListener('keydown', handleKeydown);
                        resolve(false);
                    }
                };
                document.addEventListener('keydown', handleKeydown);

                // Click outside to close
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        console.log('üîî DEBUG: Custom dialog - User clicked outside');
                        cleanup();
                        document.removeEventListener('keydown', handleKeydown);
                        resolve(false);
                    }
                };

                // Assemble the modal structure
                modalHeader.appendChild(title);
                modalBody.appendChild(messageEl);
                modalFooter.appendChild(cancelButton);
                modalFooter.appendChild(okButton);
                
                modalContent.appendChild(modalHeader);
                modalContent.appendChild(modalBody);
                modalContent.appendChild(modalFooter);
                overlay.appendChild(modalContent);

                // Add CSS animation keyframes if not already present
                if (!document.querySelector('#custom-modal-animations')) {
                    const style = document.createElement('style');
                    style.id = 'custom-modal-animations';
                    style.textContent = `
                        @keyframes modalSlideIn {
                            from {
                                opacity: 0;
                                transform: translateY(-20px) scale(0.95);
                            }
                            to {
                                opacity: 1;
                                transform: translateY(0) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                // Add to DOM
                document.body.appendChild(overlay);
                console.log('üîî DEBUG: Unified custom confirmation dialog created and shown');
            });
        }

        // Generate tone audio (from original GPT-5 design)
        function generateToneAudio(frequency, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const sampleRate = audioContext.sampleRate;
                const length = sampleRate * duration;
                const audioBuffer = audioContext.createBuffer(1, length, sampleRate);
                const data = audioBuffer.getChannelData(0);
                
                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    data[i] = Math.sin(2 * Math.PI * frequency * t) * 0.1 * Math.exp(-t * 0.1);
                }
                
                // Convert buffer to blob URL
                const offlineContext = new OfflineAudioContext(1, length, sampleRate);
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(offlineContext.destination);
                source.start();
                
                return offlineContext.startRendering().then(renderedBuffer => {
                    const wavBlob = bufferToWave(renderedBuffer);
                    return URL.createObjectURL(wavBlob);
                }).catch(() => {
                    // Fallback: return a data URL
                    return `data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXLPu55hVFApGn+DyvmUhBz2Y3/PJeSj+KoXs6ZlbCf8+8tnWwz4+c1+6+d++WbfB`;
                });
            } catch (error) {
                console.error('Audio generation error:', error);
                return '';
            }
        }
        
        function bufferToWave(abuffer) {
            const numOfChan = abuffer.numberOfChannels;
            const length = abuffer.length * numOfChan * 2 + 44;
            const buffer = new ArrayBuffer(length);
            const view = new DataView(buffer);
            const channels = [];
            let sample;
            let offset = 0;
            let pos = 0;

            // write WAVE header
            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length - 8
            setUint32(0x45564157); // "WAVE"

            setUint32(0x20746d66); // "fmt " chunk
            setUint32(16); // length = 16
            setUint16(1); // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2); // block-align
            setUint16(16); // 16-bit

            setUint32(0x61746164); // "data" - chunk
            setUint32(length - pos - 4); // chunk length

            // write interleaved data
            for (let i = 0; i < abuffer.numberOfChannels; i++) {
                channels.push(abuffer.getChannelData(i));
            }

            while (pos < length) {
                for (let i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int
                    view.setInt16(pos, sample, true); // write 16-bit sample
                    pos += 2;
                }
                offset++; // next sample
            }

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }

            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }

            return new Blob([buffer], { type: "audio/wav" });
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', initializeApp);

        
        // Track deletion functions
        // Confirmation preferences storage
        let confirmationPreferences = {
            skipDeleteConfirmation: false,
            skipRemoveConfirmation: false
        };

        // Load preferences from localStorage
        function loadConfirmationPreferences() {
            const saved = localStorage.getItem('confirmationPreferences');
            if (saved) {
                try {
                    confirmationPreferences = JSON.parse(saved);
                    // console.log(' Loaded confirmation preferences:', confirmationPreferences);
                } catch (e) {
                    console.error('Failed to load confirmation preferences:', e);
                }
            }
        }

        // Save preferences to localStorage
        function saveConfirmationPreferences() {
            localStorage.setItem('confirmationPreferences', JSON.stringify(confirmationPreferences));
            // console.log(' Saved confirmation preferences:', confirmationPreferences);
        }

        // Initialize preferences on load
        loadConfirmationPreferences();

        // Custom confirmation modal functions
        let pendingConfirmation = null;

        window.showConfirmationModal = function(options) {
            const {
                title,
                message,
                warningMessage,
                confirmText = 'Á¢∫Ë™ç',
                cancelText = '„Ç≠„É£„É≥„Çª„É´',
                skipOption = false,
                skipKey = null,
                onConfirm,
                onCancel
            } = options;

            pendingConfirmation = { onConfirm, onCancel };

            // Set modal content
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').textContent = message;
            
            const warningElement = document.getElementById('confirmWarning');
            if (warningMessage) {
                warningElement.textContent = warningMessage;
                warningElement.style.display = 'block';
            } else {
                warningElement.style.display = 'none';
            }

            // Set button texts
            document.getElementById('confirmActionBtn').textContent = confirmText;
            document.getElementById('confirmCancelBtn').textContent = cancelText;

            // Handle skip option
            const skipContainer = document.getElementById('confirmSkipContainer');
            const skipCheckbox = document.getElementById('confirmSkipCheckbox');
            if (skipOption && skipKey) {
                skipContainer.style.display = 'flex';
                skipCheckbox.checked = false;
                skipCheckbox.dataset.skipKey = skipKey;
            } else {
                skipContainer.style.display = 'none';
            }

            // Show modal
            document.getElementById('confirmationModal').style.display = 'flex';
        }

        window.confirmAction = function() {
            const skipCheckbox = document.getElementById('confirmSkipCheckbox');
            if (skipCheckbox.checked && skipCheckbox.dataset.skipKey) {
                confirmationPreferences[skipCheckbox.dataset.skipKey] = true;
                saveConfirmationPreferences();
            }

            closeConfirmationModal();
            if (pendingConfirmation && pendingConfirmation.onConfirm) {
                pendingConfirmation.onConfirm();
            }
        }

        window.cancelAction = function() {
            closeConfirmationModal();
            if (pendingConfirmation && pendingConfirmation.onCancel) {
                pendingConfirmation.onCancel();
            }
        }

        window.closeConfirmationModal = function() {
            document.getElementById('confirmationModal').style.display = 'none';
            pendingConfirmation = null;
        }

        async function confirmDeleteTrack(trackId, title) {
            if (!currentUser) {
                showMessage('', 'error');
                return;
            }

            // console.log('Delete track request:', { trackId, title, user: currentUser.uid });

            // Check if we should skip confirmation
            if (confirmationPreferences.skipDeleteConfirmation) {
                // console.log(' Skipping delete confirmation (user preference)');
                await deleteTrack(trackId);
                return;
            }

            // Show custom confirmation modal
            showConfirmationModal({
                title: '„Éà„É©„ÉÉ„ÇØ„ÇíÂâäÈô§',
                message: `"${title}" „ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`,
                warningMessage: '„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ',
                confirmText: 'ÂâäÈô§',
                cancelText: '„Ç≠„É£„É≥„Çª„É´',
                skipOption: true,
                skipKey: 'skipDeleteConfirmation',
                onConfirm: async () => {
                    // console.log('User confirmed deletion for trackId:', trackId);
                    await deleteTrack(trackId);
                },
                onCancel: () => {
                    // console.log('User cancelled deletion for trackId:', trackId);
                }
            });
        }

        async function deleteTrack(trackId) {
            try {
                // console.log('Starting track deletion:', trackId);
                setLoadingState('delete', true);
                showMessage('...', 'warning');

                // console.log('Calling DELETE API for trackId:', trackId);
                const response = await apiClient.request(`/api/tracks/${trackId}`, {
                    method: 'DELETE'
                });

                // console.log('Delete API response:', response);
                showMessage('', 'success');
                
                // Immediately remove from episodes array for faster UI response
                const beforeCount = episodes.length;
                episodes = episodes.filter(ep => ep.trackId !== trackId);
                // console.log(` Removed from episodes array: ${beforeCount} -> ${episodes.length}`);
                
                // Force clear cache and reload episodes to reflect changes
                // console.log('Reloading episodes after deletion');
                forceClearEpisodesCache();
                await loadEpisodes();
                
                // Additional UI cleanup for deleted track
                const deletedTrackElement = document.querySelector(`[onclick*="playEpisode('${trackId}')"]`);
                if (deletedTrackElement) {
                    const episodeCard = deletedTrackElement.closest('.episode-card');
                    if (episodeCard) {
                        episodeCard.style.transition = 'opacity 0.3s ease-out';
                        episodeCard.style.opacity = '0';
                        setTimeout(() => {
                            if (episodeCard.parentNode) {
                                episodeCard.parentNode.removeChild(episodeCard);
                            }
                        }, 300);
                    }
                }
                
                // Close player if deleted track was playing
                const currentPlayingId = getCurrentPlayingTrackId();
                if (currentPlayingId === trackId) {
                    // console.log('Closing player for deleted track');
                    closePlayer();
                }
                
                // console.log('Track deletion completed successfully');
                
            } catch (error) {
                console.error('Delete error:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    trackId: trackId,
                    status: error.status,
                    response: error.response
                });
                
                let errorMessage = '';
                if (error.message.includes('403') || error.message.includes('Permission denied')) {
                    errorMessage = '';
                } else if (error.message.includes('404') || error.message.includes('not found')) {
                    errorMessage = '';
                } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                    errorMessage = '';
                } else {
                    errorMessage += ': ' + error.message;
                }
                
                showMessage(errorMessage, 'error');
            } finally {
                setLoadingState('delete', false);
            }
        }

        async function confirmDeleteOrphanedTrack(trackId, title) {
            // Special deletion for orphaned tracks (no uploaderUid or no audioUrl)
            // Show custom confirmation modal
            showConfirmationModal({
                title: 'Á†¥Êêç„Éà„É©„ÉÉ„ÇØ„ÇíÂâäÈô§',
                message: `"${title}" „ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`,
                warningMessage: '„Åì„ÅÆ„Éà„É©„ÉÉ„ÇØ„ÅØ„Ç¢„Ç´„Ç¶„É≥„Éà„Å´Á¥ê„Å•„ÅÑ„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÄÅÈü≥Â£∞„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÁ†¥Êêç„Åó„Åü„Éà„É©„ÉÉ„ÇØ„Åß„Åô„ÄÇÂâäÈô§„Åô„Çã„Åì„Å®„Åß‰ªñ„ÅÆ„É¶„Éº„Ç∂„Éº„Å´„ÇÇÂΩπÁ´ã„Å°„Åæ„Åô„ÄÇ',
                confirmText: 'ÂâäÈô§',
                cancelText: '„Ç≠„É£„É≥„Çª„É´',
                skipOption: false,
                onConfirm: async () => {
                    await deleteOrphanedTrack(trackId);
                },
                onCancel: () => {
                    // User cancelled deletion
                }
            });
        }

        async function deleteOrphanedTrack(trackId) {
            try {
                setLoadingState('delete', true);
                showMessage('Á†¥Êêç„Éà„É©„ÉÉ„ÇØ„ÇíÂâäÈô§‰∏≠...', 'warning');

                // Call the special orphaned track deletion API
                const response = await apiClient.request(`/api/tracks/${trackId}/delete-orphaned`, {
                    method: 'DELETE'
                });

                showMessage('Á†¥Êêç„Éà„É©„ÉÉ„ÇØ„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü', 'success');
                
                // Remove from episodes array for faster UI response
                const beforeCount = episodes.length;
                episodes = episodes.filter(ep => ep.trackId !== trackId);
                
                // Force clear cache and reload episodes
                forceClearEpisodesCache();
                await loadEpisodes();
                
                // UI cleanup for deleted track
                const deletedTrackElement = document.querySelector(`[onclick*="playEpisode('${trackId}')"]`);
                if (deletedTrackElement) {
                    const episodeCard = deletedTrackElement.closest('.episode-card');
                    if (episodeCard) {
                        episodeCard.style.transition = 'opacity 0.3s ease-out';
                        episodeCard.style.opacity = '0';
                        setTimeout(() => {
                            if (episodeCard.parentNode) {
                                episodeCard.parentNode.removeChild(episodeCard);
                            }
                        }, 300);
                    }
                }
                
                // Close player if deleted track was playing
                const currentPlayingId = getCurrentPlayingTrackId();
                if (currentPlayingId === trackId) {
                    closePlayer();
                }
                
            } catch (error) {
                console.error('Orphaned track deletion error:', error);
                console.error('Error details:', {
                    message: error.message,
                    status: error.status,
                    stack: error.stack
                });
                
                let errorMessage = 'Á†¥Êêç„Éà„É©„ÉÉ„ÇØ„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
                if (error.message.includes('404')) {
                    errorMessage = '„Éà„É©„ÉÉ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì';
                } else if (error.message.includes('500')) {
                    errorMessage = '„Çµ„Éº„Éê„Éº„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
                } else if (error.message.includes('400')) {
                    errorMessage = '„Åì„ÅÆ„Éà„É©„ÉÉ„ÇØ„ÅØÁ†¥Êêç„Éà„É©„ÉÉ„ÇØ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì';
                } else if (error.message.includes('503')) {
                    errorMessage = '„Éá„Éº„Çø„Éô„Éº„Çπ„Çµ„Éº„Éì„Çπ„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì';
                }
                
                // „Çà„ÇäË©≥Á¥∞„Å™„Ç®„É©„ÉºÊÉÖÂ†±„ÇíË°®Á§∫
                showMessage(`${errorMessage} (${error.message})`, 'error');
                
            } finally {
                setLoadingState('delete', false);
            }
        }

        function getCurrentPlayingTrackId() {
            // Extract track ID from current media if available
            if (!currentMedia || !currentMedia.src) return null;
            
            const matches = currentMedia.src.match(/\/tracks\/([^\/]+)\/stream/);
            return matches ? matches[1] : null;
        }

        // Episode menu functions
        function toggleEpisodeMenu(trackId) {
            // Close all other menus
            document.querySelectorAll('.menu-dropdown.active').forEach(menu => {
                if (menu.id !== `menu-${trackId}`) {
                    menu.classList.remove('active');
                }
            });
            
            // Toggle the clicked menu
            const menu = document.getElementById(`menu-${trackId}`);
            if (menu) {
                menu.classList.toggle('active');
            }
        }

        // Track Edit Functions
        let currentEditingTrackId = null;
        
        async function openTrackEditor(trackId, title, description) {
            // console.log(' Opening track editor for:', { trackId, title, description });
            
            if (!currentUser) {
                showMessage('', 'error');
                return;
            }
            
            currentEditingTrackId = trackId;
            
            // Close any open menus
            document.querySelectorAll('.menu-dropdown.active').forEach(menu => {
                menu.classList.remove('active');
            });
            
            try {
                // Fetch current track data
                showMessage('...', 'warning');
                const trackData = await apiClient.request(`/api/tracks/${trackId}`);
                
                // Populate the form with current values
                document.getElementById('editTrackTitle').value = trackData.title || title || '';
                document.getElementById('editTrackDescription').value = trackData.description || description || '';
                document.getElementById('editTrackGenre').value = trackData.genre || '';
                document.getElementById('editTrackTags').value = trackData.tags || '';
                // Public visibility removed - all tracks are now public by default
                document.getElementById('editTrackDownloadable').checked = trackData.allowDownloads === true;
                
                // Show the modal
                document.getElementById('trackEditModal').style.display = 'flex';
                
                // Focus on title field
                setTimeout(() => {
                    document.getElementById('editTrackTitle').focus();
                }, 100);
                
                showMessage('', ''); // Clear message
            } catch (error) {
                console.error('Failed to load track data:', error);
                console.error('Load error details:', {
                    message: error.message,
                    trackId: trackId,
                    user: currentUser ? currentUser.email : 'none'
                });
                
                let errorMessage = '';
                if (error.message.includes('403') || error.message.includes('Access denied')) {
                    errorMessage = '';
                } else if (error.message.includes('404')) {
                    errorMessage = '';
                } else {
                    errorMessage = `: ${error.message}`;
                }
                
                showMessage(errorMessage, 'error');
            }
        }
        
        function closeTrackEditor() {
            document.getElementById('trackEditModal').style.display = 'none';
            currentEditingTrackId = null;
            
            // Clear form
            document.getElementById('trackEditForm').reset();
        }
        
        async function saveTrackChanges() {
            if (!currentEditingTrackId || !currentUser) {
                showMessage('', 'error');
                return;
            }
            
            // Get form values
            const title = document.getElementById('editTrackTitle').value.trim();
            const description = document.getElementById('editTrackDescription').value.trim();
            const genre = document.getElementById('editTrackGenre').value;
            const tags = document.getElementById('editTrackTags').value.trim();
            const isPublic = true; // All tracks are public by default
            const allowDownloads = document.getElementById('editTrackDownloadable').checked;
            
            // Validate required fields
            if (!title) {
                showMessage('', 'error');
                document.getElementById('editTrackTitle').focus();
                return;
            }
            
            if (title.length > 200) {
                showMessage('200', 'error');
                document.getElementById('editTrackTitle').focus();
                return;
            }
            
            if (description.length > 1000) {
                showMessage('1000', 'error');
                document.getElementById('editTrackDescription').focus();
                return;
            }
            
            try {
                const saveBtn = document.getElementById('saveTrackBtn');
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';
                
                showMessage('...', 'warning');
                
                const updateData = {
                    title: title,
                    description: description || null,
                    genre: genre || null,
                    tags: tags || null,
                    isPublic: isPublic,
                    allowDownloads: allowDownloads
                };
                
                // console.log(' Updating track:', currentEditingTrackId, updateData);
                
                await apiClient.request(`/api/tracks/${currentEditingTrackId}`, {
                    method: 'PUT',
                    body: JSON.stringify(updateData)
                });
                
                showMessage(' ', 'success');
                
                // Close modal
                closeTrackEditor();
                
                // Reload episodes to reflect changes
                await loadEpisodes();
                
            } catch (error) {
                console.error('Failed to update track:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    trackId: currentEditingTrackId,
                    user: currentUser ? currentUser.email : 'none'
                });
                
                let errorMessage = '';
                
                if (error.message.includes('403') || error.message.includes('Forbidden') || error.message.includes('Access denied')) {
                    errorMessage = '';
                } else if (error.message.includes('404') || error.message.includes('not found')) {
                    errorMessage = '';
                } else if (error.message.includes('400') || error.message.includes('Bad Request')) {
                    errorMessage = ': ' + error.message;
                } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                    errorMessage = '';
                } else {
                    errorMessage = `: ${error.message}`;
                }
                
                showMessage(errorMessage, 'error');
            } finally {
                const saveBtn = document.getElementById('saveTrackBtn');
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Changes';
            }
        }

        // Playlist Management Functions
        let currentPlaylists = [];
        let selectedPlaylistEmoji = '';
        
        // üî• PLAYLIST FIX: Make selectedPlaylistId globally accessible
        window.selectedPlaylistId = 'all'; // 'all' means show all tracks
        let playlistTracks = {}; // Cache for playlist tracks

        window.openPlaylistManager = function() {
            // console.log(' Opening playlist manager...');
            document.getElementById('playlistModal').style.display = 'flex';
            loadUserPlaylists();
        };

        window.openPodcastPlaylistManager = function() {
            console.log('üéôÔ∏è Opening podcast playlist manager...');
            document.getElementById('podcastPlaylistModal').style.display = 'flex';
            loadUserPodcastPlaylists();
        };

        // Load User Podcast Playlists for Management
        window.loadUserPodcastPlaylists = async function() {
            const container = document.getElementById('podcastPlaylistsList');
            container.innerHTML = '<div class="loading-item">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>';
            
            try {
                const response = await fetch('/api/podcast-playlists', {
                    headers: {
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);
                
                const data = await response.json();
                const playlists = data.playlists || [];
                
                if (playlists.length === 0) {
                    container.innerHTML = `
                        <div class="no-playlists" style="text-align: center; padding: 40px; color: var(--text-muted);">
                            <div style="font-size: 3em; margin-bottom: 16px;">üéôÔ∏è</div>
                            <h3 style="margin: 0 0 12px 0; color: var(--text);">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</h3>
                            <p style="margin: 0 0 20px 0;">Êñ∞„Åó„ÅÑ„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„Çí‰ΩúÊàê„Åó„Å¶„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅÆ„Ç®„Éî„ÇΩ„Éº„Éâ„ÇíÊï¥ÁêÜ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
                            <button onclick="createNewPodcastPlaylist();" class="auth-button">
                                <span>+</span> Êñ∞„Åó„ÅÑ„Éó„É¨„Ç§„É™„Çπ„Éà‰ΩúÊàê
                            </button>
                        </div>
                    `;
                    return;
                }
                
                let html = '';
                playlists.forEach(playlist => {
                    const episodeCount = playlist.episodes ? playlist.episodes.length : 0;
                    const lastUpdated = playlist.last_updated ? new Date(playlist.last_updated).toLocaleDateString('ja-JP') : '';
                    
                    html += `
                        <div class="playlist-item" style="display: flex; align-items: center; padding: 16px; border: 1px solid rgba(159, 247, 234, 0.3); border-radius: 12px; margin-bottom: 12px; background: rgba(159, 247, 234, 0.05); transition: all 0.2s ease;">
                            <div class="playlist-icon" style="font-size: 2em; margin-right: 16px;">
                                ${playlist.emoji || 'üéôÔ∏è'}
                            </div>
                            <div class="playlist-info" style="flex: 1;">
                                <h3 style="margin: 0 0 4px 0; font-size: 1.1em; color: var(--text);">${playlist.name}</h3>
                                <p style="margin: 0; font-size: 0.9em; color: var(--text-muted);">
                                    ${episodeCount} „Ç®„Éî„ÇΩ„Éº„Éâ
                                    ${lastUpdated ? ` ‚Ä¢ ÊúÄÁµÇÊõ¥Êñ∞: ${lastUpdated}` : ''}
                                </p>
                                ${playlist.description ? `<p style="margin: 8px 0 0 0; font-size: 0.85em; color: var(--text-muted); opacity: 0.8;">${playlist.description}</p>` : ''}
                            </div>
                            <div class="playlist-actions" style="display: flex; gap: 8px;">
                                <button class="auth-button small" onclick="openPodcastPlaylist('${playlist.id}', '${playlist.name.replace(/'/g, "\\'")}');" title="„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÈñã„Åè">
                                    Èñã„Åè
                                </button>
                                <button class="auth-button small secondary" onclick="editPodcastPlaylist('${playlist.id}');" title="„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÁ∑®ÈõÜ">
                                    Á∑®ÈõÜ
                                </button>
                                <button class="auth-button small danger" onclick="deletePodcastPlaylist('${playlist.id}', '${playlist.name.replace(/'/g, "\\'")}');" title="„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÂâäÈô§">
                                    ÂâäÈô§
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to load podcast playlists:', error);
                container.innerHTML = `
                    <div class="error-message" style="text-align: center; padding: 40px; color: var(--error-color);">
                        <div style="font-size: 2em; margin-bottom: 16px;">‚ö†Ô∏è</div>
                        <h3 style="margin: 0 0 12px 0;">Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº</h3>
                        <p style="margin: 0 0 20px 0;">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ</p>
                        <button onclick="loadUserPodcastPlaylists();" class="auth-button">
                            ÂÜçË©¶Ë°å
                        </button>
                    </div>
                `;
            }
        };

        // Close Podcast Playlist Manager
        window.closePodcastPlaylistManager = function() {
            console.log('üéôÔ∏è Closing podcast playlist manager...');
            document.getElementById('podcastPlaylistModal').style.display = 'none';
        };

        // Open Podcast Playlist
        window.openPodcastPlaylist = async function(playlistId, playlistName) {
            console.log('üéôÔ∏è Opening podcast playlist:', playlistName, 'with ID:', playlistId);
            
            try {
                // üî• CRITICAL FIX: If only name is provided, resolve to actual ID
                let actualPlaylistId = playlistId;
                let actualPlaylistName = playlistName;
                
                if (!playlistId && playlistName) {
                    console.log(`üîç Resolving playlist name "${playlistName}" to ID...`);
                    
                    try {
                        const response = await fetch('/api/podcast-playlists', {
                            headers: {
                                'Authorization': `Bearer ${await currentUser.getIdToken()}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const playlist = data.playlists?.find(p => p.name === playlistName);
                            if (playlist) {
                                actualPlaylistId = playlist.id;
                                actualPlaylistName = playlist.name;
                                console.log(`‚úÖ Resolved "${playlistName}" to ID: ${actualPlaylistId}`);
                            } else {
                                console.warn(`‚ùå Could not find playlist with name: ${playlistName}`);
                                showMessage(`„Éó„É¨„Ç§„É™„Çπ„Éà„Äå${playlistName}„Äç„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`, 'error');
                                return;
                            }
                        } else {
                            throw new Error(`Failed to get playlists: ${response.status}`);
                        }
                    } catch (error) {
                        console.error('üî• Failed to resolve playlist ID:', error);
                        showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆÊÉÖÂ†±ÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                        return;
                    }
                }
                
                // Use resolved values
                playlistId = actualPlaylistId;
                playlistName = actualPlaylistName;
                
                // Close the playlist manager modal first
                closePodcastPlaylistManager();
                
                // Show library screen first
                showLibraryScreen();
                
                // üî• NEW FIX: Hide music track areas and show podcast episode areas
                const episodeGrid = document.getElementById('episodeGrid');
                const podcastSearchResults = document.getElementById('podcastSearchResults');
                const noEpisodesMsg = document.getElementById('noEpisodes');
                
                // Hide music track display areas
                if (episodeGrid) {
                    episodeGrid.style.display = 'none';
                    console.log('üéôÔ∏è Hidden music tracks area (episodeGrid)');
                }
                if (noEpisodesMsg) {
                    noEpisodesMsg.style.display = 'none';
                }
                
                // Show podcast episode display area
                if (podcastSearchResults) {
                    podcastSearchResults.style.display = 'block';
                    console.log('üéôÔ∏è Showing podcast episode area (podcastSearchResults)');
                    
                    // üî• CRITICAL FIX: Remove hidden class from parent section
                    const parentSection = podcastSearchResults.closest('.section');
                    if (parentSection) {
                        parentSection.classList.remove('hidden');
                        parentSection.style.display = 'block';
                        console.log('üéôÔ∏è Removed hidden class from parent section');
                    }
                }
                
                // Update the search results header for playlist display
                const titleElement = document.getElementById('searchResultsTitle');
                const countElement = document.getElementById('searchResultsCount');
                if (titleElement) {
                    titleElement.textContent = `üéôÔ∏è ${playlistName}`;
                }
                
                // Clear any existing episode display
                const episodesList = document.getElementById('episodesList');
                if (episodesList) {
                    episodesList.innerHTML = '';
                    // üî• CRITICAL FIX: Ensure episodes list is visible
                    episodesList.style.display = 'block';
                    episodesList.style.visibility = 'visible';
                    console.log('üéôÔ∏è Cleared existing episode display and ensured visibility');
                }
                
                // Set the selected playlist with podcast_ prefix
                const podcastPlaylistId = `podcast_${playlistId}`;
                
                // üîß FIX: Update the global variable BEFORE changing the selector
                window.selectedPlaylistId = podcastPlaylistId;
                console.log(`üéôÔ∏è Set selectedPlaylistId to: ${window.selectedPlaylistId}`);
                
                // Update the playlist selector
                const selector = document.getElementById('playlistSelector');
                if (selector) {
                    // First, check if the option exists, if not, add it
                    let optionExists = false;
                    for (let option of selector.options) {
                        if (option.value === podcastPlaylistId) {
                            optionExists = true;
                            break;
                        }
                    }
                    
                    if (!optionExists) {
                        // Add the podcast playlist option
                        const newOption = document.createElement('option');
                        newOption.value = podcastPlaylistId;
                        newOption.textContent = `üéôÔ∏è ${playlistName}`;
                        selector.appendChild(newOption);
                    }
                    
                    selector.value = podcastPlaylistId;
                    
                    // üîß FIX: Directly call loadPodcastPlaylistContent instead of triggering change event
                    // This ensures the podcast playlist content is loaded directly
                    console.log(`üéôÔ∏è Directly loading podcast playlist content for: ${podcastPlaylistId}`);
                    await window.loadPodcastPlaylistContent(podcastPlaylistId);
                    
                    // Update the count after loading
                    if (countElement && episodesList) {
                        const episodeItems = episodesList.querySelectorAll('.episode-item');
                        countElement.textContent = `${episodeItems.length}„Ç®„Éî„ÇΩ„Éº„Éâ`;
                    }
                }
                
                // Show success message
                showMessage(`üéôÔ∏è „Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„Éó„É¨„Ç§„É™„Çπ„Éà„Äå${playlistName}„Äç„ÇíÈñã„Åç„Åæ„Åó„Åü`, 'success');
                
                // Scroll to the library section
                const librarySection = document.querySelector('#podcastLibrarySection');
                if (librarySection) {
                    librarySection.scrollIntoView({ behavior: 'smooth' });
                }
                
            } catch (error) {
                console.error('Failed to open podcast playlist:', error);
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÈñã„Åë„Åæ„Åõ„Çì„Åß„Åó„Åü', 'error');
            }
        };

        // Edit Podcast Playlist
        window.editPodcastPlaylist = function(playlistId) {
            console.log('üéôÔ∏è Editing podcast playlist:', playlistId);
            // TODO: Implement playlist editing functionality
            alert('„Éó„É¨„Ç§„É™„Çπ„ÉàÁ∑®ÈõÜÊ©üËÉΩ„ÅØÊ∫ñÂÇô‰∏≠„Åß„Åô„ÄÇ');
        };

        // Delete Podcast Playlist
        window.deletePodcastPlaylist = async function(playlistId, playlistName) {
            console.log('üéôÔ∏è Deleting podcast playlist:', playlistName);
            
            if (!confirm(`„Éó„É¨„Ç§„É™„Çπ„Éà„Äå${playlistName}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\n\n„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ`)) {
                console.log('üéôÔ∏è Deletion cancelled by user');
                return;
            }
            
            try {
                const response = await fetch(`/api/podcast-playlists/${playlistId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to delete playlist: ${response.status}`);
                }
                
                showMessage(`üéôÔ∏è „Éó„É¨„Ç§„É™„Çπ„Éà„Äå${playlistName}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü`, 'success');
                
                // üîß ENHANCED DELETION: Clear all caches and reset state
                const podcastPlaylistId = `podcast_${playlistId}`;
                
                // Clear playlist selector if this playlist was selected
                if (window.selectedPlaylistId === podcastPlaylistId) {
                    window.selectedPlaylistId = null;
                    const selector = document.getElementById('playlistSelector');
                    if (selector) {
                        // Remove the playlist option from selector
                        for (let i = 0; i < selector.options.length; i++) {
                            if (selector.options[i].value === podcastPlaylistId) {
                                selector.remove(i);
                                break;
                            }
                        }
                        // Reset to default selection
                        selector.value = '';
                    }
                }
                
                // Clear episode display if showing deleted playlist
                const episodesList = document.getElementById('episodesList');
                if (episodesList && window.selectedPlaylistId === podcastPlaylistId) {
                    episodesList.innerHTML = '<div class="no-episodes">„Éó„É¨„Ç§„É™„Çπ„Éà„ÅåÂâäÈô§„Åï„Çå„Åæ„Åó„Åü</div>';
                }
                
                // Force reload of playlist manager without closing it
                await loadUserPodcastPlaylists();
                
                // Ensure the podcast playlist manager stays open after deletion
                const podcastModal = document.getElementById('podcastPlaylistModal');
                if (podcastModal) {
                    podcastModal.style.display = 'flex';
                    console.log('üéôÔ∏è Podcast playlist manager kept open after deletion');
                }
                
                // Clear any cached playlist data
                if (window.playlistCache) {
                    delete window.playlistCache[podcastPlaylistId];
                    delete window.playlistCache[playlistId];
                }
                
            } catch (error) {
                console.error('Failed to delete podcast playlist:', error);
                showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        };

        // Remove Podcast From Playlist - REMOVED (duplicate function)

        // Initialize playlist selector
        function initializePlaylistSelector() {
            const selector = document.getElementById('playlistSelector');
            if (selector) {
                selector.addEventListener('change', handlePlaylistSelection);
            }
        }

        // Handle playlist selection change
        async function handlePlaylistSelection(event) {
            // üîß FIX: Support both manual calls and event-based calls
            const selector = event ? event.target : document.getElementById('playlistSelector');
            const selectedValue = selector.value;
            // „Éó„É¨„Ç§„É™„Çπ„ÉàÊÉÖÂ†±Ë°®Á§∫„ÅØÂâäÈô§Ê∏à„Åø
            // const infoElement = document.getElementById('currentPlaylistInfo');
            
            console.log(`üîç handlePlaylistSelection called: ${selectedValue}`);
            console.log(`üîç Event type: ${event ? event.type : 'manual call'}`);
            
            // üî• PLAYLIST FIX: Update global variable
            window.selectedPlaylistId = selectedValue;
            console.log(`üîç Updated selectedPlaylistId to: ${window.selectedPlaylistId}`);
            
            // Check if it's a podcast playlist
            if (selectedValue && selectedValue.startsWith('podcast_')) {
                console.log('üéôÔ∏è Podcast playlist selected, loading podcast episodes...');
                await window.loadPodcastPlaylistContent(selectedValue);
            } else {
                // Reload episodes with new filter for regular playlists
                console.log('üîÑ Reloading episodes with new filter...');
                await loadEpisodes();
            }
        }

        // Load Podcast Playlist Content
        window.loadPodcastPlaylistContent = async function(podcastPlaylistId) {
            console.log('üéôÔ∏è Loading podcast playlist content:', podcastPlaylistId);
            
            // Try different possible container IDs
            const container = document.getElementById('episodesList') || document.getElementById('episodesContainer') || document.getElementById('libraryResults');
            const loadingIndicator = document.getElementById('loadingEpisodes');
            const noEpisodes = document.getElementById('noEpisodes');
            
            if (!container) {
                console.error('Episodes container not found. Available containers:', 
                    Array.from(document.querySelectorAll('[id*="episode"], [id*="library"]')).map(el => el.id));
                return;
            }
            
            console.log('Using container:', container.id);
            
            // üöÄ ENHANCED: Show detailed loading indicator with progress
            if (loadingIndicator) loadingIndicator.style.display = 'block';
            if (noEpisodes) noEpisodes.style.display = 'none';
            
            // Add detailed loading message to container
            container.innerHTML = `
                <div class="podcast-playlist-loading" style="text-align: center; padding: 40px; color: var(--text-muted);">
                    <h3 style="margin: 0 0 12px 0; color: var(--text);">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠...</h3>
                    <p id="loadingProgress" style="margin: 0; font-size: 0.9em;">„Éó„É¨„Ç§„É™„Çπ„ÉàÊÉÖÂ†±„ÇíÂèñÂæó‰∏≠...</p>
                    <div class="loading-dots" style="margin-top: 16px;">
                        <span style="animation: loading-dot 1.4s infinite ease-in-out both; animation-delay: 0s;">‚óè</span>
                        <span style="animation: loading-dot 1.4s infinite ease-in-out both; animation-delay: 0.2s;">‚óè</span>
                        <span style="animation: loading-dot 1.4s infinite ease-in-out both; animation-delay: 0.4s;">‚óè</span>
                    </div>
                </div>
                <style>
                    @keyframes loading-dot {
                        0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
                        40% { transform: scale(1); opacity: 1; }
                    }
                </style>
            `;
            
            const progressElement = document.getElementById('loadingProgress');
            
            try {
                // Extract the actual playlist ID (remove 'podcast_' prefix)
                const actualPlaylistId = podcastPlaylistId.replace('podcast_', '');
                
                // üî• API FIX: Use correct endpoint for podcast playlists
                const response = await fetch(`/api/podcast-playlists/${actualPlaylistId}`, {
                    headers: {
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch podcast playlist: ${response.status}`);
                }
                
                const data = await response.json();
                const episodes = data.playlist?.episodes || data.episodes || [];
                
                console.log(`üéôÔ∏è Loaded ${episodes.length} podcast episodes`);
                
                // Hide loading indicator
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                
                if (episodes.length === 0) {
                    if (noEpisodes) {
                        noEpisodes.style.display = 'block';
                        noEpisodes.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                                <div style="font-size: 3em; margin-bottom: 16px;">üéôÔ∏è</div>
                                <h3 style="margin: 0 0 12px 0; color: var(--text);">„Åì„ÅÆ„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„Éó„É¨„Ç§„É™„Çπ„Éà„ÅØÁ©∫„Åß„Åô</h3>
                                <p style="margin: 0;">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„ÇíÊ§úÁ¥¢„Åó„Å¶„Ç®„Éî„ÇΩ„Éº„Éâ„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
                            </div>
                        `;
                    }
                    return;
                }
                
                // ‚ö° PERFORMANCE OPTIMIZATION: Process episodes in parallel instead of sequential
                console.log('‚ö° Starting parallel episode processing to reduce loading time...');
                const startTime = performance.now();
                
                // üìä Progress tracking for user feedback
                let processedCount = 0;
                const totalCount = episodes.length;
                const progressElement = document.getElementById('loadingProgress');
                
                // üöÄ ULTRA-FAST Helper function with timeout and aggressive caching
                async function processEpisode(episode) {
                    const episodeId = episode.id || episode;
                    
                    if (typeof episode === 'string' || (episode.id && !episode.title)) {
                        // ‚ö° SPEED OPTIMIZATION: Add timeout control for API calls
                        console.log(`üîç Fast-fetching details for episode ID: ${episodeId}`);
                        
                        try {
                            // Create AbortController for timeout control
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 3000); // 3-second timeout
                            
                            // Use podcast search API to get episode details with timeout
                            const searchResponse = await fetch(`/api/podcasts/search?episode_id=${episodeId}`, {
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            if (searchResponse.ok) {
                                const searchData = await searchResponse.json();
                                if (searchData.episodes && searchData.episodes.length > 0) {
                                    const fullEpisode = searchData.episodes.find(ep => ep.id === episodeId) || searchData.episodes[0];
                                    const episodeData = { 
                                        ...fullEpisode,
                                        id: episodeId,
                                        added_at: episode.added_at || new Date().toISOString()
                                    };
                                    console.log(`‚ö° Fast-fetched episode details in <3s:`, episodeData.title);
                                    return episodeData;
                                } else {
                                    console.warn(`‚ö†Ô∏è No episode details found for ${episodeId}, using fast fallback`);
                                    return createFallbackEpisodeData(episodeId, episode.added_at);
                                }
                            } else {
                                console.warn(`‚ö†Ô∏è Search API failed for episode ${episodeId} (${searchResponse.status}), using fast fallback`);
                                return createFallbackEpisodeData(episodeId, episode.added_at);
                            }
                        } catch (error) {
                            if (error.name === 'AbortError') {
                                console.warn(`‚è∞ Episode ${episodeId} fetch timed out after 3s, trying fallback with extended search...`);
                            } else {
                                console.warn(`‚ö†Ô∏è Error fetching episode ${episodeId}:`, error.message);
                            }
                            
                            // üî• CRITICAL FIX: Try extended search for full episode data in fallback
                            try {
                                console.log(`üîç Trying extended search for episode ${episodeId}...`);
                                const fallbackSearchResponse = await fetch(`/api/podcasts/search?episode_id=${episodeId}`, {
                                    headers: {
                                        'Content-Type': 'application/json'
                                    }
                                    // No timeout for fallback search
                                });
                                
                                if (fallbackSearchResponse.ok) {
                                    const fallbackSearchData = await fallbackSearchResponse.json();
                                    if (fallbackSearchData.episodes && fallbackSearchData.episodes.length > 0) {
                                        const fallbackEpisode = fallbackSearchData.episodes.find(ep => ep.id === episodeId) || fallbackSearchData.episodes[0];
                                        const fallbackEpisodeData = { 
                                            ...fallbackEpisode,
                                            id: episodeId,
                                            added_at: episode.added_at || new Date().toISOString()
                                        };
                                        console.log(`‚úÖ Extended search successful for ${episodeId}:`, fallbackEpisodeData.title);
                                        console.log(`üéµ Audio URL found: ${fallbackEpisodeData.audio_url ? 'YES' : 'NO'}`);
                                        return fallbackEpisodeData;
                                    }
                                }
                            } catch (fallbackError) {
                                console.warn(`‚ö†Ô∏è Fallback search also failed for ${episodeId}:`, fallbackError.message);
                            }
                            
                            return createFallbackEpisodeData(episodeId, episode.added_at);
                        }
                    } else if (episode.id && episode.title) {
                        // If episode already has full details
                        console.log(`‚ö° Episode already has full details: ${episode.title}`);
                        return episode;
                    } else {
                        // Fallback for unexpected data structure
                        console.log(`‚ö° Using fast fallback for episode: ${episodeId}`);
                        return createFallbackEpisodeData(episodeId, episode.added_at);
                    }
                }
                
                // üìä Wrapper function to track progress
                async function processEpisodeWithProgress(episode) {
                    const result = await processEpisode(episode);
                    processedCount++;
                    if (progressElement) {
                        progressElement.textContent = `„Ç®„Éî„ÇΩ„Éº„ÉâË©≥Á¥∞„ÇíÂèñÂæó‰∏≠... (${processedCount}/${totalCount})`;
                    }
                    return result;
                }
                
                // üöÄ Process all episodes in parallel using Promise.all with error handling
                let enrichedEpisodes = [];
                try {
                    console.log(`üöÄ Starting Promise.all for ${episodes.length} episodes...`);
                    enrichedEpisodes = await Promise.all(episodes.map(processEpisodeWithProgress));
                    console.log(`‚úÖ Promise.all completed successfully with ${enrichedEpisodes.length} episodes`);
                } catch (promiseError) {
                    console.error('üî• Promise.all failed, processing episodes individually:', promiseError);
                    
                    // Fallback: Process episodes one by one to avoid total failure
                    enrichedEpisodes = [];
                    processedCount = 0; // Reset counter for individual processing
                    for (let i = 0; i < episodes.length; i++) {
                        try {
                            console.log(`üîÑ Processing episode ${i + 1}/${episodes.length} individually...`);
                            if (progressElement) {
                                progressElement.textContent = `„Ç®„Éî„ÇΩ„Éº„ÉâË©≥Á¥∞„ÇíÂèñÂæó‰∏≠... (${i + 1}/${totalCount})`;
                            }
                            const processedEpisode = await processEpisode(episodes[i]);
                            enrichedEpisodes.push(processedEpisode);
                        } catch (singleEpisodeError) {
                            console.error(`‚ùå Failed to process episode ${i + 1}:`, singleEpisodeError);
                            // Add fallback episode data
                            const episodeId = episodes[i].id || episodes[i];
                            enrichedEpisodes.push(createFallbackEpisodeData(episodeId, episodes[i].added_at));
                        }
                        processedCount = i + 1;
                    }
                }
                
                const endTime = performance.now();
                const processingTimeMs = endTime - startTime;
                console.log(`‚ö° Episode processing completed in ${processingTimeMs.toFixed(2)}ms (${(processingTimeMs/1000).toFixed(2)} seconds)`);
                console.log(`‚ö° Final result: ${enrichedEpisodes.length} episodes processed`);
                
                // üìä Final progress update
                if (progressElement) {
                    progressElement.textContent = `„Ç®„Éî„ÇΩ„Éº„Éâ‰∏ÄË¶ß„ÇíË°®Á§∫‰∏≠... (${enrichedEpisodes.length}‰ª∂ÂÆå‰∫Ü)`;
                }
                
                // Helper function to create fallback episode data
                function createFallbackEpisodeData(episodeId, addedAt) {
                    const parts = episodeId.split('_');
                    let podcastName = 'Unknown Podcast';
                    let episodeTitle = `Episode ${parts[parts.length - 1]}`;
                    
                    if (parts.length >= 2) {
                        // Extract podcast name from ID
                        podcastName = parts.slice(0, -1).join(' ')
                            .replace(/_/g, ' ')
                            .split(' ')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');
                        episodeTitle = `Episode (ID: ${parts[parts.length - 1]})`;
                    }
                    
                    return {
                        id: episodeId,
                        title: episodeTitle,
                        podcast_name: podcastName,
                        added_at: addedAt || new Date().toISOString(),
                        description: 'Episode details are being loaded...'
                    };
                }
                
                console.log(`üéôÔ∏è Enriched ${enrichedEpisodes.length} episodes with full details`);
                
                // Display episodes
                let html = '';
                console.log('üîç Starting HTML generation for enrichedEpisodes:', enrichedEpisodes.length);
                enrichedEpisodes.forEach((episode, index) => {
                    console.log(`üîç Processing episode ${index + 1}:`, episode);
                    const episodeId = episode.id;
                    const addedAt = episode.added_at;
                    console.log(`üîç Episode ID: ${episodeId}, Added At: ${addedAt}`);
                    
                    // Extract podcast name from ID if not available in episode data
                    let podcastName = episode.podcast_name;
                    if (!podcastName && episodeId) {
                        const parts = episodeId.split('_');
                        if (parts.length >= 2) {
                            // Convert snake_case to readable format
                            podcastName = parts.slice(0, -1).join(' ').replace(/_/g, ' ')
                                .split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
                        }
                    }
                    
                    // Use episode data or fallback to extracted info
                    const displayTitle = episode.title || `„Ç®„Éî„ÇΩ„Éº„Éâ (${episodeId?.split('_').pop() || index + 1})`;
                    const displayPodcastName = podcastName || episode.podcast_name || 'Unknown Podcast';
                    const displayDate = addedAt ? new Date(addedAt).toLocaleDateString('ja-JP') : 
                                      episode.published_date ? new Date(episode.published_date).toLocaleDateString('ja-JP') : '';
                    
                    html += `
                        <div class="podcast-episode-item episode-item" data-episode-id="${episodeId || ''}" style="margin-bottom: 16px; padding: 16px; border: 1px solid rgba(159, 247, 234, 0.3); border-radius: 12px; background: rgba(159, 247, 234, 0.05);">
                            <div class="episode-header" style="display: flex; gap: 12px; align-items: start;">
                                ${episode.artwork ? `
                                    <img src="${episode.artwork}" alt="${displayTitle}" style="width: 80px; height: 80px; object-fit: cover; border-radius: 8px;">
                                ` : `
                                    <div style="width: 80px; height: 80px; background: rgba(159, 247, 234, 0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 2em;">
                                        üéôÔ∏è
                                    </div>
                                `}
                                <div style="flex: 1;">
                                    <h3 style="margin: 0 0 8px 0; font-size: 1.1em; color: var(--text);">${displayTitle}</h3>
                                    <p style="margin: 0 0 4px 0; font-size: 0.9em; color: var(--accent-color);">${displayPodcastName}</p>
                                    <p style="margin: 0; font-size: 0.85em; color: var(--text-muted);">
                                        ${displayDate}
                                        ${addedAt ? ' („Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†)' : ''}
                                        ${episode.duration ? ` ‚Ä¢ ${Math.floor(episode.duration / 60)}ÂàÜ` : ''}
                                    </p>
                                </div>
                            </div>
                            ${episode.description ? `
                                <p style="margin: 12px 0 0 0; font-size: 0.9em; color: var(--text-muted); line-height: 1.5;">
                                    ${episode.description.substring(0, 200)}${episode.description.length > 200 ? '...' : ''}
                                </p>
                            ` : ''}
                            <div class="episode-actions" style="margin-top: 12px; display: flex; gap: 8px;">
                                <button class="auth-button small play-button" onclick="playEpisode('${episodeId}', '${displayTitle.replace(/'/g, "\\'")}', '${displayPodcastName.replace(/'/g, "\\'")}')">
                                    ‚ñ∂Ô∏è ÂÜçÁîü
                                </button>
                                <button class="auth-button small secondary" onclick="removePodcastFromPlaylist('${actualPlaylistId}', '${episodeId}')">
                                    üóëÔ∏è ÂâäÈô§
                                </button>
                            </div>
                        </div>
                    `;
                    console.log(`üîç Generated HTML for episode ${index + 1}, current html length:`, html.length);
                });
                
                console.log('üîç Final HTML length:', html.length);
                console.log('üîç First 500 characters of HTML:', html.substring(0, 500));
                container.innerHTML = html;
                console.log('üîç Container innerHTML after assignment:', container.innerHTML.length);
                
            } catch (error) {
                console.error('Failed to load podcast playlist content:', error);
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                if (noEpisodes) {
                    noEpisodes.style.display = 'block';
                    noEpisodes.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: var(--error-color);">
                            <div style="font-size: 2em; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <h3 style="margin: 0 0 12px 0;">Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº</h3>
                            <p style="margin: 0;">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ</p>
                        </div>
                    `;
                }
            }
        }

        // Remove podcast episode from playlist
        window.removePodcastFromPlaylist = async function(playlistId, episodeId) {
            // üîß Enhanced debugging and error handling
            console.log('üîß DEBUG: removePodcastFromPlaylist called', {
                playlistId,
                episodeId,
                currentUser: currentUser ? 'authenticated' : 'null',
                userEmail: currentUser?.email
            });

            if (!currentUser) {
                console.error('üö´ ERROR: User not authenticated');
                showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà„Åã„ÇâÂâäÈô§„Åô„Çã„Å´„ÅØ„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'warning');
                return;
            }

            console.log('üîî DEBUG: Showing custom confirmation dialog...');
            const confirmResult = await showCustomConfirmDialog('„Åì„ÅÆ„Ç®„Éî„ÇΩ„Éº„Éâ„Çí„Éó„É¨„Ç§„É™„Çπ„Éà„Åã„ÇâÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü');
            console.log('üîî DEBUG: Custom confirmation result:', confirmResult);

            if (!confirmResult) {
                console.log('üîî DEBUG: User cancelled deletion');
                return;
            }

            try {
                console.log(`üóëÔ∏è Removing episode ${episodeId} from playlist ${playlistId}`);
                showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà„Åã„ÇâÂâäÈô§‰∏≠...', 'info');

                console.log('üîß DEBUG: Getting ID token...');
                const token = await firebaseAuth.getIdToken();
                console.log('üîß DEBUG: Token obtained, making DELETE request...');
                
                const deleteUrl = `/api/podcast-playlists/${playlistId}/episodes/${episodeId}`;
                console.log('üîß DEBUG: DELETE URL:', deleteUrl);
                
                const response = await fetch(deleteUrl, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                console.log('üîß DEBUG: Response status:', response.status, response.statusText);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('üö´ ERROR: Delete request failed:', errorData);
                    throw new Error(errorData.error || `ÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü (${response.status})`);
                }

                showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà„Åã„ÇâÂâäÈô§„Åó„Åæ„Åó„Åü', 'success');
                console.log(`‚úÖ Successfully removed episode ${episodeId} from playlist ${playlistId}`);

                // üöÄ FAST METHOD: Remove episode element directly from DOM (no reload)
                console.log('üîß DEBUG: Using fast DOM removal method...');
                const episodeElement = document.querySelector(`[data-episode-id="${episodeId}"]`);
                if (episodeElement) {
                    episodeElement.remove();
                    console.log(`üîß DEBUG: Removed episode element for ${episodeId}`);
                    
                    // Update the episode count display
                    console.log('üîß DEBUG: Updating episode count display...');
                    const countElement = document.getElementById('searchResultsCount');
                    const episodesList = document.getElementById('episodesList');
                    if (countElement && episodesList) {
                        const episodeItems = episodesList.querySelectorAll('.episode-item');
                        const newCount = episodeItems.length;
                        countElement.textContent = `${newCount}„Ç®„Éî„ÇΩ„Éº„Éâ`;
                        console.log(`üîß DEBUG: Updated episode count display to ${newCount} episodes`);
                    } else {
                        console.log('üîß DEBUG: Could not find count element or episodes list for update');
                    }
                } else {
                    console.log(`üîß DEBUG: Could not find episode element for ${episodeId}, falling back to safe reload method`);
                    
                    // üõ°Ô∏è FALLBACK: Safe method with full reload (backup implementation)
                    console.log('üîß DEBUG: Using safe reload fallback method...');
                    await window.loadPodcastPlaylistContent(playlistId);
                    
                    // Update the episode count display after reload
                    console.log('üîß DEBUG: Updating episode count display after reload...');
                    const countElement = document.getElementById('searchResultsCount');
                    const episodesList = document.getElementById('episodesList');
                    if (countElement && episodesList) {
                        const episodeItems = episodesList.querySelectorAll('.episode-item');
                        const newCount = episodeItems.length;
                        countElement.textContent = `${newCount}„Ç®„Éî„ÇΩ„Éº„Éâ`;
                        console.log(`üîß DEBUG: Updated episode count display to ${newCount} episodes (fallback)`);
                    }
                }

            } catch (error) {
                console.error('üö´ ERROR: Failed to remove episode from playlist:', error);
                console.error('üö´ ERROR: Error stack:', error.stack);
                showMessage(`„Éó„É¨„Ç§„É™„Çπ„Éà„Åã„Çâ„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error.message}`, 'error');
            }
        }

        // Update playlist selector options
        function updatePlaylistSelector() {
            const selector = document.getElementById('playlistSelector');
            if (!selector) return;
            
            // Clear existing options except "All"
            selector.innerHTML = '<option value="all">„Åô„Åπ„Å¶„ÅÆ„Éó„É¨„Ç§„É™„Çπ„Éà</option>';
            
            // Add playlist options
            if (currentUser && currentPlaylists.length > 0) {
                currentPlaylists.forEach(playlist => {
                    const option = document.createElement('option');
                    option.value = playlist.playlistId;
                    option.textContent = playlist.name;
                    selector.appendChild(option);
                });
            }
            
            // Restore selected value
            selector.value = window.selectedPlaylistId;
            
            // üîß FIX: Remove all existing event listeners and add fresh one
            // Clone element to remove all event listeners
            const newSelector = selector.cloneNode(true);
            selector.parentNode.replaceChild(newSelector, selector);
            
            // Restore selected value on the cloned selector
            newSelector.value = window.selectedPlaylistId;
            
            // Add event listener with proper binding
            newSelector.addEventListener('change', handlePlaylistSelection, {
                passive: false,
                once: false,
                capture: false
            });
            
            // üîß FIX: Also bind to 'input' event for broader compatibility
            newSelector.addEventListener('input', handlePlaylistSelection, {
                passive: false,
                once: false,
                capture: false
            });
            
            // Test the event handler attachment with a synthetic event
            const testEvent = new Event('change', { bubbles: true });
            newSelector.dispatchEvent(testEvent);
            
            console.log('‚úÖ Playlist selector updated with fresh event handlers');
            console.log(`üîç New selector ID: ${newSelector.id}, value: ${newSelector.value}`);
            console.log(`üîç selectedPlaylistId: ${window.selectedPlaylistId}`);
        }

        // üî• PLAYLIST FIX: Make updatePlaylistSelector globally accessible for playlist management
        window.updatePlaylistSelector = updatePlaylistSelector;
        
        // üî• PLAYLIST FIX: Make handlePlaylistSelection globally accessible for playlist switching
        window.handlePlaylistSelection = handlePlaylistSelection;

        window.closePlaylistManager = function() {
            // console.log(' Closing playlist manager...');
            document.getElementById('playlistModal').style.display = 'none';
        };

        window.createNewPlaylist = function() {
            document.getElementById('createPlaylistModal').style.display = 'flex';
            // Reset form
            document.getElementById('playlistName').value = '';
            document.getElementById('playlistDescription').value = '';
            document.getElementById('selectedEmoji').value = '';
            // Reset emoji selector
            document.querySelectorAll('.emoji-option').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.emoji-option[data-emoji=""]').classList.add('active');
            selectedPlaylistEmoji = '';
        }

        // Make function globally accessible
        window.openCreatePlaylist = function() {
            // console.log(' Opening create playlist modal...');
            const modal = document.getElementById('createPlaylistModal');
            const form = document.getElementById('createPlaylistForm');
            
            if (!modal) {
                console.error(' Create playlist modal not found!');
                showMessage('', 'error');
                return;
            }
            
            if (!form) {
                console.error(' Create playlist form not found!');
                showMessage('', 'error');
                return;
            }
            
            // console.log(' Modal and form found, displaying modal...');
            modal.style.display = 'flex';
            
            // Clear the form
            form.reset();
            
            // Reset emoji selection
            document.querySelectorAll('.emoji-option').forEach(option => {
                option.classList.remove('active');
            });
            const defaultEmoji = document.querySelector('.emoji-option[data-emoji=""]');
            if (defaultEmoji) {
                defaultEmoji.classList.add('active');
                selectedPlaylistEmoji = '';
            }
            
            // console.log(' Create playlist modal opened successfully');
            showMessage('', 'info');
        };

        window.closeCreatePlaylist = function() {
            // console.log(' Closing create playlist modal...');
            const modal = document.getElementById('createPlaylistModal');
            if (modal) {
                modal.style.display = 'none';
                // console.log(' Create playlist modal closed');
            }
        };

        // Setup emoji selector event listeners
        function setupEmojiSelector() {
            document.querySelectorAll('.emoji-option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    // Remove active from all
                    document.querySelectorAll('.emoji-option').forEach(b => b.classList.remove('active'));
                    // Add active to clicked
                    btn.classList.add('active');
                    selectedPlaylistEmoji = btn.dataset.emoji;
                    document.getElementById('selectedEmoji').value = selectedPlaylistEmoji;
                });
            });
        }

        window.submitCreatePlaylist = async function(event) {
            event.preventDefault();
            // console.log(' Submitting create playlist form...');
            
            const name = document.getElementById('playlistName').value.trim();
            const description = document.getElementById('playlistDescription').value.trim();
            const emoji = selectedPlaylistEmoji;
            const isPrivate = document.getElementById('playlistIsPrivate').checked;
            
            // console.log(' Playlist data:', { name, description, emoji, isPrivate });
            
            if (!name) {
                showMessage('', 'error');
                return;
            }
            
            if (!currentUser) {
                showMessage('', 'error');
                return;
            }
            
            try {
                showMessage('...', 'warning');
                // console.log(' Sending API request...');
                
                const playlistData = {
                    name: name,
                    description: description || null,
                    emoji: emoji,
                    isPrivate: isPrivate,
                    tracks: [],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                
                // Create playlist via API
                const response = await apiClient.request('/api/playlists', {
                    method: 'POST',
                    body: JSON.stringify(playlistData)
                });
                
                // console.log(' Playlist created:', response);
                showMessage(' ', 'success');
                closeCreatePlaylist();
                loadUserPlaylists(); // Refresh playlist list
                
            } catch (error) {
                console.error(' Failed to create playlist:', error);
                showMessage(': ' + error.message, 'error');
            }
        };

        async function loadUserPlaylists() {
            // console.log(' Loading user playlists...');
            // console.log(' Current user:', currentUser);
            
            if (!currentUser) {
                // console.log(' No authenticated user, skipping playlist load');
                document.getElementById('playlistList').innerHTML = '<p class="empty-state"></p>';
                updatePlaylistSelector(); // Clear selector when not authenticated
                return;
            }
            
            try {
                // console.log(' Fetching playlists from API...');
                const response = await apiClient.request('/api/playlists', {
                    method: 'GET'
                });
                
                // console.log(' API response received:', response);
                
                currentPlaylists = response.playlists || [];
                // console.log(' Loaded playlists count:', currentPlaylists.length);
                
                renderPlaylistList(currentPlaylists);
                updatePlaylistSelector(); // Update selector with new playlists
                
                // console.log(' Playlists loaded successfully');
                
            } catch (error) {
                console.error(' Failed to load playlists:', error);
                console.error('Error details:', {
                    message: error.message,
                    status: error.status,
                    response: error.response
                });
                
                document.getElementById('playlistList').innerHTML = '<p class="empty-state"></p>';
                updatePlaylistSelector(); // Clear selector on error
                
                // Show user-friendly error message
                if (error.status === 401) {
                    showMessage('', 'error');
                } else if (error.status === 503) {
                    showMessage('', 'error');
                } else {
                    showMessage('', 'error');
                }
            }
        }

        function renderPlaylistList(playlists) {
            const container = document.getElementById('playlistList');
            
            if (!playlists || playlists.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <p></p>
                        <p class="empty-subtitle"></p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = playlists.map(playlist => `
                <div class="playlist-item" data-playlist-id="${playlist.playlistId}">
                    <div class="playlist-info">
                        <div class="playlist-emoji">${playlist.emoji || ''}</div>
                        <div class="playlist-details">
                            <h3 class="playlist-name">${escapeHtml(playlist.name)}</h3>
                            <p class="playlist-description">${escapeHtml(playlist.description || '')}</p>
                            <div class="playlist-meta">
                                <span class="track-count">${playlist.tracks ? playlist.tracks.length : 0} „Éà„É©„ÉÉ„ÇØ</span>
                                <span class="created-date">${formatDate(playlist.createdAt)}</span>
                            </div>
                        </div>
                    </div>
                    <div class="playlist-actions">
                        <button class="action-btn playlist-open-btn" onclick="window.openPlaylist('${playlist.playlistId}')" title="„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÈñã„Åè">
                            Èñã„Åè
                        </button>
                        <button class="action-btn playlist-edit-btn" onclick="window.editPlaylist('${playlist.playlistId}')" title="„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÁ∑®ÈõÜ">
                            Á∑®ÈõÜ
                        </button>
                        <button class="action-btn playlist-delete-btn danger" onclick="window.deletePlaylist('${playlist.playlistId}')" title="„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÂâäÈô§">
                            ÂâäÈô§
                        </button>
                    </div>
                </div>
            `).join('');
        }

        window.deletePlaylist = async function(playlistId) {
            // Get playlist name for display
            const playlist = currentPlaylists.find(p => p.playlistId === playlistId);
            const playlistName = playlist ? playlist.name : '';
            
            // Check if we should skip confirmation
            if (confirmationPreferences.skipDeleteConfirmation) {
                // console.log(' Skipping playlist delete confirmation (user preference)');
                await performPlaylistDeletion(playlistId);
                return;
            }
            
            // Show custom confirmation modal
            showConfirmationModal({
                title: '„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÂâäÈô§',
                message: `"${playlistName}" „ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`,
                warningMessage: '„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ',
                confirmText: 'ÂâäÈô§',
                cancelText: '„Ç≠„É£„É≥„Çª„É´',
                skipOption: true,
                skipKey: 'skipDeleteConfirmation',
                onConfirm: async () => {
                    await performPlaylistDeletion(playlistId);
                }
            });
        }
        
        async function performPlaylistDeletion(playlistId) {
            try {
                await apiClient.request(`/api/playlists/${playlistId}`, {
                    method: 'DELETE'
                });
                
                showMessage(' ', 'success');
                loadUserPlaylists(); // Refresh list
                
            } catch (error) {
                console.error('Failed to delete playlist:', error);
                showMessage(': ' + error.message, 'error');
            }
        }

        window.openPlaylist = async function(playlistId) {
            try {
                // Set the selected playlist
                selectedPlaylistId = playlistId;
                
                // Update the playlist selector
                const selector = document.getElementById('playlistSelector');
                if (selector) {
                    selector.value = playlistId;
                }
                
                // Get playlist info for success message
                const playlist = currentPlaylists.find(p => p.playlistId === playlistId);
                
                // Close the playlist manager
                window.closePlaylistManager();
                
                // Reload the library view with the selected playlist
                await loadEpisodes();
                
                // Scroll to library section
                const librarySection = document.querySelector('.section h2');
                if (librarySection) {
                    librarySection.scrollIntoView({ behavior: 'smooth' });
                }
                
                showMessage(` "${playlist?.name || ''}"`, 'success');
                
            } catch (error) {
                console.error('Failed to open playlist:', error);
                showMessage('', 'error');
            }
        }

        window.editPlaylist = function(playlistId) {
            // TODO: Implement playlist editing
            showMessage('', 'info');
        }

        // escapeHtml function already exists above, using that one

        // üî• PLAYLIST FIX: Make playlist variables globally accessible
        window.selectedTrackIdForPlaylist = null;
        window.selectedPlaylistForAdding = null;

        async function addToPlaylist(trackId) {
            // console.log(' Add to playlist called:', { trackId, user: currentUser?.uid });
            
            // Close menu
            const menu = document.getElementById(`menu-${trackId}`);
            if (menu) {
                menu.classList.remove('active');
            }
            
            if (!currentUser) {
                showMessage('', 'error');
                return;
            }
            
            // Store the selected track ID and reset playlist selection
            window.selectedTrackIdForPlaylist = trackId;
            window.selectedPlaylistForAdding = null;
            
            // Get the track details for display
            const track = episodes.find(ep => ep.trackId === trackId);
            if (track) {
                document.getElementById('selectedTrackTitle').textContent = track.title;
            }
            
            // Load and show playlists in modal
            await loadPlaylistsForAddingTrack();
            
            // Show the add to playlist modal
            const modal = document.getElementById('addToPlaylistModal');
            modal.style.display = 'flex';
            
            // Reset selection state when opening modal
            window.selectedPlaylistForAdding = null;
            
            // Initialize add button state (should be disabled initially)
            updateAddToPlaylistButton();
        }

        async function loadPlaylistsForAddingTrack() {
            const playlistList = document.getElementById('playlistListForAdding');
            
            try {
                // console.log(' Loading playlists for adding track...');
                // console.log(' Current playlists available:', currentPlaylists ? currentPlaylists.length : 'null');
                playlistList.innerHTML = '<div class="loading-item">...</div>';
                
                // Try to load playlists from API if currentPlaylists is empty
                let playlists = currentPlaylists && currentPlaylists.length > 0 
                    ? currentPlaylists 
                    : [];
                
                if (playlists.length === 0) {
                    // console.log(' No cached playlists, fetching from API...');
                    try {
                        const response = await apiClient.request('/api/playlists');
                        playlists = response.playlists || [];
                        currentPlaylists = playlists; // Cache for future use
                        // console.log(' Loaded playlists from API:', playlists.length);
                    } catch (error) {
                        console.error(' Failed to load playlists from API:', error);
                        playlists = [];
                    }
                }
                
                if (playlists.length === 0) {
                    playlistList.innerHTML = `
                        <div class="empty-playlists" style="text-align: center; padding: 30px; background: var(--panel); border-radius: 10px;">
                            <div style="font-size: 48px; margin-bottom: 15px;"></div>
                            <h3 style="color: var(--accent); margin: 0 0 10px 0;"></h3>
                            <p style="margin: 0 0 20px 0; opacity: 0.8;"></p>
                            <button onclick="createFirstPlaylist();" class="auth-button" style="background: var(--accent);">
                                
                            </button>
                        </div>
                    `;
                    return;
                }
                
                // Render playlist options
                playlistList.innerHTML = playlists.map(playlist => {
                    const isSelected = window.selectedPlaylistForAdding === playlist.playlistId;
                    return `
                    <div class="playlist-option ${isSelected ? 'selected' : ''}" 
                         onclick="window.selectPlaylistForAdding('${playlist.playlistId}', '${playlist.name.replace(/'/g, "\\'")}')"
                         style="display: flex; justify-content: space-between; align-items: center; padding: 15px; margin: 10px 0; background: ${isSelected ? '#2d4a6b' : '#1a1a2e'}; border: 2px solid ${isSelected ? '#4fc3f7' : 'rgba(159, 247, 234, 0.3)'}; border-radius: 10px; cursor: pointer; transition: all 0.3s ease;">
                        <div class="playlist-option-info">
                            <h4 style="margin: 0; color: #ffffff; font-size: 1.1em;">${escapeHtml(playlist.name)}</h4>
                        </div>
                        <div class="playlist-option-selection">
                            <div class="selection-indicator ${isSelected ? 'active' : ''}" 
                                 style="width: 24px; height: 24px; border-radius: 50%; border: 2px solid ${isSelected ? '#4fc3f7' : 'rgba(159, 247, 234, 0.5)'}; display: flex; align-items: center; justify-content: center; font-weight: bold; background: ${isSelected ? '#4fc3f7' : 'transparent'}; color: ${isSelected ? '#000000' : '#9ff7ea'};">${isSelected ? '' : ''}</div>
                        </div>
                    </div>
                    `;
                }).join('');
                
                // Update add button state only if no playlist is currently selected
                // (Don't reset the selection when re-rendering)
                if (!window.selectedPlaylistForAdding) {
                    updateAddToPlaylistButton();
                }
                
            } catch (error) {
                console.error(' Failed to load playlists for adding:', error);
                playlistList.innerHTML = `
                    <div class="error-item">
                        <p></p>
                        <button onclick="loadPlaylistsForAddingTrack()" class="retry-btn">ÂÜçË©¶Ë°å</button>
                    </div>
                `;
            }
        }

        // Make selectPlaylistForAdding globally accessible
        window.selectPlaylistForAdding = function(playlistId, playlistName) {
            // console.log(' Playlist selected:', { playlistId, playlistName });
            // console.log(' Before selection - selectedPlaylistForAdding:', selectedPlaylistForAdding);
            
            window.selectedPlaylistForAdding = playlistId;
            // console.log(' After selection - selectedPlaylistForAdding:', selectedPlaylistForAdding);
            
            // Update visual selection immediately without re-rendering
            document.querySelectorAll('.playlist-option').forEach(option => {
                option.style.borderColor = 'rgba(159, 247, 234, 0.3)';
                option.style.background = '#1a1a2e';
                option.classList.remove('selected');
                
                const indicator = option.querySelector('.selection-indicator');
                if (indicator) {
                    indicator.style.background = 'transparent';
                    indicator.style.borderColor = 'rgba(159, 247, 234, 0.5)';
                    indicator.style.color = '#9ff7ea';
                    indicator.textContent = ''; // Remove checkmark
                    indicator.classList.remove('active');
                }
            });
            
            // Apply selected styles to the clicked option
            const selectedOption = document.querySelector(`[onclick*="${playlistId}"]`);
            if (selectedOption) {
                selectedOption.style.borderColor = '#4fc3f7';
                selectedOption.style.background = '#2d4a6b';
                selectedOption.classList.add('selected');
                
                const indicator = selectedOption.querySelector('.selection-indicator');
                if (indicator) {
                    indicator.style.background = '#4fc3f7';
                    indicator.style.borderColor = '#4fc3f7';
                    indicator.style.color = '#000000';
                    indicator.textContent = ''; // Add checkmark only to selected
                    indicator.classList.add('active');
                }
                
                // console.log(' Visual selection updated for playlist:', playlistName);
            }
            
            // Update add button state immediately
            const addButton = document.getElementById('confirmAddToPlaylistBtn');
            if (addButton) {
                addButton.disabled = false;
                addButton.classList.remove('disabled');
                addButton.style.opacity = '1';
                addButton.style.cursor = 'pointer';
                addButton.style.background = 'linear-gradient(45deg, #667eea 0%, #764ba2 100%)';
                addButton.textContent = 'ËøΩÂä†';
                // console.log(' Add button enabled');
            }
        }

        function updateAddToPlaylistButton() {
            // console.log(' Updating add button state:', { selectedPlaylistForAdding });
            
            const addButton = document.getElementById('confirmAddToPlaylistBtn');
            // console.log(' Add button element:', addButton ? 'Found' : 'Not found');
            
            if (addButton) {
                if (window.selectedPlaylistForAdding) {
                    // console.log(' Enabling add button');
                    addButton.disabled = false;
                    addButton.classList.remove('disabled');
                    addButton.style.opacity = '1';
                    addButton.style.cursor = 'pointer';
                    addButton.style.background = 'linear-gradient(45deg, #667eea 0%, #764ba2 100%)';
                    addButton.textContent = 'ËøΩÂä†';
                } else {
                    // console.log(' Disabling add button');
                    addButton.disabled = true;
                    addButton.classList.add('disabled');
                    addButton.style.opacity = '0.5';
                    addButton.style.cursor = 'not-allowed';
                    addButton.style.background = '#333';
                    addButton.textContent = 'ËøΩÂä†';
                }
            } else {
                console.error(' Add button not found in DOM');
            }
        }

        // Make confirmAddToPlaylist globally accessible
        window.confirmAddToPlaylist = async function() {
            try {
                // console.log(' confirmAddToPlaylist called - Adding track to playlist:', { 
                //     trackId: selectedTrackIdForPlaylist, 
                //     playlistId: selectedPlaylistForAdding
                // });
                
                if (!window.selectedTrackIdForPlaylist || !window.selectedPlaylistForAdding) {
                    console.error(' Missing required data:', { 
                        trackId: window.selectedTrackIdForPlaylist, 
                        playlistId: window.selectedPlaylistForAdding 
                    });
                    showMessage('', 'error');
                    return;
                }
                
                // Disable button to prevent double-clicks
                const addButton = document.getElementById('confirmAddToPlaylistBtn');
                if (addButton) {
                    addButton.disabled = true;
                    addButton.textContent = '...';
                }
                
                // Get playlist name for success message - with safe fallback
                let playlistName = '';
                try {
                    const selectedOption = document.querySelector(`[onclick*="${window.selectedPlaylistForAdding}"]`);
                    if (selectedOption) {
                        const h4Element = selectedOption.querySelector('.playlist-option-info h4') || 
                                         selectedOption.querySelector('h4');
                        if (h4Element && h4Element.textContent) {
                            playlistName = h4Element.textContent.trim();
                        }
                    }
                } catch (nameError) {
                    // console.warn(' Could not get playlist name:', nameError);
                }
            
            try {
                showMessage('...', 'info');
                
                // console.log(' Making API request to add track to playlist:', {
                //     url: `/api/playlists/${selectedPlaylistForAdding}/tracks`,
                //     method: 'POST',
                //     body: { trackId: selectedTrackIdForPlaylist }
                // });
                
                const response = await apiClient.request(`/api/playlists/${window.selectedPlaylistForAdding}/tracks`, {
                    method: 'POST',
                    body: JSON.stringify({
                        trackId: window.selectedTrackIdForPlaylist
                    })
                });
                
                // console.log(' Track added to playlist successfully:', response);
                showMessage(`"${playlistName}"`, 'success');
                
                // Close modal automatically after success
                // console.log(' Closing modal after successful addition');
                closeAddToPlaylistModal();
                
                // Refresh playlists if needed
                // console.log(' Refreshing playlists...');
                await loadUserPlaylists();
                
            } catch (error) {
                console.error(' Failed to add track to playlist:', error);
                // console.log(' Error message analysis:', error.message);
                
                let errorMessage = '';
                let messageType = 'error';
                let shouldCloseModal = false;
                
                if (error.message && (error.message.includes('already exists') || error.message.includes('already in the playlist'))) {
                    // console.log(' Detected duplicate track error - treating as info');
                    errorMessage = ` "${playlistName}"`;
                    messageType = 'info';
                    shouldCloseModal = true; // Already in playlist is not really an error, close modal
                } else if (error.message.includes('403') || error.message.includes('Forbidden')) {
                    errorMessage = '';
                } else if (error.message.includes('404') || error.message.includes('not found')) {
                    errorMessage = '';
                } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                    errorMessage = '';
                }
                
                // console.log(' Showing message:', { message: errorMessage, type: messageType });
                showMessage(errorMessage, messageType);
                
                // Close modal if track already exists (not a real error)
                if (shouldCloseModal) {
                    // console.log(' Closing modal - track already in playlist');
                    closeAddToPlaylistModal();
                } else {
                    // console.log(' Keeping modal open for real error');
                    // Re-enable button only for real errors
                    if (addButton) {
                        addButton.disabled = false;
                        addButton.textContent = '';
                    }
                }
            } finally {
                // Always ensure button is re-enabled if still in error state
                // console.log(' confirmAddToPlaylist function completed');
            }
            } catch (globalError) {
                console.error(' Critical error in confirmAddToPlaylist:', globalError);
                showMessage('', 'error');
                
                // Restore button state
                const addButton = document.getElementById('confirmAddToPlaylistBtn');
                if (addButton) {
                    addButton.disabled = false;
                    addButton.textContent = 'ËøΩÂä†';
                }
            }
        }
        
        // Quick playlist creation for first-time users
        window.createFirstPlaylist = async function() {
            // console.log(' Creating first playlist quickly...');
            
            try {
                const playlistData = {
                    name: 'My First Playlist',
                    description: 'Automatically created first playlist',
                    emoji: 'üéµ',
                    tracks: [],
                    isPublic: false,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                
                showMessage('...', 'info');
                
                const response = await apiClient.request('/api/playlists', {
                    method: 'POST',
                    body: JSON.stringify(playlistData)
                });
                
                // console.log(' First playlist created:', response);
                showMessage(' ', 'success');
                
                // Reload the playlists in the modal
                await loadPlaylistsForAddingTrack();
                
            } catch (error) {
                console.error(' Failed to create first playlist:', error);
                showMessage(': ' + error.message, 'error');
            }
        }
        
        // Close add to playlist modal
        window.closeAddToPlaylistModal = function() {
            const modal = document.getElementById('addToPlaylistModal');
            modal.style.display = 'none';
            window.selectedTrackIdForPlaylist = null;
            window.selectedPlaylistForAdding = null;
            
            // Reset visual selections
            document.querySelectorAll('.playlist-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelectorAll('.selection-indicator').forEach(indicator => {
                indicator.classList.remove('active');
            });
        }

        async function removeFromLibrary(trackId, title, isPodcastEpisode = false) {
            console.log('üöÄ removeFromLibrary v3.1.1 called:', { trackId, title, isPodcastEpisode, user: currentUser?.uid });
            console.log('üîç Current selectedPlaylistId:', window.selectedPlaylistId);
            console.log('üîç Current URL:', window.location.href);
            
            // Close menu
            const menu = document.getElementById(`menu-${trackId}`);
            if (menu) {
                menu.classList.remove('active');
            }
            
            if (!currentUser) {
                console.log('‚ùå No current user, showing error message');
                showMessage('„É¶„Éº„Ç∂„Éº„ÅåË™çË®º„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì', 'error');
                return;
            }
            
            // Show confirmation dialog
            console.log('üìã Showing confirmation dialog for:', title);
            const confirmed = confirm(`"${title}" „Çí„Éó„É¨„Ç§„É™„Çπ„Éà„Åã„ÇâÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`);
            
            if (confirmed) {
                console.log('‚úÖ User confirmed removal for trackId:', trackId);
                
                // Find and disable the menu button for this track (direct style manipulation)
                const menuButton = document.querySelector(`[onclick*="toggleEpisodeMenu('${trackId}')"]`);
                let originalOpacity = '1';
                let originalPointerEvents = 'auto';
                
                if (menuButton) {
                    originalOpacity = menuButton.style.opacity || '1';
                    originalPointerEvents = menuButton.style.pointerEvents || 'auto';
                    menuButton.style.opacity = '0.5';
                    menuButton.style.pointerEvents = 'none';
                }

                try {
                    showMessage(' ...', 'warning');

                    // Determine the correct API endpoint based on current view
                    const token = await firebaseAuth.getIdToken();
                    let apiUrl, apiMessage;
                    
                    if (window.selectedPlaylistId && window.selectedPlaylistId !== 'all') {
                        // Removing from a specific playlist
                        if (isPodcastEpisode) {
                            // Use podcast-specific endpoint for podcast episodes
                            apiUrl = `/api/playlists/${window.selectedPlaylistId}/podcast-episodes/${trackId}`;
                            apiMessage = 'remove podcast episode from playlist';
                        } else {
                            // Use regular track endpoint for music tracks
                            apiUrl = `/api/playlists/${window.selectedPlaylistId}/tracks/${trackId}`;
                            apiMessage = 'remove track from playlist';
                        }
                    } else {
                        // Removing from personal library
                        apiUrl = `/api/tracks/${trackId}/remove-from-library`;
                        apiMessage = 'remove from library';
                    }
                    
                    console.log(`üåê Calling API to ${apiMessage}:`, trackId);
                    console.log('üåê API URL:', apiUrl);
                    console.log('üåê isPodcastEpisode:', isPodcastEpisode);
                    
                    const rawResponse = await fetch(apiUrl, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    console.log('üì° Raw API Response Status:', rawResponse.status);
                    console.log('üì° Raw API Response StatusText:', rawResponse.statusText);
                    
                    const responseText = await rawResponse.text();
                    console.log('üì° Raw API Response Body:', responseText);
                    
                    if (!rawResponse.ok) {
                        let errorData;
                        try {
                            errorData = JSON.parse(responseText);
                        } catch (e) {
                            errorData = { error: responseText };
                        }
                        // console.log(' Parsed Error Data:', errorData);
                        throw new Error(errorData.error || `HTTP ${rawResponse.status}: ${rawResponse.statusText}`);
                    }
                    
                    const response = JSON.parse(responseText);
                    
                    // Show appropriate success message
                    const action = window.selectedPlaylistId && window.selectedPlaylistId !== 'all' 
                        ? '„Éó„É¨„Ç§„É™„Çπ„Éà„Åã„ÇâÂâäÈô§„Åó„Åæ„Åó„Åü' 
                        : '„É©„Ç§„Éñ„É©„É™„Åã„ÇâÂâäÈô§„Åó„Åæ„Åó„Åü';
                    
                    showMessage(` "${response.trackTitle || title}" „Çí${action}`, 'success');
                    
                    // Immediately remove from episodes array for faster UI response
                    const beforeRemoveCount = episodes.length;
                    episodes = episodes.filter(ep => ep.trackId !== trackId);
                    // console.log(` Removed from episodes array: ${beforeRemoveCount} -> ${episodes.length}`);
                    
                    // Force clear cache and reload episodes to reflect changes
                    // console.log(' Force clearing cache and reloading episodes to reflect changes...');
                    forceClearEpisodesCache();
                    await loadEpisodes();
                    
                    // Additional UI cleanup for removed track
                    const removedTrackElement = document.querySelector(`[onclick*="playEpisode('${trackId}')"]`);
                    if (removedTrackElement) {
                        const episodeCard = removedTrackElement.closest('.episode-card');
                        if (episodeCard) {
                            episodeCard.style.transition = 'opacity 0.3s ease-out';
                            episodeCard.style.opacity = '0';
                            setTimeout(() => {
                                if (episodeCard.parentNode) {
                                    episodeCard.parentNode.removeChild(episodeCard);
                                }
                            }, 300);
                        }
                    }
                    
                    // Close player if removed track was playing
                    try {
                        const currentPlayingId = getCurrentPlayingTrackId();
                        if (currentPlayingId === trackId) {
                            // console.log('‚èπ Closing player as removed track was playing');
                            closePlayer();
                        }
                    } catch (playerError) {
                        // console.warn('Could not check/close player:', playerError);
                    }
                    
                } catch (error) {
                    console.error(' Remove from library error:', error);
                    console.error(' Error details:', {
                        name: error.name,
                        message: error.message,
                        stack: error.stack,
                        trackId: trackId
                    });
                    
                    // Re-enable menu button on error
                    if (menuButton) {
                        menuButton.style.opacity = originalOpacity;
                        menuButton.style.pointerEvents = originalPointerEvents;
                    }
                    
                    // Enhanced contextual error messages
                    let errorMessage = '';
                    if (error.message.includes('permanently delete your own tracks')) {
                        // User is trying to remove their own uploaded track - offer permanent deletion
                        const shouldDelete = confirm(`„Åì„ÅÆ„Éà„É©„ÉÉ„ÇØ„ÅØ„ÅÇ„Å™„Åü„Åå„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„ÅüÊõ≤„Åß„Åô„ÄÇ\n\n"${title}"\n\n„É©„Ç§„Éñ„É©„É™„Åã„ÇâÂâäÈô§„Åô„Çã„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅÊ∞∏Á∂öÁöÑ„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\n\n„ÄêÊ≥®ÊÑè„ÄëÊ∞∏Á∂öÁöÑ„Å´ÂâäÈô§„Åô„Çã„Å®ÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ`);
                        
                        if (shouldDelete) {
                            try {
                                showMessage('„Éà„É©„ÉÉ„ÇØ„ÇíÂÆåÂÖ®ÂâäÈô§‰∏≠...', 'warning');
                                
                                const token = await firebaseAuth.getIdToken();
                                const deleteResponse = await fetch(`/api/tracks/${trackId}`, {
                                    method: 'DELETE',
                                    headers: {
                                        'Authorization': `Bearer ${token}`,
                                        'Content-Type': 'application/json'
                                    }
                                });
                                
                                if (!deleteResponse.ok) {
                                    const errorData = await deleteResponse.json();
                                    throw new Error(errorData.error || `HTTP ${deleteResponse.status}`);
                                }
                                
                                const deleteResult = await deleteResponse.json();
                                showMessage(`"${title}" „ÇíÂÆåÂÖ®„Å´ÂâäÈô§„Åó„Åæ„Åó„Åü`, 'success');
                                
                                // Remove from UI immediately
                                episodes = episodes.filter(ep => ep.trackId !== trackId);
                                forceClearEpisodesCache();
                                await loadEpisodes();
                                
                                // Remove from DOM
                                const trackElement = document.querySelector(`[onclick*="playEpisode('${trackId}')"]`);
                                if (trackElement) {
                                    const episodeCard = trackElement.closest('.episode-card');
                                    if (episodeCard) {
                                        episodeCard.style.transition = 'opacity 0.3s ease-out';
                                        episodeCard.style.opacity = '0';
                                        setTimeout(() => {
                                            if (episodeCard.parentNode) {
                                                episodeCard.parentNode.removeChild(episodeCard);
                                            }
                                        }, 300);
                                    }
                                }
                                
                                return;
                            } catch (deleteError) {
                                console.error('Permanent deletion error:', deleteError);
                                showMessage(`ÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${deleteError.message}`, 'error');
                                return;
                            }
                        } else {
                            showMessage('ÂâäÈô§„Çí„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü', 'info');
                            return;
                        }
                    } else if (error.message.includes('404') || error.message.includes('not found')) {
                        errorMessage = ' ';
                    } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                        errorMessage = ' : ';
                    } else if (error.message.includes('403') || error.message.includes('Forbidden')) {
                        errorMessage = ' ';
                    } else if (error.message.includes('503') || error.message.includes('unavailable')) {
                        errorMessage = ' ';
                    } else if (error.message.includes('network') || error.message.includes('fetch')) {
                        errorMessage = ' : ';
                    } else {
                        errorMessage += `: ${error.message}`;
                    }
                    
                    showMessage(errorMessage, 'error');
                } finally {
                    // Always clean up - restore menu button
                    if (menuButton) {
                        menuButton.style.opacity = originalOpacity;
                        menuButton.style.pointerEvents = originalPointerEvents;
                    }
                    // console.log(' Cleanup completed for removeFromLibrary');
                }
            } else {
                // console.log(' User cancelled removal for trackId:', trackId);
            }
        }

        // Close menus when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.episode-menu')) {
                document.querySelectorAll('.menu-dropdown.active').forEach(menu => {
                    menu.classList.remove('active');
                });
            }
        });

        // Profile Management Functions
        window.switchProfileTab = (tabName) => {
            // Remove active class from all tabs and content
            document.querySelectorAll('.profile-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            document.getElementById(`${tabName}Tab`).classList.add('active');
            document.getElementById(`${tabName}Content`).classList.add('active');
        };

        window.toggleSetting = (element) => {
            element.classList.toggle('active');
            // Here you could add logic to save the setting to the backend
            const isActive = element.classList.contains('active');
            // console.log(`Setting toggled: ${isActive}`);
        };

        window.changeAvatar = () => {
            const fileInput = document.getElementById('avatarInput');
            fileInput.click();
        };

        window.handleAvatarChange = (event) => {
            const file = event.target.files[0];
            if (file) {
                if (file.size > 5 * 1024 * 1024) { // 5MB limit
                    showMessage('„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅØ5MB‰ª•‰∏ã„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                    return;
                }
                
                if (!file.type.startsWith('image/')) {
                    showMessage('ÁîªÂÉè„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    // Update profile avatar
                    const profileAvatar = document.getElementById('profileAvatar');
                    if (profileAvatar) {
                        profileAvatar.innerHTML = `<img src="${e.target.result}" alt="Avatar" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                    }
                    
                    // Update header avatar
                    const headerAvatar = document.querySelector('.header-user-avatar');
                    if (headerAvatar) {
                        headerAvatar.innerHTML = `<img src="${e.target.result}" alt="Avatar" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
                    }
                    
                    // Store avatar data for saving
                    window.pendingAvatarData = e.target.result;
                    
                    showMessage('„Ç¢„Éê„Çø„ÉºÁîªÂÉè„ÇíÈÅ∏Êäû„Åó„Åæ„Åó„Åü„ÄÇ‰øùÂ≠ò„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Â§âÊõ¥„Çí‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'success');
                };
                reader.readAsDataURL(file);
            }
        };

        window.saveProfile = async () => {
            try {
                const formData = {
                    displayName: document.getElementById('profileDisplayName').value,
                    bio: document.getElementById('profileBio').value,
                    website: document.getElementById('profileWebsite').value,
                    location: document.getElementById('profileLocation').value
                };

                // Add avatar data if available
                if (window.pendingAvatarData) {
                    formData.avatar = window.pendingAvatarData;
                }

                setLoadingState('profile', true);
                await apiClient.request('/api/users/profile', {
                    method: 'POST',
                    body: JSON.stringify(formData)
                });

                // Clear pending avatar data after successful save
                if (window.pendingAvatarData) {
                    delete window.pendingAvatarData;
                }

                showMessage('„Éó„É≠„Éï„Ç£„Éº„É´„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü', 'success');
            } catch (error) {
                console.error('Profile save error:', error);
                showMessage(': ' + error.message, 'error');
            } finally {
                setLoadingState('profile', false);
            }
        };

        window.changePassword = async () => {
            const currentPassword = prompt(':');
            if (!currentPassword) return;

            const newPassword = prompt('6:');
            if (!newPassword || newPassword.length < 6) {
                showMessage('6', 'error');
                return;
            }

            const confirmPassword = prompt(':');
            if (newPassword !== confirmPassword) {
                showMessage('', 'error');
                return;
            }

            try {
                await apiClient.request('/api/users/change-password', {
                    method: 'POST',
                    body: JSON.stringify({
                        currentPassword,
                        newPassword
                    })
                });
                showMessage('', 'success');
            } catch (error) {
                showMessage(': ' + error.message, 'error');
            }
        };

        window.enable2FA = async () => {
            try {
                const response = await apiClient.request('/api/users/enable-2fa', {
                    method: 'POST'
                });
                
                if (response.qrCode) {
                    const qrWindow = window.open('', '_blank', 'width=400,height=500');
                    qrWindow.document.write(`
                        <html><head><title>2</title></head><body style="padding: 20px; font-family: system-ui;">
                            <h2>2</h2>
                            <p>QR</p>
                            <img src="${response.qrCode}" style="max-width: 100%;">
                            <p><strong>:</strong> ${response.backupCodes?.join(', ') || 'N/A'}</p>
                        </body></html>
                    `);
                }
                showMessage('2', 'success');
            } catch (error) {
                showMessage('2: ' + error.message, 'error');
            }
        };

        window.exportData = async (dataType) => {
            try {
                showMessage('...', 'info');
                const response = await apiClient.request(`/api/users/export/${dataType}`, {
                    method: 'POST'
                });

                if (response.downloadUrl) {
                    const link = document.createElement('a');
                    link.href = response.downloadUrl;
                    link.download = `podcast-${dataType}-export.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showMessage(`${dataType}`, 'success');
                }
            } catch (error) {
                showMessage(`: ${error.message}`, 'error');
            }
        };

        window.deleteAccount = async () => {
            // Show custom confirmation modal
            showConfirmationModal({
                title: '„Ç¢„Ç´„Ç¶„É≥„Éà„ÇíÂâäÈô§',
                message: '„Ç¢„Ç´„Ç¶„É≥„Éà„ÇíÂÆåÂÖ®„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü',
                warningMessage: 'Ë≠¶Âëä: „Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ„Åô„Åπ„Å¶„ÅÆ„Éá„Éº„Çø„ÅåÂ§±„Çè„Çå„Åæ„Åô„ÄÇ',
                confirmText: '„Ç¢„Ç´„Ç¶„É≥„ÉàÂâäÈô§',
                cancelText: '„Ç≠„É£„É≥„Çª„É´',
                skipOption: false, // Never skip this confirmation
                onConfirm: async () => {
                    // Second confirmation with email verification
                    const email = prompt(':');
                    if (!email || email !== currentUser?.email) {
                        showMessage('', 'error');
                        return;
                    }

                    try {
                        await apiClient.request('/api/users/delete-account', {
                            method: 'DELETE',
                            body: JSON.stringify({ confirmEmail: email })
                        });
                        
                        showMessage('', 'success');
                        
                        // Sign out and redirect
                        setTimeout(async () => {
                            await firebaseAuth.signOut();
                            window.location.reload();
                        }, 3000);
                    } catch (error) {
                        showMessage(': ' + error.message, 'error');
                    }
                }
            });
        };

        // Button text checker function (removed for production)
        /*
        window.debugButtonText = function() {
            console.log('=== BUTTON TEXT DEBUG ===');
            const buttons = document.querySelectorAll('button');
            buttons.forEach((btn, index) => {
                if (btn.textContent || btn.innerText) {
                    console.log(`Button ${index}:`, {
                        textContent: btn.textContent,
                        innerText: btn.innerText,
                        title: btn.title,
                        className: btn.className,
                        id: btn.id,
                        computedStyle: {
                            color: window.getComputedStyle(btn).color,
                            fontSize: window.getComputedStyle(btn).fontSize,
                            opacity: window.getComputedStyle(btn).opacity,
                            display: window.getComputedStyle(btn).display,
                            visibility: window.getComputedStyle(btn).visibility
                        }
                    });
                }
            });
            
            // Check specific problematic buttons
            const playlistSelector = document.getElementById('playlistSelector');
            if (playlistSelector) {
                console.log('Playlist selector options:');
                playlistSelector.querySelectorAll('option').forEach((opt, i) => {
                    console.log(`Option ${i}:`, opt.textContent, opt.value);
                });
            }
            
            const addBtn = document.getElementById('confirmAddToPlaylistBtn');
            if (addBtn) {
                console.log('Add to playlist button:', {
                    textContent: addBtn.textContent,
                    innerText: addBtn.innerText,
                    innerHTML: addBtn.innerHTML
                });
            }
        };
        */

        // Export functions for HTML onclick handlers
        window.playEpisode = playEpisode;
        window.confirmDeleteTrack = confirmDeleteTrack;
        window.confirmDeleteOrphanedTrack = confirmDeleteOrphanedTrack;
        window.toggleEpisodeMenu = toggleEpisodeMenu;
        window.addToPlaylist = addToPlaylist;
        window.addToPodcastLibrary = addToPodcastLibrary;
        window.removeFromLibrary = removeFromLibrary;
        window.openTrackEditor = openTrackEditor;
        window.closeTrackEditor = closeTrackEditor;
        window.saveTrackChanges = saveTrackChanges;

        // =================================
        // Podcasts
        // =================================

        // Search podcasts
        async function searchPodcasts() {
            console.log('üîç Search function called');
            const searchInput = document.getElementById('podcastSearchInput');
            const categoryFilter = document.getElementById('podcastCategoryFilter');
            const loadingElement = document.getElementById('podcastSearchLoading');
            const resultsContainer = document.getElementById('podcastSearchResults');
            const messageElement = document.getElementById('podcastSearchMessage');
            
            const query = searchInput.value.trim();
            const category = categoryFilter.value;
            console.log('üîç Query:', query, 'Category:', category);
            
            if (!query && category === 'all') {
                messageElement.textContent = '';
                messageElement.className = 'message warning-message';
                messageElement.classList.remove('hidden');
                setTimeout(() => messageElement.classList.add('hidden'), 5000);
                return;
            }
            
            try {
                // Show loading
                loadingElement.classList.remove('hidden');
                resultsContainer.style.display = 'none';
                messageElement.classList.add('hidden');
                
                // Construct search URL
                const searchParams = new URLSearchParams();
                if (query) searchParams.append('query', query);
                if (category !== 'all') searchParams.append('category', category);
                searchParams.append('limit', '100');
                
                const response = await fetch(`/api/podcasts/search?${searchParams}`);
                
                if (!response.ok) {
                    throw new Error(`Search failed: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üîç API Response:', data);
                loadingElement.classList.add('hidden');
                
                if (data.episodes && data.episodes.length > 0) {
                    console.log('üîç Calling displaySearchResults with', data.episodes.length, 'episodes');
                    displaySearchResults(data.episodes, data.total_count, query);
                } else {
                    console.log('üîç No results found');
                    showNoResults(query, category);
                }
                
            } catch (error) {
                console.error(' Podcast search error:', error);
                loadingElement.classList.add('hidden');
                messageElement.textContent = '';
                messageElement.className = 'message error-message';
                messageElement.classList.remove('hidden');
                setTimeout(() => messageElement.classList.add('hidden'), 5000);
            }
        }

        // Load latest episodes (without search query)
        async function loadLatestEpisodes() {
            const loadingElement = document.getElementById('podcastSearchLoading');
            const resultsContainer = document.getElementById('podcastSearchResults');
            const messageElement = document.getElementById('podcastSearchMessage');
            
            try {
                // Show loading
                loadingElement.classList.remove('hidden');
                resultsContainer.style.display = 'none';
                messageElement.classList.add('hidden');
                
                const response = await fetch('/api/podcasts/search?limit=100');
                
                if (!response.ok) {
                    throw new Error(`Failed to load episodes: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                loadingElement.classList.add('hidden');
                
                if (data.episodes && data.episodes.length > 0) {
                    displaySearchResults(data.episodes, data.total_count, '');
                } else {
                    showNoResults('', 'all');
                }
                
            } catch (error) {
                console.error(' Load latest episodes error:', error);
                loadingElement.classList.add('hidden');
                showMessage('', 'error', messageElement);
            }
        }

        // Display search results
        function displaySearchResults(episodes, totalCount, query) {
            console.log('üì∫ displaySearchResults called with:', { episodes: episodes.length, totalCount, query });
            const resultsContainer = document.getElementById('podcastSearchResults');
            const titleElement = document.getElementById('searchResultsTitle');
            const countElement = document.getElementById('searchResultsCount');
            const listElement = document.getElementById('episodesList');
            console.log('üì∫ Elements found:', { resultsContainer: !!resultsContainer, titleElement: !!titleElement, countElement: !!countElement, listElement: !!listElement });
            
            // Store search results globally for button functions
            window.currentPodcastSearchResults = episodes;
            
            // Update title and count
            titleElement.textContent = query ? `"${query}" ` : '';
            countElement.textContent = `${totalCount}`;
            
            // Clear and populate episodes list
            listElement.innerHTML = '';
            
            episodes.forEach((episode, index) => {
                const episodeCard = createEpisodeCard(episode);
                listElement.appendChild(episodeCard);
                if (index < 3) console.log('üì∫ Added episode card:', episode.title);
            });
            
            console.log('üì∫ Setting resultsContainer display to block');
            resultsContainer.style.display = 'block';
            console.log('üì∫ Results container display:', resultsContainer.style.display);
        }

        // Create episode card HTML element
        function createEpisodeCard(episode) {
            const card = document.createElement('div');
            card.className = 'episode-card';
            
            // Format published date
            let publishedText = '';
            if (episode.published) {
                try {
                    const date = new Date(episode.published);
                    publishedText = date.toLocaleDateString('ja-JP', { 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric' 
                    });
                } catch (e) {
                    publishedText = episode.published.substring(0, 10);
                }
            }
            
            // Create keywords display
            const keywordsHtml = episode.matched_keywords && episode.matched_keywords.length > 0 
                ? `<div class="episode-keywords">
                     ${episode.matched_keywords.map(kw => `<span class="keyword-tag">${kw}</span>`).join('')}
                   </div>`
                : '';
            
            card.innerHTML = `
                <div class="episode-header">
                    <div>
                        <h3 class="episode-title">${episode.title}</h3>
                        <div class="episode-podcast"> ${episode.podcast_name}</div>
                    </div>
                </div>
                
                <div class="episode-meta">
                    <span class="episode-duration">‚è± ${episode.duration}</span>
                    <span class="episode-published"> ${publishedText}</span>
                </div>
                
                ${episode.description ? `<div class="episode-description">${episode.description.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, '').substring(0, 100)}${episode.description.length > 100 ? '...' : ''}</div>` : ''}
                
                ${keywordsHtml}
                
                <div class="episode-actions">
                    ${episode.audio_url ? `
                        <button class="episode-btn" data-episode-id="${episode.id}" onclick="playPodcastEpisodeSimple(this)">ÂÜçÁîü</button>
                        <button class="episode-btn secondary" data-episode-id="${episode.id}" onclick="downloadPodcastEpisodeSimple(this)">„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</button>
                    ` : ''}
                    ${episode.link ? `
                        <button class="episode-btn secondary" onclick="window.open('${episode.link}', '_blank')">„É™„É≥„ÇØ</button>
                    ` : ''}
                    <button class="episode-btn podcast-library-add login-required" data-episode-id="${episode.id}" onclick="addToPodcastLibrarySimple(this)">„É©„Ç§„Éñ„É©„É™ËøΩÂä†</button>
                    <button class="episode-btn podcast-playlist-add login-required" data-episode-id="${episode.id}" onclick="showAddToPodcastPlaylistModal('${episode.id}', '${episode.title.replace(/'/g, "\\'")}', '${episode.podcast_name.replace(/'/g, "\\'")}', '${episode.audio_url || ''}', '${(episode.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').substring(0, 100)}')">„Éó„É¨„Ç§„É™„Çπ„ÉàËøΩÂä†</button>
                </div>
            `;
            
            return card;
        }

        // Show no results message
        function showNoResults(query, category) {
            const resultsContainer = document.getElementById('podcastSearchResults');
            const titleElement = document.getElementById('searchResultsTitle');
            const countElement = document.getElementById('searchResultsCount');
            const listElement = document.getElementById('episodesList');
            
            titleElement.textContent = query ? `"${query}" ` : '';
            countElement.textContent = '0';
            
            listElement.innerHTML = `
                <div class="search-no-results">
                    <h3>0‰ª∂</h3>
                </div>
            `;
            
            resultsContainer.style.display = 'block';
        }

        // Play podcast episode directly
        function playPodcastEpisode(audioUrl, title, podcastName) {
            // Create a temporary episode object for the player
            const tempEpisode = {
                trackId: 'podcast_' + Date.now(),
                title: title,
                artist: podcastName,
                audioUrl: audioUrl,
                isPodcast: true
            };
            
            // Use existing playEpisode function
            playEpisode(tempEpisode.trackId, tempEpisode);
        }

        // Download podcast episode to user's library
        async function downloadPodcastEpisode(episodeId, audioUrl, title, description, podcastName) {
            if (!currentUser) {
                showMessage('', 'warning');
                return;
            }
            
            const button = event.target;
            const originalText = button.textContent;
            
            try {
                button.disabled = true;
                button.textContent = ' ...';
                
                const response = await apiClient.request('/api/podcasts/download', {
                    method: 'POST',
                    body: JSON.stringify({
                        episode_id: episodeId,
                        audio_url: audioUrl,
                        title: title,
                        description: description || '',
                        podcast_name: podcastName
                    })
                });
                
                button.textContent = ' ';
                showMessage(`"${title}" `, 'success');
                
                // Reset button after 3 seconds
                setTimeout(() => {
                    button.disabled = false;
                    button.textContent = originalText;
                }, 3000);
                
                // Optionally reload episodes to show the new download
                // loadEpisodes();
                
            } catch (error) {
                console.error(' Download error:', error);
                button.disabled = false;
                button.textContent = originalText;
                showMessage(': ' + error.message, 'error');
            }
        }

        // Add Enter key support for search input
        document.addEventListener('DOMContentLoaded', () => {
            const searchInput = document.getElementById('podcastSearchInput');
            if (searchInput) {
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        searchPodcasts();
                    }
                });
            }
        });

        // Admin function to clear demo tracks for current user
        window.clearDemoTracks = async function() {
            if (!currentUser) {
                showMessage('„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'error');
                return;
            }
            
            const confirmed = confirm('Êó¢Â≠ò„ÅÆ„Éá„É¢„Éà„É©„ÉÉ„ÇØÔºàdemo-„ÄÅuser-track-„ÅßÂßã„Åæ„Çã„Éà„É©„ÉÉ„ÇØÔºâ„Çí„Åô„Åπ„Å¶„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü\n\nÊ≥®ÊÑèÔºö„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ');
            if (!confirmed) {
                return;
            }
            
            try {
                showMessage('„Éá„É¢„Éà„É©„ÉÉ„ÇØ„Çí„ÇØ„É™„Ç¢‰∏≠...', 'warning');
                
                // Get all demo tracks that need to be cleared
                const demoTrackIds = episodes
                    .filter(ep => ep.trackId && (
                        ep.trackId.startsWith('demo-') || 
                        ep.trackId.startsWith('user-track-') ||
                        ep.trackId.includes('demo') ||
                        ep.title === 'Demo Track' ||
                        ep.title.includes('„ÉÜ„Çπ„Éà') ||
                        ep.title.includes('Demo')
                    ))
                    .map(ep => ep.trackId);
                
                console.log('Found demo tracks to clear:', demoTrackIds);
                
                if (demoTrackIds.length === 0) {
                    showMessage('„ÇØ„É™„Ç¢„Åô„Çã„Éá„É¢„Éà„É©„ÉÉ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'info');
                    return;
                }
                
                // Clear each demo track
                let cleared = 0;
                const token = await firebaseAuth.getIdToken();
                
                for (const trackId of demoTrackIds) {
                    try {
                        // Try permanent deletion first (if user owns the track)
                        const deleteResponse = await fetch(`/api/tracks/${trackId}`, {
                            method: 'DELETE',
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (deleteResponse.ok) {
                            console.log('Permanently deleted demo track:', trackId);
                            cleared++;
                            continue;
                        }
                        
                        // If permanent deletion fails, try library removal
                        const removeResponse = await fetch(`/api/tracks/${trackId}/remove-from-library`, {
                            method: 'DELETE',
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (removeResponse.ok) {
                            console.log('Removed demo track from library:', trackId);
                            cleared++;
                        } else {
                            console.log('Failed to clear demo track:', trackId, removeResponse.status);
                        }
                        
                    } catch (error) {
                        console.log('Error clearing demo track:', trackId, error.message);
                    }
                }
                
                showMessage(`${cleared}ÂÄã„ÅÆ„Éá„É¢„Éà„É©„ÉÉ„ÇØ„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü`, 'success');
                
                // Refresh the episode list
                forceClearEpisodesCache();
                await loadEpisodes();
                
            } catch (error) {
                console.error('Demo track clearing error:', error);
                showMessage('„Éá„É¢„Éà„É©„ÉÉ„ÇØ„ÇØ„É™„Ç¢‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' + error.message, 'error');
            }
        };

        // Make functions globally available
        window.searchPodcasts = searchPodcasts;
        window.loadLatestEpisodes = loadLatestEpisodes;
        window.playPodcastEpisode = playPodcastEpisode;
        window.downloadPodcastEpisode = downloadPodcastEpisode;
        window.displaySearchResults = displaySearchResults;
        window.showNoResults = showNoResults;
        window.createEpisodeCard = createEpisodeCard;
        
        // ============== PODCAST PLAYLIST FUNCTIONS ==============
        let selectedPodcastPlaylistEmoji = 'üéôÔ∏è';
        let selectedPodcastPlaylistForAdding = null;
        let selectedPodcastIdForPlaylist = null;
        
        // Show Podcast Playlists
        async function showPodcastPlaylists() {
            if (!currentUser) {
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË°®Á§∫„Åô„Çã„Å´„ÅØ„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'warning');
                return;
            }
            
            try {
                const response = await fetch('/api/podcast-playlists', {
                    headers: {
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);
                
                const data = await response.json();
                displayPodcastPlaylistsResults(data.playlists || []);
                
            } catch (error) {
                console.error('Error loading podcast playlists:', error);
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Display Podcast Playlists Results
        function displayPodcastPlaylistsResults(playlists) {
            const resultsContainer = document.getElementById('podcastLibraryResults');
            
            // Safe check for resultsContainer
            if (!resultsContainer) {
                console.log('podcastLibraryResults element not found in displayPodcastPlaylistsResults, skipping');
                return;
            }
            
            if (!playlists || playlists.length === 0) {
                resultsContainer.innerHTML = `
                    <div class="empty-library-state">
                        <div style="text-align: center; opacity: 0.8;">
                            <div style="font-size: 4em; margin-bottom: 20px;">üìã</div>
                            <h3 style="margin-bottom: 10px; color: var(--text);">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</h3>
                            <p style="margin-bottom: 20px; color: var(--text-muted);">„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅÆ„Ç®„Éî„ÇΩ„Éº„Éâ„ÇíÊï¥ÁêÜ„Åô„Çã„Åü„ÇÅ„ÅÆ„Éó„É¨„Ç§„É™„Çπ„Éà„Çí‰ΩúÊàê„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
                            <button onclick="createNewPodcastPlaylist()" style="padding: 10px 20px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                                Êñ∞„Åó„ÅÑ„Éó„É¨„Ç§„É™„Çπ„Éà‰ΩúÊàê
                            </button>
                        </div>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div class="podcast-playlists-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: var(--text);">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà (${playlists.length})</h3>
                    <button onclick="createNewPodcastPlaylist()" class="auth-button" style="padding: 8px 16px; font-size: 0.9em;">
                        + Êñ∞Ë¶è‰ΩúÊàê
                    </button>
                </div>
                <div class="podcast-playlists-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px;">
            `;
            
            playlists.forEach(playlist => {
                const episodeCount = playlist.episodes ? playlist.episodes.length : 0;
                html += `
                    <div class="podcast-playlist-card" style="background: var(--panel); border: 1px solid rgba(159, 247, 234, 0.3); border-radius: 12px; padding: 20px; transition: all 0.3s ease;">
                        <div class="playlist-header" style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <span class="playlist-emoji" style="font-size: 2em;">${playlist.emoji || 'üéôÔ∏è'}</span>
                            <div>
                                <h4 style="margin: 0 0 4px 0; color: var(--text);">${playlist.name}</h4>
                                <p style="margin: 0; color: var(--text-muted); font-size: 0.9em;">${episodeCount} „Ç®„Éî„ÇΩ„Éº„Éâ</p>
                            </div>
                        </div>
                        ${playlist.description ? `<p style="margin-bottom: 15px; color: var(--text-muted); font-size: 0.9em; line-height: 1.4;">${playlist.description}</p>` : ''}
                        <div class="playlist-actions" style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="viewPodcastPlaylist('${playlist.id}')" class="playlist-action-btn" style="padding: 6px 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; font-size: 0.8em; cursor: pointer;">
                                Ë°®Á§∫
                            </button>
                            <button onclick="deletePodcastPlaylist('${playlist.id}', '${playlist.name}')" class="playlist-action-btn danger" style="padding: 6px 12px; background: #ff4757; color: white; border: none; border-radius: 6px; font-size: 0.8em; cursor: pointer;">
                                ÂâäÈô§
                            </button>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            resultsContainer.innerHTML = html;
        }
        
        // Show Add to Podcast Playlist Modal
        async function showAddToPodcastPlaylistModal(episodeId, title, podcastName, audioUrl, description) {
            if (!currentUser) {
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†„Åô„Çã„Å´„ÅØ„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'warning');
                return;
            }
            
            selectedPodcastIdForPlaylist = episodeId;
            
            // Update selected episode info
            document.getElementById('selectedPodcastTitle').textContent = title;
            
            // Load and show playlists in modal
            await loadPodcastPlaylistsForAdding();
            
            // Show the modal
            document.getElementById('addToPodcastPlaylistModal').style.display = 'flex';
            
            // Reset selection state
            selectedPodcastPlaylistForAdding = null;
            document.getElementById('confirmAddToPodcastPlaylistBtn').disabled = true;
            document.getElementById('confirmAddToPodcastPlaylistBtn').classList.add('disabled');
        }
        
        // Close Add to Podcast Playlist Modal
        function closeAddToPodcastPlaylistModal() {
            document.getElementById('addToPodcastPlaylistModal').style.display = 'none';
            selectedPodcastIdForPlaylist = null;
            selectedPodcastPlaylistForAdding = null;
        }
        
        // Load Podcast Playlists for Adding
        async function loadPodcastPlaylistsForAdding() {
            const container = document.getElementById('podcastPlaylistsForAdding');
            container.innerHTML = '<div class="loading-item">„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>';
            
            try {
                const response = await fetch('/api/podcast-playlists', {
                    headers: {
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);
                
                const data = await response.json();
                const playlists = data.playlists || [];
                
                if (playlists.length === 0) {
                    container.innerHTML = `
                        <div class="no-playlists" style="text-align: center; padding: 20px; color: var(--text-muted);">
                            <p>„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
                            <button onclick="createNewPodcastPlaylist(); closeAddToPodcastPlaylistModal();" class="auth-button" style="margin-top: 10px;">
                                Êñ∞„Åó„ÅÑ„Éó„É¨„Ç§„É™„Çπ„Éà‰ΩúÊàê
                            </button>
                        </div>
                    `;
                    return;
                }
                
                let html = '';
                playlists.forEach(playlist => {
                    const episodeCount = playlist.episodes ? playlist.episodes.length : 0;
                    html += `
                        <div class="playlist-option" onclick="selectPodcastPlaylistForAdding('${playlist.id}', '${playlist.name}')" style="cursor: pointer; padding: 12px; border: 1px solid rgba(159, 247, 234, 0.3); border-radius: 8px; margin-bottom: 8px; transition: all 0.2s ease;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.2em;">${playlist.emoji || 'üéôÔ∏è'}</span>
                                <div>
                                    <h4 style="margin: 0; font-size: 0.9em; color: var(--text);">${playlist.name}</h4>
                                    <p style="margin: 0; font-size: 0.8em; color: var(--text-muted);">${episodeCount} „Ç®„Éî„ÇΩ„Éº„Éâ</p>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading playlists for adding:', error);
                container.innerHTML = '<div class="error-state">Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº</div>';
            }
        }
        
        // Select Podcast Playlist for Adding
        function selectPodcastPlaylistForAdding(playlistId, playlistName, clickedElement) {
            selectedPodcastPlaylistForAdding = { id: playlistId, name: playlistName };
            
            // Update visual selection
            document.querySelectorAll('#podcastPlaylistsForAdding .playlist-option').forEach(option => {
                option.style.borderColor = 'rgba(159, 247, 234, 0.3)';
                option.style.backgroundColor = 'transparent';
            });
            
            // Handle the clicked element (either from event or parameter)
            const targetElement = clickedElement || (typeof event !== 'undefined' ? event.currentTarget : null);
            if (targetElement) {
                targetElement.style.borderColor = 'var(--accent)';
                targetElement.style.backgroundColor = 'rgba(159, 247, 234, 0.1)';
            } else {
                // Find the element by playlist ID if no target element available
                const playlistElement = Array.from(document.querySelectorAll('#podcastPlaylistsForAdding .playlist-option'))
                    .find(option => option.onclick && option.onclick.toString().includes(`'${playlistId}'`));
                if (playlistElement) {
                    playlistElement.style.borderColor = 'var(--accent)';
                    playlistElement.style.backgroundColor = 'rgba(159, 247, 234, 0.1)';
                }
            }
            
            // Enable add button
            const addButton = document.getElementById('confirmAddToPodcastPlaylistBtn');
            addButton.disabled = false;
            addButton.classList.remove('disabled');
            
            console.log('üéôÔ∏è Selected playlist for adding:', playlistName, playlistId);
        }
        
        // Confirm Add to Podcast Playlist
        async function confirmAddToPodcastPlaylist() {
            if (!selectedPodcastPlaylistForAdding || !selectedPodcastIdForPlaylist) {
                showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà„Å®„Ç®„Éî„ÇΩ„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/podcast-playlists/${selectedPodcastPlaylistForAdding.id}/episodes`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        episode_id: selectedPodcastIdForPlaylist
                    })
                });
                
                if (!response.ok) throw new Error(`Failed to add: ${response.status}`);
                
                showMessage(`"${selectedPodcastPlaylistForAdding.name}" „Å´„Ç®„Éî„ÇΩ„Éº„Éâ„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü`, 'success');
                closeAddToPodcastPlaylistModal();
                
            } catch (error) {
                console.error('Error adding to podcast playlist:', error);
                if (error.message.includes('already exists')) {
                    showMessage('„Åì„ÅÆ„Ç®„Éî„ÇΩ„Éº„Éâ„ÅØÊó¢„Å´„Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„Åô', 'info');
                } else {
                    showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà„Å∏„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                }
            }
        }
        
        // Create New Podcast Playlist
        function createNewPodcastPlaylist() {
            document.getElementById('createPodcastPlaylistModal').style.display = 'flex';
            // Reset form
            document.getElementById('podcastPlaylistName').value = '';
            document.getElementById('podcastPlaylistDescription').value = '';
            selectedPodcastPlaylistEmoji = 'üéôÔ∏è';
            updatePodcastPlaylistEmojiSelection();
        }
        
        // Close Create Podcast Playlist
        function closeCreatePodcastPlaylist() {
            document.getElementById('createPodcastPlaylistModal').style.display = 'none';
        }
        
        // Select Podcast Playlist Emoji
        function selectPodcastPlaylistEmoji(emoji) {
            selectedPodcastPlaylistEmoji = emoji;
            document.getElementById('selectedPodcastPlaylistEmoji').value = emoji;
            updatePodcastPlaylistEmojiSelection();
        }
        
        // Update Podcast Playlist Emoji Selection
        function updatePodcastPlaylistEmojiSelection() {
            document.querySelectorAll('#createPodcastPlaylistModal .emoji-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.textContent === selectedPodcastPlaylistEmoji) {
                    btn.classList.add('selected');
                }
            });
        }
        
        // Submit Create Podcast Playlist
        async function submitCreatePodcastPlaylist() {
            if (!currentUser) {
                showMessage('„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'error');
                return;
            }
            
            const name = document.getElementById('podcastPlaylistName').value.trim();
            const description = document.getElementById('podcastPlaylistDescription').value.trim();
            
            if (!name) {
                showMessage('„Éó„É¨„Ç§„É™„Çπ„ÉàÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/podcast-playlists', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        name: name,
                        description: description,
                        emoji: selectedPodcastPlaylistEmoji
                    })
                });
                
                if (!response.ok) throw new Error(`Failed to create: ${response.status}`);
                
                const data = await response.json();
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü', 'success');
                
                // Close creation modal and reload playlist manager
                closeCreatePodcastPlaylist();
                
                // Reload the playlist manager to show the new playlist
                await loadUserPodcastPlaylists();
                
                // Ensure the podcast playlist manager stays open
                const podcastModal = document.getElementById('podcastPlaylistModal');
                if (podcastModal) {
                    podcastModal.style.display = 'flex';
                    console.log('üéôÔ∏è Podcast playlist manager kept open after creation');
                }
                
            } catch (error) {
                console.error('Error creating podcast playlist:', error);
                showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Make functions globally available
        window.showPodcastPlaylists = showPodcastPlaylists;
        window.createNewPodcastPlaylist = createNewPodcastPlaylist;
        window.closeCreatePodcastPlaylist = closeCreatePodcastPlaylist;
        window.selectPodcastPlaylistEmoji = selectPodcastPlaylistEmoji;
        window.submitCreatePodcastPlaylist = submitCreatePodcastPlaylist;
        window.showAddToPodcastPlaylistModal = showAddToPodcastPlaylistModal;
        window.closeAddToPodcastPlaylistModal = closeAddToPodcastPlaylistModal;
        window.selectPodcastPlaylistForAdding = selectPodcastPlaylistForAdding;
        window.confirmAddToPodcastPlaylist = confirmAddToPodcastPlaylist;

        // ============== SIDEBAR TOGGLE FUNCTIONS ==============
        let sidebarHidden = false;
        
        // Toggle Sidebar Visibility
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.querySelector('.main-content');
            const isMobile = window.innerWidth < 768;
            
            if (!sidebar) return;
            
            sidebarHidden = !sidebarHidden;
            
            if (sidebarHidden) {
                sidebar.classList.add('sidebar-hidden');
                toggleBtn.title = '„Çµ„Ç§„Éâ„Éê„Éº„ÇíË°®Á§∫';
                // „Çµ„Ç§„Éâ„Éê„Éº„ÅåÈñâ„Åò„Å¶„ÅÑ„ÇãÊôÇ„ÅØ„Éà„Ç∞„É´„Éú„Çø„É≥„ÇíË°®Á§∫
                toggleBtn.style.setProperty('display', 'flex', 'important');
                // „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÇíÂÖ®ÂπÖ„Å´Ë®≠ÂÆö
                if (mainContent) {
                    mainContent.classList.add('full-width');
                }
                // Save state to localStorage
                localStorage.setItem('sidebarHidden', 'true');
            } else {
                sidebar.classList.remove('sidebar-hidden');
                toggleBtn.title = '„Çµ„Ç§„Éâ„Éê„Éº„ÇíÈùûË°®Á§∫';
                // „Çµ„Ç§„Éâ„Éê„Éº„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÊôÇ„ÅØ„Éà„Ç∞„É´„Éú„Çø„É≥„ÇíÈùûË°®Á§∫Ôºà„Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„ÅøÔºâ
                if (!isMobile) {
                    toggleBtn.style.setProperty('display', 'none', 'important');
                }
                // „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Åã„ÇâÂÖ®ÂπÖ„ÇØ„É©„Çπ„ÇíÂâäÈô§
                if (mainContent) {
                    mainContent.classList.remove('full-width');
                }
                // Save state to localStorage
                localStorage.setItem('sidebarHidden', 'false');
            }
            
            console.log('Sidebar toggled:', sidebarHidden ? 'hidden' : 'visible');
        }
        
        // Initialize Sidebar State
        function initializeSidebarState() {
            const savedState = localStorage.getItem('sidebarHidden');
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.querySelector('.main-content');
            
            if (!sidebar) return;
            
            // Check if mobile view (screen width < 768px)
            const isMobile = window.innerWidth < 768;
            
            // „É≠„Ç∞„Ç§„É≥Áä∂ÊÖã„Å´„Çà„Å£„Å¶ÂàùÊúüÁä∂ÊÖã„ÇíÊ±∫ÂÆö
            if (currentUser) {
                // „É≠„Ç∞„Ç§„É≥Âæå: „Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅØÂ∏∏„Å´Èñã„Åè„ÄÅ„É¢„Éê„Ç§„É´„ÅØ‰øùÂ≠ò„Åï„Çå„ÅüÁä∂ÊÖã„Åæ„Åü„ÅØ„Éá„Éï„Ç©„É´„ÉàÔºàÈñâ„Åò„ÇãÔºâ
                if (!isMobile) {
                    // „Éá„Çπ„ÇØ„Éà„ÉÉ„Éó: „É≠„Ç∞„Ç§„É≥Âæå„ÅØÂ∏∏„Å´„Çµ„Ç§„Éâ„É°„Éã„É•„Éº„ÇíÈñã„Åè
                    sidebarHidden = false;
                    localStorage.setItem('sidebarHidden', 'false');
                } else {
                    // „É¢„Éê„Ç§„É´: ‰øùÂ≠ò„Åï„Çå„ÅüÁä∂ÊÖã„Çí‰ΩøÁî®ÔºàÂàùÂõû„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅßÈñâ„Åò„ÇãÔºâ
                    if (savedState === null) {
                        sidebarHidden = true; // „É¢„Éê„Ç§„É´„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅßÈñâ„Åò„Çã
                        localStorage.setItem('sidebarHidden', 'true');
                    } else {
                        sidebarHidden = savedState === 'true';
                    }
                }
            } else {
                // „É≠„Ç∞„Ç§„É≥Ââç: ÂæìÊù•ÈÄö„Çä„ÅÆÂãï‰ΩúÔºà„Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÈñã„Åè„ÄÅ„É¢„Éê„Ç§„É´Èñâ„Åò„ÇãÔºâ
                if (savedState === null) {
                    sidebarHidden = isMobile; // Hidden on mobile, open on desktop
                    localStorage.setItem('sidebarHidden', isMobile ? 'true' : 'false');
                } else {
                    sidebarHidden = savedState === 'true';
                }
            }
            
            if (sidebarHidden) {
                sidebar.classList.add('sidebar-hidden');
                toggleBtn.title = '„Çµ„Ç§„Éâ„Éê„Éº„ÇíË°®Á§∫';
                // „Çµ„Ç§„Éâ„Éê„Éº„ÅåÈñâ„Åò„Å¶„ÅÑ„ÇãÊôÇ„ÅØ„Éà„Ç∞„É´„Éú„Çø„É≥„ÇíË°®Á§∫
                toggleBtn.style.setProperty('display', 'flex', 'important');
                // „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÇíÂÖ®ÂπÖ„Å´Ë®≠ÂÆö
                if (mainContent) {
                    mainContent.classList.add('full-width');
                }
            } else {
                sidebar.classList.remove('sidebar-hidden');
                toggleBtn.title = '„Çµ„Ç§„Éâ„Éê„Éº„ÇíÈùûË°®Á§∫';
                // „Çµ„Ç§„Éâ„Éê„Éº„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÊôÇ„ÅØ„Éà„Ç∞„É´„Éú„Çø„É≥„ÇíÈùûË°®Á§∫Ôºà„Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„ÅøÔºâ
                if (!isMobile) {
                    toggleBtn.style.setProperty('display', 'none', 'important');
                } else {
                    toggleBtn.style.setProperty('display', 'flex', 'important');
                }
                // „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Åã„ÇâÂÖ®ÂπÖ„ÇØ„É©„Çπ„ÇíÂâäÈô§
                if (mainContent) {
                    mainContent.classList.remove('full-width');
                }
            }
            
            console.log('Sidebar initialized:', sidebarHidden ? 'hidden' : 'visible');
        }
        
        // Close sidebar function for mobile overlay
        function closeSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            
            if (sidebar) {
                sidebar.classList.add('sidebar-hidden');
            }
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        // Enhanced toggle for mobile support
        function toggleSidebarMobile() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            
            if (!sidebar) return;
            
            const isHidden = sidebar.classList.contains('sidebar-hidden');
            
            if (isHidden) {
                sidebar.classList.remove('sidebar-hidden');
                if (overlay) overlay.style.display = 'block';
            } else {
                sidebar.classList.add('sidebar-hidden');
                if (overlay) overlay.style.display = 'none';
            }
        }
        
        // Make functions globally available
        window.toggleSidebar = toggleSidebar;
        window.toggleSidebarMobile = toggleSidebarMobile;
        window.closeSidebar = closeSidebar;
        window.initializeSidebarState = initializeSidebarState;
        
        // ============== END SIDEBAR TOGGLE FUNCTIONS ==============

        // ============== MOBILE MENU FUNCTIONS ==============
        
        // Toggle mobile menu screen (Èñã„Åè„ÉªÈñâ„Åò„Çã)
        function showMobileMenuScreen() {
            const mobileMenuScreen = document.getElementById('mobileMenuScreen');
            
            if (mobileMenuScreen) {
                if (mobileMenuScreen.classList.contains('hidden')) {
                    // „É°„Éã„É•„Éº„ÅåÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥ÂêàÔºöÈñã„Åè
                    const sections = document.querySelectorAll('.section');
                    sections.forEach(section => {
                        section.classList.add('hidden');
                    });
                    mobileMenuScreen.classList.remove('hidden');
                    
                    // üé® „Çµ„Ç§„Éâ„Éê„Éº„Éú„Çø„É≥„ÇíÁ¢∫ÂÆü„Å´Ë°®Á§∫Ôºà„É°„Ç§„É≥„Éà„Ç∞„É´„Éú„Çø„É≥„Å®Áµ±‰∏Ä„Çπ„Çø„Ç§„É´Ôºâ
                    setTimeout(() => {
                        const sidebarToggle = document.getElementById('sidebarMenuToggle');
                        const mobileToggle = document.getElementById('mobileMenuToggle');
                        
                        if (sidebarToggle && mobileToggle) {
                            const mobileStyle = window.getComputedStyle(mobileToggle);
                            sidebarToggle.removeAttribute('style');
                            const fullStyle = `position: absolute !important; top: 15px !important; left: 15px !important; z-index: 10002 !important; width: ${mobileStyle.width} !important; height: ${mobileStyle.height} !important; background: ${mobileStyle.backgroundColor} !important; border: ${mobileStyle.border} !important; border-radius: ${mobileStyle.borderRadius} !important; backdrop-filter: ${mobileStyle.backdropFilter} !important; display: flex !important; visibility: visible !important; align-items: center !important; justify-content: center !important; padding: 0 !important; margin: 0 !important; transition: none !important; cursor: pointer !important; font-size: 0 !important; box-shadow: ${mobileStyle.boxShadow} !important; transform: none !important; opacity: 1 !important;`;
                            sidebarToggle.setAttribute('style', fullStyle);
                            console.log('üé® Sidebar toggle button synced with main toggle when menu opened');
                        }
                    }, 50);
                } else {
                    // „É°„Éã„É•„Éº„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥ÂêàÔºöÈñâ„Åò„ÇãÔºà„É°„Ç§„É≥ÁîªÈù¢„Å´Êàª„ÇãÔºâ
                    mobileMenuScreen.classList.add('hidden');
                    showMainScreen();
                }
            }
        }
        
        // „É¢„Éê„Ç§„É´„É°„Éã„É•„Éº„ÇíÈñâ„Åò„Å¶„Åã„ÇâÊåáÂÆö„Åó„ÅüÈñ¢Êï∞„ÇíÂÆüË°å
        function closeMobileMenuAndExecute(callback) {
            const mobileMenuScreen = document.getElementById('mobileMenuScreen');
            if (mobileMenuScreen && !mobileMenuScreen.classList.contains('hidden')) {
                mobileMenuScreen.classList.add('hidden');
            }
            
            // „Ç≥„Éº„É´„Éê„ÉÉ„ÇØÈñ¢Êï∞„ÇíÂÆüË°å
            if (typeof callback === 'function') {
                callback();
            }
        }
        
        // Toggle mobile debug menu
        function toggleMobileDebugMenu() {
            const submenu = document.getElementById('mobileDebugSubmenu');
            const arrow = document.querySelector('.mobile-debug-arrow');
            
            if (submenu && arrow) {
                if (submenu.style.display === 'none' || submenu.style.display === '') {
                    submenu.style.display = 'block';
                    arrow.classList.add('rotated');
                } else {
                    submenu.style.display = 'none';
                    arrow.classList.remove('rotated');
                }
            }
        }
        
        // Make mobile menu functions globally available
        window.showMobileMenuScreen = showMobileMenuScreen;
        window.closeMobileMenuAndExecute = closeMobileMenuAndExecute;
        window.toggleMobileDebugMenu = toggleMobileDebugMenu;
        
        // ============== MOBILE SIDEBAR SIZE ADJUSTER ==============
        // CSSÁ´∂ÂêàËß£Ê±∫: JavaScriptÁõ¥Êé•„Çπ„Çø„Ç§„É´ÈÅ©Áî®„ÅßÁ¢∫ÂÆü„Å´„Çµ„Ç§„Ç∫1.2ÂÄçÂåñ
        function applyMobileSidebarDoubleSize() {
            console.log('üîß Applying mobile sidebar 1.2x size via JavaScript');
            
            // „Éò„ÉÉ„ÉÄ„Éº
            const header = document.querySelector('#mobileMenuScreen .mobile-sidebar-header');
            if (header) {
                header.style.setProperty('padding', '19.2px', 'important'); // 16px * 1.2
                header.style.setProperty('border-bottom', '1.2px solid rgba(255, 255, 255, 0.1)', 'important');
                header.style.setProperty('position', 'relative', 'important');
                header.style.setProperty('z-index', '10001', 'important'); // „Çµ„Ç§„Éâ„Éê„Éº„Çà„Çä‰∏ä
            }
            
            // „Çµ„Ç§„Éâ„Éê„ÉºËá™‰Ωì„ÅÆz-index„ÇíÁ¢∫ÂÆü„Å´Ë®≠ÂÆö
            const sidebar = document.querySelector('#mobileMenuScreen');
            if (sidebar) {
                sidebar.style.setProperty('z-index', '10000', 'important');
                sidebar.style.setProperty('position', 'fixed', 'important');
            }
            
            // „É°„Ç§„É≥„ÅÆ„Éà„Ç∞„É´„Éú„Çø„É≥„ÅÆ‰ΩçÁΩÆ„Å®z-index„ÇíË™øÊï¥ - üîß „Çπ„Éû„ÉõÁâà„Åß„ÅØÂ∑¶Á´Ø„Å´ÈÖçÁΩÆ
            const mainToggle = document.querySelector('.hamburger-menu, .mobile-menu-toggle');
            if (mainToggle) {
                mainToggle.style.setProperty('position', 'fixed', 'important');
                mainToggle.style.setProperty('top', '20px', 'important');
                mainToggle.style.setProperty('left', '20px', 'important'); // Âè≥Á´Ø„Åã„ÇâÂ∑¶Á´Ø„Å´Â§âÊõ¥
                mainToggle.style.setProperty('right', 'auto', 'important'); // Âè≥ÂÅ¥„ÅÆË®≠ÂÆö„Çí„É™„Çª„ÉÉ„Éà
                mainToggle.style.setProperty('z-index', '10002', 'important'); // ÊúÄ‰∏ä‰Ωç
                mainToggle.style.setProperty('background', 'rgba(0, 0, 0, 0.7)', 'important');
                mainToggle.style.setProperty('border-radius', '8px', 'important');
                mainToggle.style.setProperty('padding', '12px', 'important');
            }
            
            
            // „Çµ„Ç§„Éâ„Éê„ÉºÂÜÖ„ÅÆ‰∏çË¶Å„Å™ÁôΩ„ÅÑ„ÄåÊàª„Çã„Äç„Éú„Çø„É≥„ÅÆ„Åø„ÇíÂâäÈô§Ôºà„É°„Ç§„É≥„ÅÆ„Éà„Ç∞„É´„Éú„Çø„É≥„ÅØÊÆã„ÅôÔºâ
            const sidebarCloseBtn = document.querySelector('#mobileMenuScreen .mobile-sidebar-close-btn');
            if (sidebarCloseBtn) {
                sidebarCloseBtn.style.setProperty('display', 'none', 'important'); // ÁôΩ„ÅÑÊàª„Çã„Éú„Çø„É≥„ÅÆ„ÅøÈö†„Åô
            }
            
            // „ÇÇ„Åó„Åè„ÅØ„ÄÅ„Çµ„Ç§„Éâ„Éê„ÉºÂÜÖ„ÅÆÁôΩ„ÅÑ„Éú„Çø„É≥Ë¶ÅÁ¥†„ÇíÁâπÂÆö„Åó„Å¶ÂâäÈô§
            const whiteButtons = document.querySelectorAll('#mobileMenuScreen button[style*="background"], #mobileMenuScreen .btn-white, #mobileMenuScreen .close-button');
            whiteButtons.forEach(btn => {
                // „É°„Ç§„É≥„ÅÆ„Éà„Ç∞„É´„Éú„Çø„É≥„Å®Êñ∞„Åó„Åè‰Ωú„Å£„Åü„Çµ„Ç§„Éâ„Éê„Éº„Éà„Ç∞„É´„Åß„ÅØ„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÈùûË°®Á§∫
                if (!btn.classList.contains('mobile-menu-toggle') && 
                    !btn.classList.contains('hamburger-menu') && 
                    !btn.classList.contains('sidebar-toggle-btn')) {
                    btn.style.setProperty('display', 'none', 'important');
                }
            });
            
            // „Éè„É≥„Éê„Éº„Ç¨„Éº„É©„Ç§„É≥Ôºà„Éà„Ç∞„É´„Éú„Çø„É≥„ÅåÈùûË°®Á§∫„Å™„ÅÆ„Åß‰∏çË¶Å„Å†„Åå„ÄÅÂøµ„ÅÆ„Åü„ÇÅÔºâ
            const hamburgerLines = document.querySelectorAll('#mobileMenuScreen .mobile-menu-toggle-button .hamburger-line');
            hamburgerLines.forEach(line => {
                line.style.setProperty('display', 'none', 'important');
            });
            
            // „Ç≥„É≥„ÉÜ„É≥„ÉÑ
            const content = document.querySelector('#mobileMenuScreen .mobile-sidebar-content');
            if (content) {
                content.style.setProperty('padding', '28.8px 19.2px', 'important'); // 24px 16px * 1.2
                content.style.setProperty('height', 'calc(100vh - 60px)', 'important'); // „Éò„ÉÉ„ÉÄ„ÉºÈ´ò„ÅïË™øÊï¥
            }
            
            // „É°„Éã„É•„ÉºÈ†ÖÁõÆ
            const menuItems = document.querySelectorAll('#mobileMenuScreen .menu-item, #mobileMenuScreen .menu-item-double');
            menuItems.forEach(item => {
                item.style.setProperty('padding', '14.4px 19.2px', 'important'); // 12px 16px * 1.2
                item.style.setProperty('margin', '0 9.6px 4.8px 9.6px', 'important'); // 0 8px 4px 8px * 1.2
                item.style.setProperty('border-radius', '9.6px', 'important'); // 8px * 1.2
                item.style.setProperty('font-size', '16.8px', 'important'); // 14px * 1.2
                item.style.setProperty('min-height', '48px', 'important'); // 40px * 1.2
                item.style.setProperty('display', 'flex', 'important');
                item.style.setProperty('align-items', 'center', 'important');
            });
            
            // „É°„Éã„É•„Éº„Ç¢„Ç§„Ç≥„É≥
            const menuIcons = document.querySelectorAll('#mobileMenuScreen .menu-icon, #mobileMenuScreen .menu-icon-double');
            menuIcons.forEach(icon => {
                icon.style.setProperty('font-size', '13.2px', 'important'); // 11px * 1.2
                icon.style.setProperty('margin-right', '14.4px', 'important'); // 12px * 1.2
                icon.style.setProperty('min-width', '60px', 'important'); // 50px * 1.2
            });
            
            // „É°„Éã„É•„Éº„ÉÜ„Ç≠„Çπ„Éà
            const menuTexts = document.querySelectorAll('#mobileMenuScreen .menu-text, #mobileMenuScreen .menu-text-double');
            menuTexts.forEach(text => {
                text.style.setProperty('font-size', '16.8px', 'important'); // 14px * 1.2
                text.style.setProperty('font-weight', '500', 'important');
            });
            
            console.log('‚úÖ Mobile sidebar 1.2x size applied successfully with button hidden');
        }
        
        // ÂÖÉ„ÅÆshowMobileMenuScreenÈñ¢Êï∞„Çí„É©„ÉÉ„Éó„Åó„Å¶„ÄÅË°®Á§∫Âæå„Å´„Çµ„Ç§„Ç∫ÈÅ©Áî®
        const originalShowMobileMenuScreen = showMobileMenuScreen;
        showMobileMenuScreen = function() {
            const result = originalShowMobileMenuScreen();
            // Â∞ë„ÅóÈÅÖÂª∂„Åó„Å¶„Çπ„Çø„Ç§„É´ÈÅ©Áî®ÔºàDOMÊõ¥Êñ∞ÂÆå‰∫Ü„ÇíÂæÖ„Å§Ôºâ
            setTimeout(() => {
                applyMobileSidebarDoubleSize();
            }, 100);
            return result;
        };
        
        // „Éö„Éº„Ç∏„É≠„Éº„ÉâÊôÇ„Å´„ÇÇÈÅ©Áî®Ôºà„Åô„Åß„Å´Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥ÂêàÔºâ
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(applyMobileSidebarDoubleSize, 500);
        });
        
        // „Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞„Å®„Åó„Å¶ÂÖ¨Èñã
        window.applyMobileSidebarDoubleSize = applyMobileSidebarDoubleSize;
        
        // ============== END MOBILE MENU FUNCTIONS ==============

        // ============== NOTIFICATION FUNCTIONS ==============
        // ‚ö†Ô∏è ÈáçË¶Å: ÈÄöÁü•Ê©üËÉΩ„ÅÆÂÆüË£Ö
        // - toggleNotifications(): ÈÄöÁü•„Éë„Éç„É´„ÅÆË°®Á§∫/ÈùûË°®Á§∫
        // - addNotification(): Êñ∞„Åó„ÅÑÈÄöÁü•„ÅÆËøΩÂä†Ôºà„Éê„ÉÉ„Ç∏Êï∞Êõ¥Êñ∞„ÇÇÂê´„ÇÄÔºâ
        // - clearAllNotifications(): ÂÖ®ÈÄöÁü•„ÇØ„É™„Ç¢
        let notificationCount = 0;
        let notifications = [];

        function toggleNotifications() {
            console.log('ÈÄöÁü•„Çí„Éà„Ç∞„É´„Åó„Åæ„Åó„Åü');
            
            // Êó¢Â≠ò„ÅÆÈÄöÁü•„Éë„Éç„É´„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            let notificationPanel = document.getElementById('notificationPanel');
            
            if (notificationPanel) {
                // „Éë„Éç„É´„ÅåÊó¢„Å´Â≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØÂâäÈô§ÔºàÈùûË°®Á§∫Ôºâ
                notificationPanel.remove();
            } else {
                // „Éë„Éç„É´„ÇíÊñ∞Ë¶è‰ΩúÊàê„Åó„Å¶Ë°®Á§∫
                showNotificationPanel();
            }
        }

        function showNotificationPanel() {
            const notificationPanel = document.createElement('div');
            notificationPanel.id = 'notificationPanel';
            notificationPanel.className = 'notification-panel';
            notificationPanel.innerHTML = `
                <div class="notification-header">
                    <h3>ÈÄöÁü•</h3>
                    <button onclick="clearAllNotifications()" class="clear-all-btn">„Åô„Åπ„Å¶„ÇØ„É™„Ç¢</button>
                </div>
                <div class="notification-list" id="notificationList">
                    ${notifications.length > 0 ? 
                        notifications.map(notification => `
                            <div class="notification-item">
                                <div class="notification-content">
                                    <div class="notification-title">${notification.title}</div>
                                    <div class="notification-message">${notification.message}</div>
                                    <div class="notification-time">${notification.time}</div>
                                </div>
                            </div>
                        `).join('') : 
                        '<div class="notification-empty">ÈÄöÁü•„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>'
                    }
                </div>
            `;
            
            document.body.appendChild(notificationPanel);
            
            // „Éë„Éç„É´„ÅÆ‰ΩçÁΩÆ„ÇíË™øÊï¥
            const notificationBtn = document.querySelector('.notification-btn');
            const rect = notificationBtn.getBoundingClientRect();
            notificationPanel.style.top = (rect.bottom + 10) + 'px';
            notificationPanel.style.right = '10px';
        }

        function clearAllNotifications() {
            notifications = [];
            notificationCount = 0;
            updateNotificationBadge();
            
            const notificationPanel = document.getElementById('notificationPanel');
            if (notificationPanel) {
                notificationPanel.remove();
            }
        }

        function addNotification(title, message) {
            const notification = {
                title: title,
                message: message,
                time: new Date().toLocaleString('ja-JP')
            };
            
            notifications.unshift(notification); // Êñ∞„Åó„ÅÑÈÄöÁü•„ÇíÂÖàÈ†≠„Å´ËøΩÂä†
            notificationCount++;
            updateNotificationBadge();
            
            console.log('Êñ∞„Åó„ÅÑÈÄöÁü•„ÅåËøΩÂä†„Åï„Çå„Åæ„Åó„Åü:', notification);
        }

        function updateNotificationBadge() {
            const badge = document.getElementById('notificationBadge');
            if (badge) {
                if (notificationCount > 0) {
                    badge.textContent = notificationCount;
                    badge.style.display = 'flex';
                } else {
                    badge.style.display = 'none';
                }
            }
        }

        // Make notification functions globally available
        window.toggleNotifications = toggleNotifications;
        window.addNotification = addNotification;
        window.clearAllNotifications = clearAllNotifications;
        
        // ============== END NOTIFICATION FUNCTIONS ==============

    </script>
    
    <!-- Track Edit Modal -->
    <div id="trackEditModal" class="modal" style="display: none;">
        <div class="modal-content track-edit-modal">
            <div class="modal-header">
                <h2>Edit Track Information</h2>
                <button class="modal-close" onclick="closeTrackEditor()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="trackEditForm">
                    <div class="track-edit-field">
                        <label for="editTrackTitle">Track Title</label>
                        <input type="text" id="editTrackTitle" class="auth-input" placeholder="Enter track title..." maxlength="200" required>
                        <div class="field-info">Maximum 200 characters</div>
                    </div>
                    
                    <div class="track-edit-field">
                        <label for="editTrackDescription">Description</label>
                        <textarea id="editTrackDescription" class="auth-input" placeholder="Enter track description..." rows="4" maxlength="1000"></textarea>
                        <div class="field-info">Maximum 1000 characters. This will appear in search results and episode details.</div>
                    </div>
                    
                    <div class="track-edit-field">
                        <label for="editTrackGenre">Genre</label>
                        <select id="editTrackGenre" class="auth-input">
                            <option value="">Select genre (optional)</option>
                            <option value="technology">Technology</option>
                            <option value="business">Business</option>
                            <option value="education">Education</option>
                            <option value="entertainment">Entertainment</option>
                            <option value="news">News</option>
                            <option value="health">Health & Wellness</option>
                            <option value="arts">Arts & Culture</option>
                            <option value="sports">Sports</option>
                            <option value="science">Science</option>
                            <option value="music">Music</option>
                            <option value="comedy">Comedy</option>
                            <option value="other">Other</option>
                        </select>
                        <div class="field-info">Help users discover your content by selecting a relevant genre</div>
                    </div>
                    
                    <div class="track-edit-field">
                        <label for="editTrackTags">Tags</label>
                        <input type="text" id="editTrackTags" class="auth-input" placeholder="ai, technology, podcast (comma-separated)" maxlength="200">
                        <div class="field-info">Add relevant tags separated by commas. Maximum 200 characters.</div>
                    </div>
                    
                    <div class="track-edit-privacy">
                        <h3>Settings</h3>
                        <div class="privacy-item">
                            <div class="privacy-info">
                                <h4>Allow Downloads</h4>
                                <p>Let users download this track for offline listening</p>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="editTrackDownloadable">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="auth-button secondary" onclick="closeTrackEditor()">Cancel</button>
                <button type="button" class="auth-button" onclick="saveTrackChanges()" id="saveTrackBtn">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Playlist Manager Modal -->
    <div id="playlistModal" class="modal" style="display: none;">
        <div class="modal-content playlist-modal">
            <div class="modal-header">
                <h2>„Éó„É¨„Ç§„É™„Çπ„ÉàÁÆ°ÁêÜ</h2>
                <button class="modal-close" onclick="window.closePlaylistManager()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="playlist-manager">
                    <div class="playlist-controls">
                        <button class="action-btn playlist-create-btn" onclick="createNewPlaylist()" style="background: rgba(159, 247, 234, 0.1); border: 1px solid var(--accent); color: var(--accent); display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; width: auto; height: auto; font-size: 12px; font-weight: 500; border-radius: 4px;">
                            <span class="btn-icon">+</span>
                            Êñ∞„Åó„ÅÑ„Éó„É¨„Ç§„É™„Çπ„Éà
                        </button>
                        <div class="search-container">
                            <input type="text" id="playlistSearchBar" placeholder="„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÊ§úÁ¥¢..." class="auth-input">
                        </div>
                    </div>
                    
                    <div class="playlist-list" id="playlistList">
                        <!-- Playlists will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Playlist Modal -->
    <div id="createPlaylistModal" class="modal" style="display: none;">
        <div class="modal-content create-playlist-modal">
            <div class="modal-header">
                <h2></h2>
                <button class="modal-close" onclick="closeCreatePlaylist()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="createPlaylistForm" onsubmit="window.submitCreatePlaylist(event)">
                    <div class="form-group">
                        <label>„Éó„É¨„Ç§„É™„Çπ„ÉàÂêç *</label>
                        <input type="text" id="playlistName" class="auth-input" placeholder="„Éó„É¨„Ç§„É™„Çπ„ÉàÂêç„ÇíÂÖ•Âäõ" required maxlength="100">
                    </div>
                    
                    <div class="form-group">
                        <label>Ë™¨Êòé</label>
                        <textarea id="playlistDescription" class="auth-input" placeholder="„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆË™¨ÊòéÔºà‰ªªÊÑèÔºâ" maxlength="500" rows="3"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>„Ç¢„Ç§„Ç≥„É≥</label>
                        <div class="emoji-selector">
                            <button type="button" class="emoji-option active" data-emoji="üéß">üéß</button>
                            <button type="button" class="emoji-option" data-emoji="üéµ">üéµ</button>
                            <button type="button" class="emoji-option" data-emoji="üéôÔ∏è">üéôÔ∏è</button>
                            <button type="button" class="emoji-option" data-emoji="üìª">üìª</button>
                            <button type="button" class="emoji-option" data-emoji="üé∂">üé∂</button>
                            <button type="button" class="emoji-option" data-emoji="‚ú®">‚ú®</button>
                            <button type="button" class="emoji-option" data-emoji="üåê">üåê</button>
                            <button type="button" class="emoji-option" data-emoji="üìö">üìö</button>
                            <button type="button" class="emoji-option" data-emoji="üöÄ">üöÄ</button>
                            <button type="button" class="emoji-option" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</button>
                            <button type="button" class="emoji-option" data-emoji="üî•">üî•</button>
                            <button type="button" class="emoji-option" data-emoji="üåü">üåü</button>
                        </div>
                        <input type="hidden" id="selectedEmoji" value="">
                    </div>
                    
                    <div class="form-group">
                        <div class="visibility-toggle">
                            <input type="checkbox" id="playlistIsPrivate" class="toggle-checkbox">
                            <label for="playlistIsPrivate" class="toggle-label">
                                <span class="visibility-icon"></span>
                                <span class="visibility-text"></span>
                            </label>
                            <div class="visibility-description"></div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="auth-button secondary" onclick="window.closeCreatePlaylist()">„Ç≠„É£„É≥„Çª„É´</button>
                <button type="button" class="auth-button" onclick="window.submitCreatePlaylist(event)">‰ΩúÊàê</button>
            </div>
        </div>
    </div>

    <!-- Add to Playlist Modal -->
    <div id="addToPlaylistModal" class="modal" style="display: none;">
        <div class="modal-content add-playlist-modal">
            <div class="modal-header">
                <h2>„Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†</h2>
                <button class="modal-close" onclick="closeAddToPlaylistModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="selected-track-info">
                    <h3 id="selectedTrackTitle">ÈÅ∏Êäû‰∏≠„ÅÆ„Éà„É©„ÉÉ„ÇØ</h3>
                    <p>ËøΩÂä†ÂÖà„ÅÆ„Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                </div>
                <div id="playlistListForAdding" class="playlist-list">
                    <div class="loading-item">...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="auth-button secondary" onclick="closeAddToPlaylistModal()">„Ç≠„É£„É≥„Çª„É´</button>
                <button type="button" id="confirmAddToPlaylistBtn" class="auth-button disabled" onclick="confirmAddToPlaylist()" disabled>ËøΩÂä†</button>
                <!-- Button text section -->
            </div>
        </div>
    </div>

    <!-- Podcast Playlist Manager Modal -->
    <div id="podcastPlaylistModal" class="modal" style="display: none;">
        <div class="modal-content podcast-playlist-modal">
            <div class="modal-header">
                <h2>üéôÔ∏è „Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„ÉàÁÆ°ÁêÜ</h2>
                <button class="modal-close" onclick="closePodcastPlaylistManager()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="playlist-manager">
                    <div class="playlist-controls">
                        <button class="auth-button" onclick="createNewPodcastPlaylist()">
                            <span>+</span> Êñ∞„Åó„ÅÑ„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà‰ΩúÊàê
                        </button>
                    </div>
                    <div id="podcastPlaylistsList" class="playlists-list">
                        <div class="loading-item">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="auth-button secondary" onclick="closePodcastPlaylistManager()">Èñâ„Åò„Çã</button>
            </div>
        </div>
    </div>

    <!-- Create Podcast Playlist Modal -->
    <div id="createPodcastPlaylistModal" class="modal" style="display: none;">
        <div class="modal-content create-playlist-modal">
            <div class="modal-header">
                <h2>üéôÔ∏è „Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà‰ΩúÊàê</h2>
                <button class="modal-close" onclick="closeCreatePodcastPlaylist()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="createPodcastPlaylistForm">
                    <div class="form-group">
                        <label>„Éó„É¨„Ç§„É™„Çπ„ÉàÂêç *</label>
                        <input type="text" id="podcastPlaylistName" placeholder="‰æã: „ÅäÊ∞ó„Å´ÂÖ•„Çä„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà" required>
                    </div>
                    <div class="form-group">
                        <label>Ë™¨Êòé</label>
                        <textarea id="podcastPlaylistDescription" placeholder="„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆË™¨Êòé„ÇíÂÖ•ÂäõÔºà‰ªªÊÑèÔºâ" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label>ÁµµÊñáÂ≠ó</label>
                        <div class="emoji-selector">
                            <button type="button" class="emoji-btn" onclick="selectPodcastPlaylistEmoji('üéôÔ∏è')">üéôÔ∏è</button>
                            <button type="button" class="emoji-btn" onclick="selectPodcastPlaylistEmoji('üìª')">üìª</button>
                            <button type="button" class="emoji-btn" onclick="selectPodcastPlaylistEmoji('üéß')">üéß</button>
                            <button type="button" class="emoji-btn" onclick="selectPodcastPlaylistEmoji('üìÇ')">üìÇ</button>
                            <button type="button" class="emoji-btn" onclick="selectPodcastPlaylistEmoji('‚≠ê')">‚≠ê</button>
                            <button type="button" class="emoji-btn" onclick="selectPodcastPlaylistEmoji('üî•')">üî•</button>
                            <button type="button" class="emoji-btn" onclick="selectPodcastPlaylistEmoji('üíº')">üíº</button>
                            <button type="button" class="emoji-btn" onclick="selectPodcastPlaylistEmoji('üéØ')">üéØ</button>
                        </div>
                        <input type="hidden" id="selectedPodcastPlaylistEmoji" value="üéôÔ∏è">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="auth-button secondary" onclick="closeCreatePodcastPlaylist()">„Ç≠„É£„É≥„Çª„É´</button>
                <button type="button" class="auth-button" onclick="submitCreatePodcastPlaylist()">‰ΩúÊàê</button>
            </div>
        </div>
    </div>

    <!-- Add to Podcast Playlist Modal -->
    <div id="addToPodcastPlaylistModal" class="modal" style="display: none;">
        <div class="modal-content add-playlist-modal">
            <div class="modal-header">
                <h2>üéôÔ∏è „Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†</h2>
                <button class="modal-close" onclick="closeAddToPodcastPlaylistModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="selected-track-info">
                    <h3 id="selectedPodcastTitle">ÈÅ∏Êäû‰∏≠„ÅÆ„Ç®„Éî„ÇΩ„Éº„Éâ</h3>
                    <p>ËøΩÂä†ÂÖà„ÅÆ„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                </div>
                <div id="podcastPlaylistsForAdding" class="playlists-grid">
                    <div class="loading-item">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà „Éó„É¨„Ç§„É™„Çπ„Éà„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="auth-button secondary" onclick="closeAddToPodcastPlaylistModal()">„Ç≠„É£„É≥„Çª„É´</button>
                <button type="button" id="confirmAddToPodcastPlaylistBtn" class="auth-button disabled" onclick="confirmAddToPodcastPlaylist()" disabled>ËøΩÂä†</button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal" style="display: none;">
        <div class="modal-content confirmation-modal">
            <div class="modal-header">
                <h2 id="confirmTitle"></h2>
                <button class="modal-close" onclick="closeConfirmationModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="confirmation-content">
                    <p id="confirmMessage" class="confirm-message"></p>
                    <div id="confirmWarning" class="confirm-warning" style="display: none;"></div>
                </div>
                <div id="confirmSkipContainer" class="confirm-skip-container" style="display: none;">
                    <label class="skip-checkbox-label">
                        <input type="checkbox" id="confirmSkipCheckbox">
                        <span></span>
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" id="confirmCancelBtn" class="auth-button secondary" onclick="cancelAction()">„Ç≠„É£„É≥„Çª„É´</button>
                <button type="button" id="confirmActionBtn" class="auth-button danger" onclick="confirmAction()">ÂâäÈô§</button>
            </div>
        </div>
    </div>

    <script>
        // Sidebar toggle functionality
        document.getElementById('menuToggle').addEventListener('click', function() {
            const sidebar = document.getElementById('sidebar');
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // „É¢„Éê„Ç§„É´Áâà: open „ÇØ„É©„Çπ„Åß„Çµ„Ç§„Éâ„Éê„Éº„ÇíË°®Á§∫/ÈùûË°®Á§∫
                sidebar.classList.toggle('open');
                toggleMobileOverlay();
            } else {
                // „Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÁâà: collapsed „ÇØ„É©„Çπ„Åß„Çµ„Ç§„Éâ„Éê„Éº„ÇíÊäò„Çä„Åü„Åü„Åø
                sidebar.classList.toggle('collapsed');
            }
        });

        // „É¢„Éê„Ç§„É´Áâà„Ç™„Éº„Éê„Éº„É¨„Ç§Âà∂Âæ°
        function toggleMobileOverlay() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobileOverlay') || createMobileOverlay();
            
            if (sidebar.classList.contains('open')) {
                overlay.style.display = 'block';
            } else {
                overlay.style.display = 'none';
            }
        }

        function createMobileOverlay() {
            const overlay = document.createElement('div');
            overlay.id = 'mobileOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 99;
                display: none;
            `;
            
            overlay.addEventListener('click', function() {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.remove('open');
                toggleMobileOverlay();
            });
            
            document.body.appendChild(overlay);
            return overlay;
        }

        // Update active menu item
        function updateActiveMenuItem(activeId) {
            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Set active based on current screen
            const menuItems = document.querySelectorAll('.menu-item');
            if (activeId === 'home') menuItems[0].classList.add('active');
            else if (activeId === 'playlist') menuItems[1].classList.add('active');
            else if (activeId === 'library') menuItems[2].classList.add('active');
            else if (activeId === 'search') menuItems[3].classList.add('active');
            else if (activeId === 'profile') menuItems[4].classList.add('active');
        }

        // Override existing screen functions to update menu
        const originalShowMainScreen = window.showMainScreen;
        window.showMainScreen = function() {
            if (originalShowMainScreen) originalShowMainScreen();
            updateActiveMenuItem('home');
        };

        const originalShowLibraryScreen = window.showLibraryScreen;
        window.showLibraryScreen = function() {
            if (originalShowLibraryScreen) originalShowLibraryScreen();
            updateActiveMenuItem('library');
        };

        const originalShowProfileScreen = window.showProfileScreen;
        window.showProfileScreen = function(event) {
            if (originalShowProfileScreen) originalShowProfileScreen(event);
            updateActiveMenuItem('profile');
        };

        const originalOpenPlaylistManager = window.openPlaylistManager;
        window.openPlaylistManager = function() {
            if (originalOpenPlaylistManager) originalOpenPlaylistManager();
            updateActiveMenuItem('playlist');
        };

        const originalOpenUserSearchModal = window.openUserSearchModal;
        window.openUserSearchModal = function() {
            if (originalOpenUserSearchModal) originalOpenUserSearchModal();
            updateActiveMenuItem('search');
        };
    </script>

    <script>
        // Êó•Êú¨Ë™û„Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„ÉàÂàùÊúüÂåñÈñ¢Êï∞
        function initializeButtonTexts() {
            // „É≠„Ç∞„Ç§„É≥ÁîªÈù¢„ÅÆ„Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„Éà
            const loginText = document.getElementById('loginText');
            if (loginText) {
                loginText.textContent = '„É≠„Ç∞„Ç§„É≥';
            }
            
            const registerText = document.getElementById('registerText');
            if (registerText) {
                registerText.textContent = 'Êñ∞Ë¶èÁôªÈå≤';
            }
            
            // „Åù„ÅÆ‰ªñ„ÅÆ„Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇÇË®≠ÂÆö
            const logoutBtn = document.getElementById('logoutBtn');
            if (logoutBtn) {
                logoutBtn.textContent = '„É≠„Ç∞„Ç¢„Ç¶„Éà';
            }
            
            // console.log('Êó•Êú¨Ë™û„Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åó„Åü');
        }

        // Podcast Library Functions - Updated to add to music playlists
        window.addToPodcastLibrary = async function(episodeId, title, description) {
            if (!currentUser) {
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Å´ËøΩÂä†„Åô„Çã„Å´„ÅØ„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'warning');
                return;
            }
            
            try {
                showMessage('Èü≥Ê•Ω„Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†‰∏≠...', 'info');
                
                const token = await currentUser.getIdToken();
                
                // First, get or create "„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà" playlist in music playlists
                let playlistsResponse = await fetch('/api/playlists', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (!playlistsResponse.ok) {
                    throw new Error('„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                }
                
                const playlistsData = await playlistsResponse.json();
                console.log('Playlists API response:', playlistsData);
                
                // Handle different response formats
                const playlists = Array.isArray(playlistsData) ? playlistsData : 
                                 (playlistsData.playlists ? playlistsData.playlists : []);
                                 
                console.log('Processed playlists:', playlists);
                
                // Ensure each playlist has proper ID field
                if (Array.isArray(playlists)) {
                    playlists.forEach(playlist => {
                        if (!playlist.id && playlist.playlistId) {
                            playlist.id = playlist.playlistId;
                        }
                    });
                }
                
                let podcastPlaylist = Array.isArray(playlists) ? 
                    playlists.find(p => p.name === '„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà' || p.name === 'Podcasts') : null;
                
                // Create podcast playlist if it doesn't exist
                if (!podcastPlaylist) {
                    const createResponse = await fetch('/api/playlists', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({
                            name: '„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà',
                            description: '„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„Ç®„Éî„ÇΩ„Éº„ÉâÈõÜ',
                            isPodcast: true
                        })
                    });
                    
                    if (!createResponse.ok) {
                        throw new Error('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„Éó„É¨„Ç§„É™„Çπ„Éà„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                    }
                    
                    const createResult = await createResponse.json();
                    console.log('üÜï Create playlist result:', createResult);
                    
                    // Handle different possible ID field names from API response
                    const createdPlaylistId = createResult.playlistId || createResult.id || createResult._id;
                    
                    podcastPlaylist = {
                        id: createdPlaylistId,
                        playlistId: createdPlaylistId,
                        name: createResult.name || '„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà'
                    };
                    
                    console.log('üÜï Created playlist object:', podcastPlaylist);
                }
                
                // Add podcast episode directly to playlist using custom endpoint
                // Debug: Check all possible ID fields in playlist object
                console.log('üîç Playlist object keys:', Object.keys(podcastPlaylist));
                console.log('üîç Playlist object:', podcastPlaylist);
                
                const playlistId = podcastPlaylist.id || podcastPlaylist.playlistId || podcastPlaylist._id || podcastPlaylist.documentId;
                console.log('Using playlist ID:', playlistId);
                
                if (!playlistId) {
                    console.error('‚ùå No valid playlist ID found!');
                    throw new Error('„Éó„É¨„Ç§„É™„Çπ„ÉàID„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                }
                
                // Get episode data from search results for audio URL and podcast name
                const episodeData = window.currentPodcastSearchResults?.find(ep => ep.id === episodeId);
                
                const podcastEpisodeData = {
                    episodeId: episodeId,
                    title: title,
                    description: description,
                    audioUrl: episodeData?.audio_url || '',
                    podcastName: episodeData?.podcast_name || '',
                    type: 'podcast',
                    addedAt: new Date().toISOString()
                };
                
                console.log('üéß Episode data being sent:', podcastEpisodeData);
                
                console.log('Adding podcast episode to playlist:', podcastEpisodeData);
                const addTrackResponse = await fetch('/api/playlists/' + playlistId + '/podcast-episodes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(podcastEpisodeData)
                });
                
                if (addTrackResponse.ok) {
                    showMessage(`"${title}" „ÇíÈü≥Ê•Ω„Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†„Åó„Åæ„Åó„Åü`, 'success');
                    
                    // Update library display if currently shown
                    if (typeof loadLibraryTracks === 'function') {
                        loadLibraryTracks();
                    }
                    
                    // Also try the podcast-specific endpoint for compatibility
                    try {
                        const podcastResponse = await fetch('/api/podcast-library/add', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({
                                episodeId: episodeId,
                                title: title,
                                description: description,
                                addedAt: new Date().toISOString()
                            })
                        });
                        
                        if (podcastResponse.ok && document.getElementById('podcastLibraryResults')?.style.display !== 'none') {
                            if (typeof loadPodcastLibrary === 'function') {
                                try {
                                    loadPodcastLibrary();
                                } catch (err) {
                                    console.log('loadPodcastLibrary error (safe to ignore):', err.message);
                                }
                            }
                        }
                    } catch (err) {
                        console.log('Podcast-specific endpoint not available, using music playlist only');
                    }
                    
                } else {
                    if (addTrackResponse.status === 409) {
                        showMessage('„Åì„ÅÆ„Ç®„Éî„ÇΩ„Éº„Éâ„ÅØÊó¢„Å´„Éó„É¨„Ç§„É™„Çπ„Éà„Å´ËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„Åô', 'info');
                        
                        // 409„Ç®„É©„Éº„Åß„ÇÇ„ÄÅ„É©„Ç§„Éñ„É©„É™Ë°®Á§∫„ÇíÊõ¥Êñ∞„Åó„Å¶Êó¢Â≠ò„ÅÆ„Éà„É©„ÉÉ„ÇØ„ÇíÁ¢∫Ë™ç„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã
                        if (typeof loadLibraryTracks === 'function') {
                            loadLibraryTracks();
                        }
                        
                        // „Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„ÇÇÊõ¥Êñ∞
                        if (document.getElementById('podcastLibraryResults')?.style.display !== 'none') {
                            if (typeof loadPodcastLibrary === 'function') {
                                try {
                                    loadPodcastLibrary();
                                } catch (err) {
                                    console.log('loadPodcastLibrary error (safe to ignore):', err.message);
                                }
                            }
                        }
                        return; // 409„Ç®„É©„Éº„ÅØÊ≠£Â∏∏„Å™Áä∂ÊÖã„Å®„Åó„Å¶Âá¶ÁêÜ
                    } else {
                        const error = await addTrackResponse.json();
                        throw new Error(error.message || 'Failed to add to playlist');
                    }
                }
            } catch (error) {
                console.error('Error adding podcast to music playlist:', error);
                showMessage('„Éó„É¨„Ç§„É™„Çπ„Éà„Å∏„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Clean function for podcast library addition - prevents text mixing
        window.addToPodcastLibraryClean = async function(episodeId, buttonElement) {
            try {
                console.log('üéôÔ∏è Clean podcast library addition:', episodeId);
                
                // Get episode data directly from the episodes array, not from DOM
                const episode = window.currentEpisodesData?.find(ep => ep.trackId === episodeId);
                if (!episode) {
                    console.error('Episode not found in data:', episodeId);
                    showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                const title = episode.title || 'Unknown Title';
                const description = episode.description || '';
                
                console.log('üéôÔ∏è Adding to library:', { title, description });
                
                await addToPodcastLibrary(episodeId, title, description);
            } catch (error) {
                console.error('Error in clean podcast library addition:', error);
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Å∏„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Clean function for episode download - prevents text mixing
        window.downloadEpisodeClean = async function(episodeId, buttonElement) {
            try {
                console.log('üì• Clean episode download:', episodeId);
                
                // Get episode data directly from the episodes array
                const episode = window.currentEpisodesData?.find(ep => ep.trackId === episodeId);
                if (!episode) {
                    console.error('Episode not found in data:', episodeId);
                    showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                console.log('üì• Downloading episode:', episode.title);
                
                // Call existing download function if it exists
                if (typeof downloadTrack === 'function') {
                    await downloadTrack(episodeId, episode.title, episode.description || '');
                } else {
                    console.warn('Download function not found');
                    showMessage('„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÊ©üËÉΩ„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì', 'error');
                }
            } catch (error) {
                console.error('Error in clean episode download:', error);
                showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Main podcast library addition function
        async function addToPodcastLibrary(episodeId, title, description) {
            if (!currentUser) {
                showMessage('„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'error');
                return;
            }

            try {
                // Show loading state
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Å´ËøΩÂä†‰∏≠...', 'info');

                // Get episode data from the search results
                const episode = window.currentPodcastSearchResults?.find(ep => ep.id === episodeId);
                if (!episode) {
                    console.error('Episode not found in search results:', episodeId);
                    showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }

                // Get user's podcast playlists to find "My Library" or create one
                const response = await fetch('/api/podcast-playlists', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to get playlists: ${response.status}`);
                }

                let playlists = await response.json();
                let myLibraryPlaylist = playlists.find(p => p.name === '„Éû„Ç§„É©„Ç§„Éñ„É©„É™' || p.name === 'My Library');

                // Create "My Library" playlist if it doesn't exist
                if (!myLibraryPlaylist) {
                    const createResponse = await fetch('/api/podcast-playlists', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${await currentUser.getIdToken()}`
                        },
                        body: JSON.stringify({
                            name: '„Éû„Ç§„É©„Ç§„Éñ„É©„É™',
                            description: '„Éá„Éï„Ç©„É´„Éà„ÅÆ„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™'
                        })
                    });

                    if (!createResponse.ok) {
                        throw new Error(`Failed to create library: ${createResponse.status}`);
                    }

                    myLibraryPlaylist = await createResponse.json();
                }

                // Add episode to the library playlist
                const addResponse = await fetch(`/api/podcast-playlists/${myLibraryPlaylist.id}/episodes`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${await currentUser.getIdToken()}`
                    },
                    body: JSON.stringify({
                        episode_id: episodeId,
                        title: episode.title || title,
                        description: episode.description || description,
                        audio_url: episode.audio_url,
                        podcast_name: episode.podcast_name,
                        duration: episode.duration,
                        published_date: episode.published_date
                    })
                });

                if (!addResponse.ok) {
                    throw new Error(`Failed to add episode: ${addResponse.status}`);
                }

                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Å´ËøΩÂä†„Åó„Åæ„Åó„Åü', 'success');
                console.log('‚úÖ Episode added to podcast library successfully');

            } catch (error) {
                console.error('Error adding to podcast library:', error);
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Å∏„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }

        // Simple podcast library addition function to prevent text mixing
        window.addToPodcastLibrarySimple = async function(buttonElement) {
            try {
                const episodeId = buttonElement.getAttribute('data-episode-id');
                if (!episodeId) {
                    console.error('Episode ID not found');
                    showMessage('„Ç®„Éî„ÇΩ„Éº„ÉâID„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                // Get episode data from the search results
                const episode = window.currentPodcastSearchResults?.find(ep => ep.id === episodeId);
                if (!episode) {
                    console.error('Episode not found in search results:', episodeId);
                    showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                // Call the existing function with clean data
                await addToPodcastLibrary(episodeId, episode.title, episode.description || '');
                
            } catch (error) {
                console.error('Error in simple podcast library addition:', error);
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Å∏„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Simple podcast episode play function to prevent text mixing
        window.playPodcastEpisodeSimple = function(buttonElement) {
            try {
                const episodeId = buttonElement.getAttribute('data-episode-id');
                if (!episodeId) {
                    console.error('Episode ID not found');
                    showMessage('„Ç®„Éî„ÇΩ„Éº„ÉâID„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                // Get episode data from the search results
                const episode = window.currentPodcastSearchResults?.find(ep => ep.id === episodeId);
                if (!episode) {
                    console.error('Episode not found in search results:', episodeId);
                    showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                // Call the existing function with clean data
                playPodcastEpisode(episode.audio_url, episode.title, episode.podcast_name);
                
            } catch (error) {
                console.error('Error in simple podcast episode play:', error);
                showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„ÅÆÂÜçÁîü„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Simple podcast episode download function to prevent text mixing
        window.downloadPodcastEpisodeSimple = async function(buttonElement) {
            try {
                const episodeId = buttonElement.getAttribute('data-episode-id');
                if (!episodeId) {
                    console.error('Episode ID not found');
                    showMessage('„Ç®„Éî„ÇΩ„Éº„ÉâID„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                // Get episode data from the search results
                const episode = window.currentPodcastSearchResults?.find(ep => ep.id === episodeId);
                if (!episode) {
                    console.error('Episode not found in search results:', episodeId);
                    showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                // Call the existing function with clean data
                await downloadPodcastEpisode(
                    episodeId, 
                    episode.audio_url, 
                    episode.title, 
                    episode.description || '', 
                    episode.podcast_name
                );
                
            } catch (error) {
                console.error('Error in simple podcast episode download:', error);
                showMessage('„Ç®„Éî„ÇΩ„Éº„Éâ„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // New function to handle menu-based podcast library addition (deprecated)
        window.addToPodcastLibraryFromMenu = async function(buttonElement, episodeId) {
            // Find the episode data from the DOM
            const episodeCard = buttonElement.closest('.episode-card');
            if (!episodeCard) return;
            
            // Extract title and description from the episode card
            const titleElement = episodeCard.querySelector('.episode-title, h3, .title');
            const descElement = episodeCard.querySelector('.episode-description, .description, p');
            
            const title = titleElement ? titleElement.textContent.trim() : 'Unknown Title';
            const description = descElement ? descElement.textContent.trim() : '';
            
            // Call the existing function with extracted data
            await addToPodcastLibrary(episodeId, title, description);
        }
        
        function showSavedPodcasts() {
            loadPodcastLibrary('podcasts');
        }
        
        function showSavedEpisodes() {
            loadPodcastLibrary('episodes');
        }
        
        function showPodcastPlaylists() {
            loadPodcastLibrary('playlists');
        }
        
        function showAutoDownloadSettings() {
            loadPodcastLibrary('settings');
        }
        
        async function loadPodcastLibrary(view = 'episodes') {
            if (!currentUser) {
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„ÇíË°®Á§∫„Åô„Çã„Å´„ÅØ„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'warning');
                return;
            }
            
            const resultsContainer = document.getElementById('podcastLibraryResults');
            const emptyState = document.getElementById('emptyPodcastLibraryState');
            
            // Safe check for resultsContainer
            if (!resultsContainer) {
                console.log('podcastLibraryResults element not found, skipping library update');
                return;
            }
            
            try {
                resultsContainer.innerHTML = '<div class="loading-item">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>';
                
                const token = await firebaseAuth.getIdToken();
                const response = await fetch(`/api/podcast-library?view=${view}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.items && data.items.length > 0) {
                        emptyState.style.display = 'none';
                        displayPodcastLibraryItems(data.items, view);
                    } else {
                        emptyState.style.display = 'block';
                        resultsContainer.innerHTML = '';
                    }
                } else {
                    throw new Error('Failed to load podcast library');
                }
            } catch (error) {
                console.error('Error loading podcast library:', error);
                resultsContainer.innerHTML = '<div class="error-message">„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</div>';
            }
        }
        
        function displayPodcastLibraryItems(items, view) {
            const resultsContainer = document.getElementById('podcastLibraryResults');
            
            // Safe check for resultsContainer
            if (!resultsContainer) {
                console.log('podcastLibraryResults element not found in displayPodcastLibraryItems, skipping');
                return;
            }
            
            let html = '<div class="podcast-library-items">';
            items.forEach(item => {
                const addedDate = new Date(item.addedAt || item.created_at).toLocaleDateString('ja-JP');
                
                html += `
                    <div class="podcast-library-item" style="display: flex; align-items: center; padding: 15px; margin-bottom: 15px; background: var(--panel); border-radius: 8px; border-left: 3px solid var(--accent);">
                        <div class="podcast-item-icon" style="font-size: 2em; margin-right: 15px;">üéôÔ∏è</div>
                        <div class="podcast-item-info" style="flex: 1;">
                            <h4 style="margin: 0 0 5px 0; color: var(--text);">${item.title || 'Unknown Title'}</h4>
                            <p style="margin: 0 0 5px 0; opacity: 0.8; font-size: 0.9em;">${(item.description || 'No description').substring(0, 100)}${(item.description && item.description.length > 100) ? '...' : ''}</p>
                            <div style="font-size: 0.8em; opacity: 0.6;">ËøΩÂä†Êó•: ${addedDate}</div>
                        </div>
                        <div class="podcast-item-actions" style="display: flex; gap: 10px;">
                            <button onclick="playEpisode('${item.episodeId}', ${JSON.stringify(item).replace(/"/g, '&quot;')})" class="play-btn" style="padding: 8px 15px; background: var(--accent); color: var(--bg); border: none; border-radius: 5px; cursor: pointer;">
                                ‚ñ∂ ÂÜçÁîü
                            </button>
                            <button onclick="removeFromPodcastLibrary('${item.episodeId}', '${item.title}')" class="remove-btn" style="padding: 8px 15px; background: var(--danger); color: white; border: none; border-radius: 5px; cursor: pointer;">
                                ÂâäÈô§
                            </button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            resultsContainer.innerHTML = html;
        }
        
        async function removeFromPodcastLibrary(episodeId, title) {
            if (!currentUser) {
                showMessage('„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô', 'warning');
                return;
            }
            
            if (!confirm(`"${title}" „Çí„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Åã„ÇâÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) {
                return;
            }
            
            try {
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Åã„ÇâÂâäÈô§‰∏≠...', 'info');
                
                const token = await firebaseAuth.getIdToken();
                const response = await fetch(`/api/podcast-library/${episodeId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    showMessage(`"${title}" „Çí„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Åã„ÇâÂâäÈô§„Åó„Åæ„Åó„Åü`, 'success');
                    loadPodcastLibrary(); // Refresh the library view
                } else {
                    throw new Error('Failed to remove from podcast library');
                }
            } catch (error) {
                console.error('Error removing from podcast library:', error);
                showMessage('„Éù„ÉÉ„Éâ„Ç≠„É£„Çπ„Éà„É©„Ç§„Éñ„É©„É™„Åã„Çâ„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        }

        // Debug functions removed for production

        // Êó•Êú¨Ë™û„ÉÜ„Ç≠„Çπ„ÉàÂàùÊúüÂåñ„ÅÆÂÆüË°å„Å®Êñ∞„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM: Ready, starting new initialization system');
            
            // „Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÂàùÊúüÂåñ„ÇíÂ∞ë„ÅóÈÅÖ„Çâ„Åõ„Å¶Á¢∫ÂÆü„Å´ÂÆüË°å
            setTimeout(() => {
                if (typeof initializeButtonTexts === 'function') {
                    initializeButtonTexts();
                    console.log('Êó•Êú¨Ë™û„Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅåÂàùÊúüÂåñ„Åï„Çå„Åæ„Åó„Åü');
                }
            }, 100);
            
            // üé® „Çµ„Ç§„Éâ„Éê„ÉºÂÜÖ„Éà„Ç∞„É´„Éú„Çø„É≥„ÅÆÂº∑Âà∂Ë°®Á§∫Ôºà„É°„Ç§„É≥„Éà„Ç∞„É´„Éú„Çø„É≥„Å®ÂÆåÂÖ®Áµ±‰∏ÄÔºâ
            const forceSidebarToggleDisplay = () => {
                const sidebarToggle = document.getElementById('sidebarMenuToggle');
                const mobileToggle = document.getElementById('mobileMenuToggle');
                
                if (sidebarToggle && mobileToggle) {
                    // „É°„Ç§„É≥„Éà„Ç∞„É´„Éú„Çø„É≥„ÅÆcomputedStyle„ÇíÂèñÂæó
                    const mobileStyle = window.getComputedStyle(mobileToggle);
                    
                    // ÂÆåÂÖ®„Å´„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
                    sidebarToggle.removeAttribute('style');
                    
                    // „É°„Ç§„É≥„Éà„Ç∞„É´„Éú„Çø„É≥„Å®ÂÆåÂÖ®„Å´Âêå„Åò„Çπ„Çø„Ç§„É´„ÇíÈÅ©Áî®Ôºà‰ΩçÁΩÆ„ÅÆ„ÅøÂ§âÊõ¥Ôºâ
                    const fullStyle = `position: absolute !important; top: 15px !important; left: 15px !important; z-index: 10002 !important; width: ${mobileStyle.width} !important; height: ${mobileStyle.height} !important; background: ${mobileStyle.backgroundColor} !important; border: ${mobileStyle.border} !important; border-radius: ${mobileStyle.borderRadius} !important; backdrop-filter: ${mobileStyle.backdropFilter} !important; display: flex !important; visibility: visible !important; align-items: center !important; justify-content: center !important; padding: 0 !important; margin: 0 !important; transition: none !important; cursor: pointer !important; font-size: 0 !important; box-shadow: ${mobileStyle.boxShadow} !important; transform: none !important; opacity: 1 !important;`;
                    sidebarToggle.setAttribute('style', fullStyle);
                    
                    console.log('üé® Sidebar toggle button synced with main toggle button style');
                }
            };
            
            // Ë§áÊï∞ÂõûÂÆüË°å„Åó„Å¶Á¢∫ÂÆü„Å´Ë°®Á§∫
            setTimeout(forceSidebarToggleDisplay, 100);
            setTimeout(forceSidebarToggleDisplay, 300);
            setTimeout(forceSidebarToggleDisplay, 500);
            
            // PHASE 2: ÂÖ®„Éè„É≥„Éê„Éº„Ç¨„Éº„Éú„Çø„É≥„ÅÆÊù°‰ª∂‰ªò„ÅçË°®Á§∫Ôºà„É≠„Ç∞„Ç§„É≥Âæå„ÅÆ„ÅøÔºâ
            const conditionalShowMobileToggle = () => {
                // „É≠„Ç∞„Ç§„É≥Áä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                const isLoggedIn = document.body.classList.contains('logged-in');
                
                // ÂÖ®„Å¶„ÅÆ„Éè„É≥„Éê„Éº„Ç¨„Éº„Éú„Çø„É≥„ÇíÂØæË±°„Å´„Åô„Çã
                const hamburgerButtons = [
                    document.getElementById('mobileMenuToggle'),
                    document.getElementById('menuToggle'),
                    ...document.querySelectorAll('.mobile-menu-toggle'),
                    ...document.querySelectorAll('.menu-toggle')
                ];
                
                hamburgerButtons.forEach(button => {
                    if (button) {
                        if (isLoggedIn) {
                            // „É≠„Ç∞„Ç§„É≥Âæå„ÅÆ„ÅøË°®Á§∫ÔºàmobileMenuToggle„ÅÆ„ÅøÔºâ
                            if (button.id === 'mobileMenuToggle') {
                                button.classList.remove('login-required');
                                button.classList.remove('hidden');
                                
                                // ÂÆåÂÖ®„Å™„Çπ„Çø„Ç§„É´„É™„Çª„ÉÉ„Éà
                                button.removeAttribute('style');
                                
                                // „É¢„Éê„Ç§„É´Áí∞Â¢ÉÂà§ÂÆöÔºàÁîªÈù¢ÂπÖ768px‰ª•‰∏ã„Åæ„Åü„ÅØ„Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„ÇπÔºâ
                                const isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
                                
                                if (isMobile) {
                                    // Âº∑Âà∂ÁöÑ„Å™„Çπ„Çø„Ç§„É´ÈÅ©Áî®„Åß„Éú„Çø„É≥„ÇíË°®Á§∫
                                    button.style.setProperty('display', 'flex', 'important');
                                    button.style.setProperty('visibility', 'visible', 'important');
                                    button.style.setProperty('opacity', '0.8', 'important');
                                    button.style.setProperty('pointer-events', 'auto', 'important');
                                    button.style.setProperty('position', 'fixed', 'important');
                                    button.style.setProperty('top', '15px', 'important');
                                    button.style.setProperty('left', '15px', 'important');
                                    button.style.setProperty('z-index', '2147483647', 'important');
                                    button.style.setProperty('width', '56px', 'important');
                                    button.style.setProperty('height', '56px', 'important');
                                    button.style.setProperty('background', 'linear-gradient(135deg, #1a1a2e, #0f0f1e)', 'important');
                                    button.style.setProperty('border', '1px solid rgba(255, 255, 255, 0.1)', 'important');
                                    button.style.setProperty('border-radius', '12px', 'important');
                                    button.style.setProperty('color', 'rgba(255, 255, 255, 0.8)', 'important');
                                    button.style.setProperty('cursor', 'pointer', 'important');
                                    button.style.setProperty('align-items', 'center', 'important');
                                    button.style.setProperty('justify-content', 'center', 'important');
                                    console.log('‚úÖ Mobile menu toggle forced visible after login');
                                } else {
                                    // „Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÁí∞Â¢É„Åß„ÅØÈùûË°®Á§∫
                                    button.style.setProperty('display', 'none', 'important');
                                    console.log('üñ•Ô∏è Mobile menu toggle hidden (desktop detected)');
                                }
                            } else {
                                // „Åù„ÅÆ‰ªñ„ÅÆ„Éè„É≥„Éê„Éº„Ç¨„Éº„Éú„Çø„É≥„ÇÇË°®Á§∫
                                button.style.removeProperty('display');
                                button.style.removeProperty('visibility');
                                button.style.removeProperty('opacity');
                                console.log('‚úÖ Other hamburger button displayed after login:', button.id || button.className);
                            }
                        } else {
                            // „É≠„Ç∞„Ç§„É≥Ââç„ÅØÂÖ®„Å¶Âº∑Âà∂ÁöÑ„Å´Èö†„Åô
                            button.style.setProperty('display', 'none', 'important');
                            button.style.setProperty('visibility', 'hidden', 'important');
                            button.style.setProperty('opacity', '0', 'important');
                            console.log('üîí Hamburger button hidden before login:', button.id || button.className);
                        }
                    }
                });
            };
            
            // Ë§áÊï∞ÂõûÂÆüË°å„Åó„Å¶Êù°‰ª∂„Å´Âøú„Åò„Å¶Ë°®Á§∫/ÈùûË°®Á§∫
            setTimeout(conditionalShowMobileToggle, 100);
            setTimeout(conditionalShowMobileToggle, 300);
            setTimeout(conditionalShowMobileToggle, 500);
            setTimeout(conditionalShowMobileToggle, 1000);
            
            // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÊôÇ„Å´„ÇÇ„É¢„Éê„Ç§„É´„Éú„Çø„É≥„ÅÆË°®Á§∫Áä∂ÊÖã„ÇíÊõ¥Êñ∞
            window.addEventListener('resize', () => {
                setTimeout(conditionalShowMobileToggle, 100);
            });
            
            // Start the new initialization system
            if (typeof initializeApp === 'function') {
                initializeApp().catch(error => {
                    console.error('INIT ERROR: New initialization failed:', error);
                });
            } else {
                console.error('INIT ERROR: initializeApp function not found');
            }
        });

        // Debug Menu Functions
        function toggleDebugMenu() {
            const submenu = document.getElementById('debugSubmenu');
            const menuItem = document.querySelector('.debug-menu-item');
            
            if (submenu.style.display === 'none' || !submenu.style.display) {
                submenu.style.display = 'block';
                menuItem.classList.add('expanded');
            } else {
                submenu.style.display = 'none';
                menuItem.classList.remove('expanded');
            }
        }

        window.hardRefresh = function() {
            console.log('üîÑ Hard refresh executing...');
            // Clear all caches first
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => {
                        caches.delete(name);
                    });
                });
            }
            // Force reload with cache bypass
            location.reload(true);
        };

        window.clearLocalStorage = function() {
            try {
                localStorage.clear();
                sessionStorage.clear();
                console.log('üóëÔ∏è Local storage cleared successfully');
                alert('„É≠„Éº„Ç´„É´‰øùÂ≠ò„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü');
            } catch (error) {
                console.error('Failed to clear local storage:', error);
                alert('„É≠„Éº„Ç´„É´‰øùÂ≠ò„Éá„Éº„Çø„ÅÆ„ÇØ„É™„Ç¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        };

        window.toggleConsoleDebug = function() {
            window.debugMode = !window.debugMode;
            console.log('üêõ Debug mode:', window.debugMode ? 'ON' : 'OFF');
            if (window.debugMode) {
                console.log('DEBUG: Console logging enabled');
                alert('„Ç≥„É≥„ÇΩ„Éº„É´„Éá„Éê„ÉÉ„Ç∞„ÅåÊúâÂäπ„Å´„Å™„Çä„Åæ„Åó„ÅüÔºàF12„Åß„Ç≥„É≥„ÇΩ„Éº„É´Á¢∫Ë™çÔºâ');
            } else {
                alert('„Ç≥„É≥„ÇΩ„Éº„É´„Éá„Éê„ÉÉ„Ç∞„ÅåÁÑ°Âäπ„Å´„Å™„Çä„Åæ„Åó„Åü');
            }
        };

        window.exportDebugData = function() {
            const debugData = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                url: location.href,
                localStorageKeys: Object.keys(localStorage),
                sessionStorageKeys: Object.keys(sessionStorage),
                documentReady: document.readyState,
                authState: !!window.currentUser,
                errorLogs: window.errorLogs || []
            };

            const blob = new Blob([JSON.stringify(debugData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `debug_data_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('üìä Debug data exported:', debugData);
            alert('„Éá„Éê„ÉÉ„Ç∞„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü');
        };
    </script>

</body>
</html>